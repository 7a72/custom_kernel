diff --git a/kernel/Kconfig b/kernel/Kconfig
index 67f177f4..def245e5 100644
--- a/kernel/Kconfig
+++ b/kernel/Kconfig
@@ -9,6 +9,15 @@ config KSU
 	  To compile as a module, choose M here: the
 	  module will be called kernelsu.
 
+config KSU_KRETPROBES_SUCOMPAT
+	bool "EXPERIMENTAL: kretprobes for sucompat"
+	depends on KRETPROBES
+	default y
+	help
+	  EXPERIMENTAL: Use kretprobes for hooking getname_flags, mainly for
+	  sucompat. This method will hijack all fs-related syscalls, but
+	  thwarts timing based detections.
+
 config KSU_DEBUG
 	bool "KernelSU debug mode"
 	depends on KSU
diff --git a/kernel/Makefile b/kernel/Makefile
index 732ba2d9..6c209aad 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -8,6 +8,10 @@ kernelsu-objs += ksud.o
 kernelsu-objs += embed_ksud.o
 kernelsu-objs += kernel_compat.o
 
+ifeq ($(CONFIG_KSU_KRETPROBES_SUCOMPAT),y)
+kernelsu-objs += rp_sucompat.o
+endif
+
 kernelsu-objs += selinux/selinux.o
 kernelsu-objs += selinux/sepolicy.o
 kernelsu-objs += selinux/rules.o
diff --git a/kernel/ksu.c b/kernel/ksu.c
index d517c3b5..8320e9aa 100644
--- a/kernel/ksu.c
+++ b/kernel/ksu.c
@@ -11,6 +11,10 @@
 #include "ksu.h"
 #include "throne_tracker.h"
 
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+extern void rp_sucompat_init();
+#endif 
+
 static struct workqueue_struct *ksu_workqueue;
 
 bool ksu_queue_work(struct work_struct *work)
@@ -57,6 +61,10 @@ int __init kernelsu_init(void)
 
 	ksu_throne_tracker_init();
 
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT	
+	rp_sucompat_init();
+#endif
+
 #ifdef CONFIG_KPROBES
 	ksu_sucompat_init();
 	ksu_ksud_init();
diff --git a/kernel/rp_sucompat.c b/kernel/rp_sucompat.c
new file mode 100644
index 00000000..c639dc62
--- /dev/null
+++ b/kernel/rp_sucompat.c
@@ -0,0 +1,108 @@
+#include <linux/version.h>
+#include <linux/kprobes.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/namei.h>
+
+#include "arch.h"
+#include "klog.h"
+#include "ksud.h"
+#include "kernel_compat.h"
+
+static DEFINE_MUTEX(ksu_rp_sucompat_lock);
+
+// struct filename *getname_flags(const char __user *filename, int flags, int *empty)
+// https://elixir.bootlin.com/linux/v4.9.337/source/samples/kprobes/kretprobe_example.c
+
+extern int ksu_getname_flags_kernel(char **kname, int flags);
+
+struct kretprobe *getname_rp;
+
+static int getname_flags_ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	int *flags = (int *)ri->data;
+
+	struct filename *ret = (struct filename *)PT_REGS_RC(regs);
+	if (IS_ERR(ret) || !ret || !ret->name)
+		return 0;
+
+	ksu_getname_flags_kernel((char **)&ret->name, *flags);
+	return 0;
+}
+
+static int getname_flags_entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	int *flags = (int *)ri->data; // as per sample, we store everything on ri->data ?
+	*flags = (int)PT_REGS_PARM2(regs); // keep a copy of arg2
+
+	return 0;
+}
+
+#if 0
+static struct kretprobe getname_kretprobe = {
+	.kp.symbol_name = "getname_flags",
+	.entry_handler = getname_flags_entry_handler,
+	.handler = getname_flags_ret_handler,
+	.data_size = sizeof(int),
+	.maxactive = 20,
+};
+#endif
+
+// kanged from upstrteam
+// this method allows high volume register/unregister
+static struct kretprobe *init_kretprobe(const char *symbol,
+					kretprobe_handler_t entry_handler,
+					kretprobe_handler_t ret_handler,
+					size_t data_size,
+					int maxactive)
+{
+	struct kretprobe *rp = kzalloc(sizeof(struct kretprobe), GFP_KERNEL);
+	if (!rp)
+		return NULL;
+
+	rp->kp.symbol_name = symbol;
+	rp->entry_handler = entry_handler;
+	rp->handler = ret_handler;
+	rp->data_size = data_size;
+	rp->maxactive = maxactive;
+
+	mutex_lock(&ksu_rp_sucompat_lock);
+	int ret = register_kretprobe(rp);
+	mutex_unlock(&ksu_rp_sucompat_lock);
+	if (ret) {
+		kfree(rp);
+		return NULL;
+	}
+	pr_info("rp_sucompat: planted kretprobe at %s: %p\n", rp->kp.symbol_name, rp->kp.addr);
+
+	return rp;
+}
+
+static void destroy_kretprobe(struct kretprobe **rp_ptr)
+{
+	if (!rp_ptr || !*rp_ptr)
+		return;
+
+	mutex_lock(&ksu_rp_sucompat_lock);
+	unregister_kretprobe(*rp_ptr);
+	mutex_unlock(&ksu_rp_sucompat_lock);
+	kfree(*rp_ptr);
+	*rp_ptr = NULL;
+}
+
+void rp_sucompat_exit()
+{
+	pr_info("rp_sucompat: unregister getname_flags!\n");
+	destroy_kretprobe(&getname_rp);
+	// return 0;
+}
+
+void rp_sucompat_init()
+{
+	pr_info("%s: register getname_flags!\n", __func__);
+	getname_rp = init_kretprobe("getname_flags", getname_flags_entry_handler,
+			getname_flags_ret_handler, sizeof(int), 20);
+}
diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index fdfc0d59..2eee6da0 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -189,98 +189,21 @@ int ksu_handle_devpts(struct inode *inode)
 	return 0;
 }
 
-#ifdef CONFIG_KPROBES
-
-static int faccessat_handler_pre(struct kprobe *p, struct pt_regs *regs)
-{
-	struct pt_regs *real_regs = PT_REAL_REGS(regs);
-	int *dfd = (int *)&PT_REGS_PARM1(real_regs);
-	const char __user **filename_user =
-		(const char **)&PT_REGS_PARM2(real_regs);
-	int *mode = (int *)&PT_REGS_PARM3(real_regs);
-
-	return ksu_handle_faccessat(dfd, filename_user, mode, NULL);
-}
-
-static int newfstatat_handler_pre(struct kprobe *p, struct pt_regs *regs)
-{
-	struct pt_regs *real_regs = PT_REAL_REGS(regs);
-	int *dfd = (int *)&PT_REGS_PARM1(real_regs);
-	const char __user **filename_user =
-		(const char **)&PT_REGS_PARM2(real_regs);
-	int *flags = (int *)&PT_REGS_SYSCALL_PARM4(real_regs);
-
-	return ksu_handle_stat(dfd, filename_user, flags);
-}
-
-static int execve_handler_pre(struct kprobe *p, struct pt_regs *regs)
-{
-	struct pt_regs *real_regs = PT_REAL_REGS(regs);
-	const char __user **filename_user =
-		(const char **)&PT_REGS_PARM1(real_regs);
-
-	return ksu_handle_execve_sucompat(AT_FDCWD, filename_user, NULL, NULL,
-					  NULL);
-}
-
-static int pts_unix98_lookup_pre(struct kprobe *p, struct pt_regs *regs)
-{
-	struct inode *inode;
-	struct file *file = (struct file *)PT_REGS_PARM2(regs);
-	inode = file->f_path.dentry->d_inode;
-
-	return ksu_handle_devpts(inode);
-}
-
-static struct kprobe *init_kprobe(const char *name,
-				  kprobe_pre_handler_t handler)
-{
-	struct kprobe *kp = kzalloc(sizeof(struct kprobe), GFP_KERNEL);
-	if (!kp)
-		return NULL;
-	kp->symbol_name = name;
-	kp->pre_handler = handler;
-
-	int ret = register_kprobe(kp);
-	pr_info("sucompat: register_%s kprobe: %d\n", name, ret);
-	if (ret) {
-		kfree(kp);
-		return NULL;
-	}
-
-	return kp;
-}
-
-static void destroy_kprobe(struct kprobe **kp_ptr)
-{
-	struct kprobe *kp = *kp_ptr;
-	if (!kp)
-		return;
-	unregister_kprobe(kp);
-	synchronize_rcu();
-	kfree(kp);
-	*kp_ptr = NULL;
-}
-
-static struct kprobe *su_kps[4];
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+extern void rp_sucompat_exit();
+extern void rp_sucompat_init();
 #endif
-
-// sucompat: permited process can execute 'su' to gain root access.
+// sucompat: permited process can execute ' to gain root access.
 void ksu_sucompat_init()
 {
-#ifdef CONFIG_KPROBES
-	su_kps[0] = init_kprobe(SYS_EXECVE_SYMBOL, execve_handler_pre);
-	su_kps[1] = init_kprobe(SYS_FACCESSAT_SYMBOL, faccessat_handler_pre);
-	su_kps[2] = init_kprobe(SYS_NEWFSTATAT_SYMBOL, newfstatat_handler_pre);
-	su_kps[3] = init_kprobe("pts_unix98_lookup", pts_unix98_lookup_pre);
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+	rp_sucompat_init();
 #endif
 }
 
 void ksu_sucompat_exit()
 {
-#ifdef CONFIG_KPROBES
-	for (int i = 0; i < ARRAY_SIZE(su_kps); i++) {
-		destroy_kprobe(&su_kps[i]);
-	}
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+	rp_sucompat_exit();
 #endif
 }
