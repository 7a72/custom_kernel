From 5de57fcc7ba4ceb6a3be06a25962bb8442e9e673 Mon Sep 17 00:00:00 2001
From: 7a72 <git@zrlab.org>
Date: Mon, 29 Sep 2025 14:16:10 +0000
Subject: [PATCH 2/3] FROMGIT: treewide: Import oplus module

- Import :
  - drivers/soc/oplus/storage
  - drivers/soc/oplus/oplus_resctrl
  - kernel/locking/sa_common_struct.h
  - kernel/locking/oplus_locking.c
  - kernel/locking/locking_main.h

- Checked out from https://github.com/OnePlusOSS/android_kernel_modules_and_devicetree_oneplus_sm8650/commit/c6b8b47a2de13527e87c94057072d436213902eb

Co-Authored-by: pswbuild <pswbuild@oppo.com>
---
 drivers/soc/Kconfig                           |    2 +
 drivers/soc/Makefile                          |    2 +
 drivers/soc/oplus/oplus_resctrl/Kbuild        |    8 +
 drivers/soc/oplus/oplus_resctrl/Kconfig       |   14 +
 drivers/soc/oplus/oplus_resctrl/Makefile      |    8 +
 drivers/soc/oplus/oplus_resctrl/iocost.c      |  165 +++
 drivers/soc/oplus/oplus_resctrl/resctrl.c     |  232 +++
 drivers/soc/oplus/oplus_resctrl/resctrl.h     |  176 +++
 drivers/soc/oplus/storage/Kconfig             |    8 +
 drivers/soc/oplus/storage/Makefile            |    5 +
 drivers/soc/oplus/storage/README.md           |   14 +
 drivers/soc/oplus/storage/bp/OplusStorage.h   |   34 +
 .../soc/oplus/storage/bp/OplusStorageDxe.c    |  144 ++
 .../soc/oplus/storage/bp/OplusStorageDxe.h    |   84 ++
 .../soc/oplus/storage/bp/OplusStorageDxe.inf  |  103 ++
 drivers/soc/oplus/storage/common/README.md    |    2 +
 .../soc/oplus/storage/common/fmonitor/Kconfig |    6 +
 .../oplus/storage/common/fmonitor/Makefile    |    7 +
 .../common/fmonitor/oplus_file_monitor.c      |  326 +++++
 .../oplus/storage/common/io_metrics/Kconfig   |   19 +
 .../oplus/storage/common/io_metrics/Makefile  |   27 +
 .../storage/common/io_metrics/abnormal_io.c   |  896 ++++++++++++
 .../storage/common/io_metrics/abnormal_io.h   |   15 +
 .../storage/common/io_metrics/block_metrics.c |  666 +++++++++
 .../storage/common/io_metrics/block_metrics.h |   73 +
 .../storage/common/io_metrics/f2fs_metrics.c  |  431 ++++++
 .../storage/common/io_metrics/f2fs_metrics.h  |   12 +
 .../common/io_metrics/io_metrics_entry.c      |   73 +
 .../common/io_metrics/io_metrics_entry.h      |   94 ++
 .../oplus/storage/common/io_metrics/procfs.c  |  492 +++++++
 .../oplus/storage/common/io_metrics/procfs.h  |   10 +
 .../storage/common/io_metrics/ufs_metrics.c   |  259 ++++
 .../storage/common/io_metrics/ufs_metrics.h   |   12 +
 drivers/soc/oplus/storage/include/storage.h   |   11 +
 .../storage/storage_feature_in_module/Kconfig |    5 +
 .../storage_feature_in_module/Makefile        |    6 +
 .../common/oplus_f2fslog_storage/Kconfig      |    7 +
 .../common/oplus_f2fslog_storage/Makefile     |    5 +
 .../oplus_f2fslog_storage.c                   |  229 +++
 .../common/oplus_uprobe/Kconfig               |    7 +
 .../common/oplus_uprobe/Makefile              |    7 +
 .../common/oplus_uprobe/oplus_uprobe.c        | 1296 +++++++++++++++++
 .../common/oplus_uprobe/oplus_uprobe.h        |    4 +
 .../common/storage_log/Kconfig                |    7 +
 .../common/storage_log/Makefile               |    3 +
 .../common/storage_log/storage_log.c          |  240 +++
 .../common/ufs_oplus_dbg/Kconfig              |    9 +
 .../common/ufs_oplus_dbg/Makefile             |    2 +
 .../common/ufs_oplus_dbg/ufs-oplus-dbg.c      | 1215 ++++++++++++++++
 .../common/ufs_oplus_dbg/ufs-oplus-dbg.h      |  209 +++
 .../common/wq_dynamic_priority/Kconfig        |    6 +
 .../common/wq_dynamic_priority/Makefile       |    5 +
 .../oplus_wq_dynamic_priority.c               |  236 +++
 .../oplus_wq_dynamic_priority.h               |  174 +++
 kernel/locking/Makefile                       |    2 +-
 kernel/locking/locking_main.h                 |  165 +++
 kernel/locking/oplus_locking.c                |  885 +++++++++++
 kernel/locking/sa_common_struct.h             |  181 +++
 58 files changed, 9334 insertions(+), 1 deletion(-)
 create mode 100644 drivers/soc/oplus/oplus_resctrl/Kbuild
 create mode 100644 drivers/soc/oplus/oplus_resctrl/Kconfig
 create mode 100644 drivers/soc/oplus/oplus_resctrl/Makefile
 create mode 100644 drivers/soc/oplus/oplus_resctrl/iocost.c
 create mode 100644 drivers/soc/oplus/oplus_resctrl/resctrl.c
 create mode 100644 drivers/soc/oplus/oplus_resctrl/resctrl.h
 create mode 100644 drivers/soc/oplus/storage/Kconfig
 create mode 100644 drivers/soc/oplus/storage/Makefile
 create mode 100644 drivers/soc/oplus/storage/README.md
 create mode 100644 drivers/soc/oplus/storage/bp/OplusStorage.h
 create mode 100644 drivers/soc/oplus/storage/bp/OplusStorageDxe.c
 create mode 100644 drivers/soc/oplus/storage/bp/OplusStorageDxe.h
 create mode 100644 drivers/soc/oplus/storage/bp/OplusStorageDxe.inf
 create mode 100644 drivers/soc/oplus/storage/common/README.md
 create mode 100644 drivers/soc/oplus/storage/common/fmonitor/Kconfig
 create mode 100644 drivers/soc/oplus/storage/common/fmonitor/Makefile
 create mode 100644 drivers/soc/oplus/storage/common/fmonitor/oplus_file_monitor.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/Kconfig
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/Makefile
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/abnormal_io.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/abnormal_io.h
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/block_metrics.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/block_metrics.h
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.h
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.h
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/procfs.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/procfs.h
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.c
 create mode 100644 drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.h
 create mode 100644 drivers/soc/oplus/storage/include/storage.h
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/Kconfig
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/Makefile
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Kconfig
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Makefile
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/oplus_f2fslog_storage.c
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Kconfig
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Makefile
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.c
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.h
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Kconfig
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Makefile
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/storage_log.c
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Kconfig
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Makefile
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.c
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.h
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Kconfig
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Makefile
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.c
 create mode 100644 drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.h
 create mode 100644 kernel/locking/locking_main.h
 create mode 100644 kernel/locking/oplus_locking.c
 create mode 100644 kernel/locking/sa_common_struct.h

diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index e461c0711..8aac6ceba 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -27,5 +27,7 @@ source "drivers/soc/ti/Kconfig"
 source "drivers/soc/ux500/Kconfig"
 source "drivers/soc/versatile/Kconfig"
 source "drivers/soc/xilinx/Kconfig"
+source "drivers/soc/oplus/oplus_resctrl/Kconfig"
+source "drivers/soc/oplus/storage/Kconfig"
 
 endmenu
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 69ba6508c..ea17e8b27 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -33,3 +33,5 @@ obj-y				+= ti/
 obj-$(CONFIG_ARCH_U8500)	+= ux500/
 obj-$(CONFIG_PLAT_VERSATILE)	+= versatile/
 obj-y				+= xilinx/
+obj-y				+= oplus/oplus_resctrl/
+obj-y				+= oplus/storage/
diff --git a/drivers/soc/oplus/oplus_resctrl/Kbuild b/drivers/soc/oplus/oplus_resctrl/Kbuild
new file mode 100644
index 000000000..336b96298
--- /dev/null
+++ b/drivers/soc/oplus/oplus_resctrl/Kbuild
@@ -0,0 +1,8 @@
+obj-$(CONFIG_OPLUS_RESCTRL) += oplus_resctrl.o
+
+oplus_resctrl-y := resctrl.o
+oplus_resctrl-$(CONFIG_OPLUS_RESCTRL) += iocost.o
+
+ifeq ($(OPLUS_OUT_OF_TREE_KO),y)
+ccflags-y += -DCONFIG_OPLUS_RESCTRL=1
+endif
diff --git a/drivers/soc/oplus/oplus_resctrl/Kconfig b/drivers/soc/oplus/oplus_resctrl/Kconfig
new file mode 100644
index 000000000..9b4a60470
--- /dev/null
+++ b/drivers/soc/oplus/oplus_resctrl/Kconfig
@@ -0,0 +1,14 @@
+config OPLUS_RESCTRL
+	tristate "oplus resctrl module"
+	depends on BLOCK
+	default y
+	help
+	  Support oplus resctrl
+
+config OPLUS_RESCTRL_DEBUG
+	bool "oplus resctrl debug"
+	depends on OPLUS_RESCTRL
+	default n
+	help
+	  use oplus resctrl debug log
+
diff --git a/drivers/soc/oplus/oplus_resctrl/Makefile b/drivers/soc/oplus/oplus_resctrl/Makefile
new file mode 100644
index 000000000..56a05a66c
--- /dev/null
+++ b/drivers/soc/oplus/oplus_resctrl/Makefile
@@ -0,0 +1,8 @@
+KBUILD_OPTIONS += CONFIG_OPLUS_RESCTRL=m
+KBUILD_OPTIONS += OPLUS_OUT_OF_TREE_KO=y
+
+KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build
+M ?= $(shell pwd)
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNEL_SRC) M=$(M) $(KBUILD_OPTIONS) $(@)
diff --git a/drivers/soc/oplus/oplus_resctrl/iocost.c b/drivers/soc/oplus/oplus_resctrl/iocost.c
new file mode 100644
index 000000000..2e14b1faa
--- /dev/null
+++ b/drivers/soc/oplus/oplus_resctrl/iocost.c
@@ -0,0 +1,165 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+* Copyright (C) 2023 Oplus. All rights reserved.
+*/
+#include "resctrl.h"
+
+#if LINUX_KERNEL_601
+#include <linux/blk-mq.h>
+#endif
+
+#define IOC_DEF_MIN_IOPS 640
+#define IOC_DEF_PPM_HIGH 80
+#define IOC_DEF_PPM_LOW (IOC_DEF_PPM_HIGH >> 2)
+
+static int ioc_ppm_high = 0;
+struct iocost_config iocost_config = {0};
+
+DEFINE_PER_CPU(struct ioc_dist_stat, ioc_dist_stat) = { { 0 } };
+EXPORT_PER_CPU_SYMBOL(ioc_dist_stat);
+
+static void ioc_dist_update_stat(int rw, u64 on_q_us, u64 rq_wait_us,
+				 int segments)
+{
+	int i = 0;
+	int j = 0;
+	while (segments > 0) {
+		if (i >= (IOC_DIST_SEGMENTS - 1))
+			break;
+		i++;
+		segments = segments >> 1;
+	}
+
+	if (rw == RESCTRL_READ) {
+		if (ioc_high_read(on_q_us))
+			this_cpu_inc(ioc_dist_stat.rw[rw].high);
+	}
+	else {
+		if (ioc_high_write(on_q_us))
+			this_cpu_inc(ioc_dist_stat.rw[rw].high);
+	}
+
+	while (on_q_us > 0) {
+		if (j >= (IOC_DIST_TIMESTAT - 1))
+			break;
+		j++;
+		on_q_us = on_q_us >> 1;
+	}
+
+	this_cpu_inc(ioc_dist_stat.rw[rw].dist[i][j]);
+}
+
+void ioc_dist_clear_stat(void)
+{
+	int cpu;
+
+	for_each_online_cpu(cpu) {
+		struct ioc_dist_stat *this = &per_cpu(ioc_dist_stat, cpu);
+		memset(this, 0, sizeof(struct ioc_dist_stat));
+	}
+}
+
+void ioc_dist_get_stat(int rw, u64 *request, int time_dist)
+{
+	int cpu;
+	int i;
+
+	for_each_online_cpu(cpu) {
+		struct ioc_dist_stat *this = &per_cpu(ioc_dist_stat, cpu);
+
+		for (i = 0; i < IOC_DIST_SEGMENTS; i++)
+			request[i] += this->rw[rw].dist[i][time_dist];
+	}
+}
+
+void android_vh_blk_account_io_done_handler(void *unused, struct request *rq)
+{
+	unsigned int segments;
+	int rw = RESCTRL_READ;
+	u64 on_q_ns = ktime_get_ns() - rq->start_time_ns;
+	u64 rq_wait_ns = 0;
+	segments = blk_rq_stats_sectors(rq) >> 3;
+
+	switch (req_op(rq) & REQ_OP_MASK) {
+	case REQ_OP_READ:
+		rw = RESCTRL_READ;
+		break;
+	case REQ_OP_WRITE:
+		rw = RESCTRL_WRITE;
+		break;
+	default:
+		resctrl_debug("resctrl android_vh_blk_account_io_done_handler op=%d, error no support!",
+					req_op(rq));
+		return;
+	}
+
+	trace_printk("resctrl rq_qos_done rw=%d req_op=0x%x on_q=%lluus rq_wait=%lluus segments=%u, %d\n",
+				rw, req_op(rq), on_q_ns / 1000, rq_wait_ns / 1000, segments,
+				blk_rq_sectors(rq));
+	/* update the stat */
+	ioc_dist_update_stat(rw, on_q_ns / 1000, rq_wait_ns / 1000, segments);
+	return;
+}
+
+static void ioc_lat_calc(u64 *nr_high, u64 *nr_all)
+{
+	int cpu, i, j, rw;
+
+	for_each_online_cpu(cpu) {
+		struct ioc_dist_stat *this = &per_cpu(ioc_dist_stat, cpu);
+
+		for (rw = RESCTRL_READ; rw <= RESCTRL_WRITE; rw++) {
+			u64 this_all = 0;
+			u64 this_high = this->rw[rw].high;
+
+			for (i = 0; i < IOC_DIST_SEGMENTS; i++) {
+				for (j = 0; j < IOC_DIST_TIMESTAT; j++) {
+					this_all += this->rw[rw].dist[i][j];
+				}
+			}
+
+			nr_all[rw] += this_all - this->rw[rw].last_sum;
+			nr_high[rw] += this_high - this->rw[rw].last_high;
+
+			this->rw[rw].last_sum = this_all;
+			this->rw[rw].last_high = this_high;
+		}
+	}
+}
+
+void ioc_timer_fn(struct timer_list *timer)
+{
+	u64 nr_high[2] = {0};
+	u64 nr_all[2] = {0};
+
+	ioc_lat_calc(nr_high, nr_all);
+	trace_printk("### nr_high=%llu, nr_all=%llu ppm=%d\n", nr_high[0], nr_all[0], ioc_ppm_high);
+	if (nr_all[0] >= IOC_DEF_MIN_IOPS) {
+		if ((nr_high[0]*100/nr_all[0])  >= IOC_DEF_PPM_HIGH) {
+			if (ioc_ppm_high == 0) {
+				printk("resctrl set high ppm\n");
+				ioc_ppm_high = 1;
+			}
+		} else if ((nr_high[0] * 100 /nr_all[0])  < IOC_DEF_PPM_LOW) {
+			if (ioc_ppm_high != 0) {
+				printk("resctrl set low ppm\n");
+				ioc_ppm_high = 0;
+			}
+		}
+	} else {
+		if (ioc_ppm_high != 0) {
+			printk("resctrl clear high ppm\n");
+			ioc_ppm_high = 0;
+		}
+	}
+
+	if (iocost_config.ppm_start) {
+		iocost_config.timer.expires = jiffies + 1*HZ;
+		add_timer(&iocost_config.timer);
+	}
+}
+
+int ioc_iop_read(void)
+{
+	return ioc_ppm_high;
+}
diff --git a/drivers/soc/oplus/oplus_resctrl/resctrl.c b/drivers/soc/oplus/oplus_resctrl/resctrl.c
new file mode 100644
index 000000000..eeb4991f5
--- /dev/null
+++ b/drivers/soc/oplus/oplus_resctrl/resctrl.c
@@ -0,0 +1,232 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+* Copyright (C) 2023 Oplus. All rights reserved.
+*/
+
+#include <linux/string.h>
+#include "resctrl.h"
+#include "linux/proc_fs.h"
+#include "linux/module.h"
+
+#define OPLUS_RESCTRL_PROC "oplus_resctrl"
+#define RESCTRL_BUFSIZE_MAX 4096
+#define RESCTRL_CONFIG_MAX 64
+
+void resctrl_printk(int log_level, const char *func, const char *fmt, ...)
+{
+	/* todo */
+	return;
+}
+
+static ssize_t iocost_ppm_read(struct file *filp, char __user *buff,
+			       size_t count, loff_t *off)
+{
+	char page[32] = { 0 };
+	int len = 0;
+
+	len += sprintf(page, "%d\n", ioc_iop_read());
+
+	return sched_data_to_user(buff, count, off, page, len);
+}
+
+static ssize_t iocost_ppm_write(struct file *filp, const char __user *buff,
+			      size_t count, loff_t *off)
+{
+	char str[RESCTRL_CONFIG_MAX] = {0};
+	u32 new_start;
+	int ret;
+
+	if(count > (RESCTRL_CONFIG_MAX - 1) || count == 0)
+		return -EFAULT;
+
+	if (copy_from_user(str, buff, count))
+		return -EFAULT;
+	ret = kstrtouint(str, 10, &new_start);
+	if (ret)
+		return ret;
+	if (new_start == iocost_config.ppm_start)
+		return count;
+	if (new_start) {
+		iocost_config.ppm_start = new_start;
+		iocost_config.timer.expires = jiffies + 1*HZ;
+		add_timer(&iocost_config.timer);
+	} else {
+		iocost_config.ppm_start = new_start;
+		iocost_config.timer.expires = jiffies + 1*HZ;
+		del_timer(&iocost_config.timer);
+	}
+
+	return count;
+}
+
+static const struct proc_ops proc_iocost_ppm_fops = {
+	.proc_read = iocost_ppm_read,
+	.proc_write = iocost_ppm_write,
+	.proc_lseek = default_llseek,
+};
+
+static ssize_t ioc_dist_read(int rw, char __user *buff, size_t count,
+			     loff_t *off)
+{
+	int len = 0;
+	int ret_len = 0;
+	int i, j;
+	char *const time_str[] = { "1us",      "2us",      "4us",
+				   "8us",      "16us",     "32us",
+				   "64us",     "128us",    "256us",
+				   "512us",    "1024us",   "2048us",
+				   "4096us",   "8192us",   "16384us",
+				   "32768us",  "65536us",  "131072us",
+				   "262144us", "524288us", "other" };
+	char *page = kzalloc(RESCTRL_BUFSIZE_MAX, GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	len += sprintf(page + len,
+		       "%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s"
+		       "%-10s\n",
+		       "latency", "1", "2", "4", "8", "16", "32", "64", "128",
+		       "256", "other");
+
+	for (i = 0; i < IOC_DIST_TIMESTAT; i++) {
+		u64 request[IOC_DIST_SEGMENTS] = { 0 };
+
+		ioc_dist_get_stat(rw, request, i);
+
+		len += sprintf(page + len, "%-10s", time_str[i]);
+		for (j = 0; j < IOC_DIST_SEGMENTS; j++)
+			len += sprintf(page + len, "%-10llu", request[j]);
+		len += sprintf(page + len, "\n");
+	}
+
+	ret_len = sched_data_to_user(buff, count, off, page, len);
+	kfree(page);
+	return ret_len;
+}
+
+static ssize_t ioc_dist_read_read(struct file *filp, char __user *buff,
+				  size_t count, loff_t *off)
+{
+	return ioc_dist_read(RESCTRL_READ, buff, count, off);
+}
+
+static ssize_t ioc_dist_write_read(struct file *filp, char __user *buff,
+				   size_t count, loff_t *off)
+{
+	return ioc_dist_read(RESCTRL_WRITE, buff, count, off);
+}
+
+static void  ioc_parse_config(char *key, char *value)
+{
+	int ret;
+	if (strcmp(key, "read_lat") == 0) {
+		ret = kstrtouint(value, 10, &iocost_config.read_lat);
+		if (ret)
+			printk("resctrl ioc_parse_config err\n");
+		printk("resctrl ioc_parse_config read_lat=%d\n", iocost_config.read_lat);
+	}
+
+	if (strcmp(key, "write_lat") == 0) {
+		ret = kstrtouint(value, 10, &iocost_config.write_lat);
+		if (ret)
+			printk("resctrl ioc_parse_config err\n");
+		printk("resctrl ioc_parse_config write_lat=%d\n", iocost_config.write_lat);
+	}
+}
+
+static ssize_t ioc_dist_write(struct file *filp, const char __user *buff,
+			      size_t count, loff_t *off)
+{
+	char str[RESCTRL_CONFIG_MAX] = {0};
+	char *sptr;
+	char *split = NULL;
+	char *key = NULL;
+
+	if(count > (RESCTRL_CONFIG_MAX - 1) || count == 0)
+		return -EFAULT;
+
+	if (copy_from_user(str, buff, count))
+		return -EFAULT;
+	sptr = str;
+
+	split = strsep(&sptr, " ");
+	while (split != NULL) {
+		key = strsep(&split, "=");
+		if (key && split) {
+			ioc_parse_config(key, split);
+		}
+
+		split = strsep(&sptr, " ");
+	}
+
+	ioc_dist_clear_stat();
+	return count;
+}
+
+static const struct proc_ops proc_ioc_dist_read_fops = {
+	.proc_read = ioc_dist_read_read,
+	.proc_write = ioc_dist_write,
+	.proc_lseek = default_llseek,
+};
+
+static const struct proc_ops proc_ioc_dist_write_fops = {
+	.proc_read = ioc_dist_write_read,
+	.proc_write = ioc_dist_write,
+	.proc_lseek = default_llseek,
+};
+
+static int __init oplus_resctrl_init(void)
+{
+	int ret = 0;
+	struct proc_dir_entry *pentry_dir = NULL;
+	struct proc_dir_entry *pentry = NULL;
+
+	pentry_dir = proc_mkdir(OPLUS_RESCTRL_PROC, NULL);
+	if (!pentry_dir) {
+		resctrl_err("create dir failed.\n");
+		return -ENOENT;
+	}
+
+	pentry = proc_create("iocost_ppm", S_IRUGO | S_IWUGO, pentry_dir,
+			     &proc_iocost_ppm_fops);
+	if (!pentry) {
+		resctrl_err("create iocost_ppm failed.\n");
+		goto err;
+	}
+	pentry = proc_create("ioc_dist_read", S_IRUGO | S_IWUGO, pentry_dir,
+			     &proc_ioc_dist_read_fops);
+	if (!pentry) {
+		resctrl_err("create ioc_dist_read failed.\n");
+		goto err;
+	}
+
+	pentry = proc_create("ioc_dist_write", S_IRUGO | S_IWUGO, pentry_dir,
+			     &proc_ioc_dist_write_fops);
+	if (!pentry) {
+		resctrl_err("create ioc_dist_write failed.\n");
+		goto err;
+	}
+
+	timer_setup(&iocost_config.timer, ioc_timer_fn, 0);
+	iocost_config.ppm_start = 1;
+	iocost_config.timer.expires = jiffies + 1*HZ;
+	add_timer(&iocost_config.timer);
+
+	return ret;
+err:
+	remove_proc_entry(OPLUS_RESCTRL_PROC, NULL);
+	return -ENOENT;
+}
+
+static void __exit oplus_resctrl_exit(void)
+{
+	del_timer(&iocost_config.timer);
+	remove_proc_subtree(OPLUS_RESCTRL_PROC, NULL);
+	printk("oplus resctrl module exit\n");
+}
+
+module_init(oplus_resctrl_init);
+module_exit(oplus_resctrl_exit);
+
+MODULE_DESCRIPTION("oplus_resctrl");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/oplus/oplus_resctrl/resctrl.h b/drivers/soc/oplus/oplus_resctrl/resctrl.h
new file mode 100644
index 000000000..0b3ac4036
--- /dev/null
+++ b/drivers/soc/oplus/oplus_resctrl/resctrl.h
@@ -0,0 +1,176 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+* Copyright (C) 2023 Oplus. All rights reserved.
+*/
+#ifndef _RESCTRL_H_
+#define _RESCTRL_H_
+#include <linux/compiler_types.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+#include <linux/blkdev.h>
+#include <linux/version.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(a, b, c)                                                \
+	(((a) << 16) + ((b) << 8) + ((c) > 255 ? 255 : (c)))
+#endif
+
+#ifndef LINUX_VERSION_CODE
+#error "Need LINUX_VERSION_CODE"
+#endif
+
+#define LINUX_KERNEL_601                                                       \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)) &&                   \
+	 (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 256)))
+#define LINUX_KERNEL_515                                                       \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)) &&                   \
+	 (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 256)))
+#define LINUX_KERNEL_510                                                       \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)) &&                   \
+	 (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 256)))
+#define LINUX_KERNEL_504                                                       \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) &&                    \
+	 (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 256)))
+#define LINUX_KERNEL_419                                                       \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)) &&                   \
+	 (LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 256)))
+
+#if (!LINUX_KERNEL_601 && !LINUX_KERNEL_515 && !LINUX_KERNEL_510 && !LINUX_KERNEL_419 &&            \
+	 !LINUX_KERNEL_504)
+#error "Kernel version not supported"
+#endif
+
+enum {
+	RESCTRL_LOG_LEVEL_ERROR,
+	RESCTRL_LOG_LEVEL_WARN,
+	RESCTRL_LOG_LEVEL_NOTICE,
+	RESCTRL_LOG_LEVEL_INFO,
+	RESCTRL_LOG_LEVEL_DEBUG,
+	RESCTRL_LOG_LEVEL_TEMP,
+};
+
+/*
+ * we know min is 4K and max is 512K
+ * but we still keep the 1 and other col
+ */
+#define IOC_DIST_TIMESTAT 21
+#define IOC_DIST_SEGMENTS 10
+
+#define RESCTRL_READ 0
+#define RESCTRL_WRITE 1
+
+struct ioc_dist_rw {
+	u64 dist[IOC_DIST_SEGMENTS][IOC_DIST_TIMESTAT];
+	u64 high;
+	u64 last_sum;
+	u64 last_high;
+};
+
+struct ioc_dist_stat {
+	struct ioc_dist_rw rw[2];
+};
+
+struct iocost_config {
+	struct timer_list timer;
+	u32 read_lat;
+	u32 write_lat;
+	u32 ppm_start;
+};
+
+extern struct iocost_config iocost_config;
+
+__printf(3, 4) void resctrl_printk(int log_level, const char *func,
+				   const char *fmt, ...);
+
+#define resctrl_err(fmt, ...)                                                  \
+	resctrl_printk(RESCTRL_LOG_LEVEL_ERROR, __func__, KERN_ERR fmt,        \
+		       ##__VA_ARGS__)
+#define resctrl_warn(fmt, ...)                                                 \
+	resctrl_printk(RESCTRL_LOG_LEVEL_WARN, __func__, KERN_WARNING fmt,     \
+		       ##__VA_ARGS__)
+#ifdef CONFIG_RESCTRL_DEBUG
+#define resctrl_notice(fmt, ...)                                               \
+	resctrl_printk(RESCTRL_LOG_LEVEL_NOTICE, __func__, KERN_NOTICE fmt,    \
+		       ##__VA_ARGS__)
+#define resctrl_info(fmt, ...)                                                 \
+	resctrl_printk(RESCTRL_LOG_LEVEL_INFO, __func__, KERN_INFO fmt,        \
+		       ##__VA_ARGS__)
+#define resctrl_debug(fmt, ...)                                                \
+	resctrl_printk(RESCTRL_LOG_LEVEL_DEBUG, __func__, KERN_DEBUG fmt,      \
+		       ##__VA_ARGS__)
+#define resctrl_temp(fmt, ...)                                                 \
+	resctrl_printk(RESCTRL_LOG_LEVEL_TEMP, __func__, KERN_DEBUG fmt,       \
+		       ##__VA_ARGS__)
+#else
+#define resctrl_notice(sbi, fmt, ...)                                          \
+	do {                                                                   \
+	} while (0)
+#define resctrl_info(sbi, fmt, ...)                                            \
+	do {                                                                   \
+	} while (0)
+#define resctrl_debug(sbi, fmt, ...)                                           \
+	do {                                                                   \
+	} while (0)
+#define resctrl_temp(sbi, fmt, ...)                                            \
+	do {                                                                   \
+	} while (0)
+#endif
+
+#define REGISTER_TRACE_VH(vender_hook, handler)                                \
+{                                                                      \
+	ret = register_trace_##vender_hook(handler, NULL);             \
+	if (ret) {                                                     \
+		pr_info("failed to register_" #vender_hook             \
+			", ret=%d\n",                                  \
+			ret);                                          \
+		return ret;                                            \
+	}                                                              \
+}
+
+#define UNREGISTER_TRACE_VH(vender_hook, handler)                              \
+{                                                                      \
+	ret = unregister_trace_##vender_hook(handler, NULL);           \
+	pr_info("%s handler register success", #handler);              \
+}
+
+static inline ssize_t sched_data_to_user(char __user *buff, size_t count,
+					 loff_t *off, char *format_str, int len)
+{
+	if (len > *off)
+		len -= *off;
+	else
+		len = 0;
+	if (copy_to_user(buff, format_str, (len < count ? len : count)))
+		return -EFAULT;
+	*off += len < count ? len : count;
+
+	return (len < count ? len : count);
+}
+
+void android_vh_blk_account_io_done_handler(void *unused, struct request *rq);
+
+int  ioc_iop_read(void);
+void ioc_dist_clear_stat(void);
+void ioc_dist_get_stat(int rw, u64 *request, int time_dist);
+void ioc_timer_fn(struct timer_list *timer);
+
+static inline bool ioc_high_read(u32 value) {
+	if (iocost_config.read_lat == 0)
+		return false;
+
+	if (value > iocost_config.read_lat)
+		return true;
+	return false;
+}
+
+static inline bool ioc_high_write(u32 value) {
+	if (iocost_config.write_lat == 0)
+		return false;
+
+	if (value > iocost_config.write_lat)
+		return true;
+	return false;
+}
+
+#endif /* _RESCTRL_H_ */
diff --git a/drivers/soc/oplus/storage/Kconfig b/drivers/soc/oplus/storage/Kconfig
new file mode 100644
index 000000000..e52838949
--- /dev/null
+++ b/drivers/soc/oplus/storage/Kconfig
@@ -0,0 +1,8 @@
+
+config OPLUS_FEATURE_STORAGE_IO_METRICS
+	tristate "config storage io metrics"
+	default y
+	help
+	  The function of this module is to collect various metrics on the IO path
+
+source "drivers/soc/oplus/storage/common/fmonitor/Kconfig"
diff --git a/drivers/soc/oplus/storage/Makefile b/drivers/soc/oplus/storage/Makefile
new file mode 100644
index 000000000..260435d19
--- /dev/null
+++ b/drivers/soc/oplus/storage/Makefile
@@ -0,0 +1,5 @@
+GCOV_PROFILE := y
+#ifdef OPLUS_FEATURE_STORAGE_IO_METRICS
+obj-$(CONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS) 	+= common/io_metrics/
+#endif /*OPLUS_FEATURE_STORAGE_IO_METRICS*/
+obj-y	+= common/fmonitor/
diff --git a/drivers/soc/oplus/storage/README.md b/drivers/soc/oplus/storage/README.md
new file mode 100644
index 000000000..4140899c4
--- /dev/null
+++ b/drivers/soc/oplus/storage/README.md
@@ -0,0 +1,14 @@
+# 目录结构说明
+## common
+存放所有平台通用模块代码
+## mtk
+存放MTK平台特有模块
+## qcom
+存放qcom平台特有模块代码
+# 开发feature说明
+1. 独立的feature模块放在对应目录下独立的子目录
+2. 当前目录下的Kconfig、Makefile为in-tree编译方式存在（OKI），out-of-tree解耦后的编译用不到
+3. 匹配不同版本的内核可以采用LINUX_VERSION_CODE、KERNEL_VERSION()去控制
+# 编译说明
+1. 子目录的编译采用out-of-tree方式编译，修改仓库oplus/kernel/build中相应的配置
+2. 子目录的编译采用in-tree方式编译，修改当前目录的Kconfig
diff --git a/drivers/soc/oplus/storage/bp/OplusStorage.h b/drivers/soc/oplus/storage/bp/OplusStorage.h
new file mode 100644
index 000000000..67a98f78a
--- /dev/null
+++ b/drivers/soc/oplus/storage/bp/OplusStorage.h
@@ -0,0 +1,34 @@
+/** @file
+  Oplus Storage protocol as defined in the UEFI 2.0 specification.
+
+  The Oplus StorageO protocol is used to abstract oplus storage drivers
+
+  Copyright (c) 2006 - 2018, OPLUS All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+ **/
+#ifndef __OPLUS_STORAGE_H__
+#define __OPLUS_STORAGE_H__
+#include "BlockIo.h"
+typedef struct _EFI_BLOCK_IO_PROTOCOL  EFI_BLOCK_IO_PROTOCOL;
+typedef struct __EFI_OPLUS_STORAGE_PROTOCOL EFI_OPLUS_STORAGE_PROTOCOL;
+#define EFI_OPLUS_STORAGE_PROTOCOL_GUID \
+{ \
+	0x62b1b2da, 0xd0df, 0x4531, {0x80, 0xa4, 0xab, 0xe7, 0xa3, 0xff, 0xdf, 0x78 } \
+}
+
+typedef
+EFI_STATUS
+(EFIAPI * EFI_OPLUS_FW_OPERATION)(
+    IN EFI_OPLUS_STORAGE_PROTOCOL *This,
+    IN EFI_BLOCK_IO_PROTOCOL *blockio,
+    VOID *in,
+    VOID *out
+);
+
+struct __EFI_OPLUS_STORAGE_PROTOCOL {
+	EFI_OPLUS_FW_OPERATION  SdccFwOps;
+};
+
+extern EFI_GUID gEfiOplusStorageProtocolGuid;
+#endif //__OPLUS_STORAGE_H__
diff --git a/drivers/soc/oplus/storage/bp/OplusStorageDxe.c b/drivers/soc/oplus/storage/bp/OplusStorageDxe.c
new file mode 100644
index 000000000..dd2fdfb78
--- /dev/null
+++ b/drivers/soc/oplus/storage/bp/OplusStorageDxe.c
@@ -0,0 +1,144 @@
+/**
+* @file    OplusStorageDxe.c
+* @brief   Universal Flash Storage (UFS) Dxe Driver
+*
+*  Copyright (c) 2013 - 2022 OPLUS All rights reserved.
+*/
+
+
+/*=============================================================================
+                               EDIT HISTORY
+
+
+ when            who   what, where, why
+ ----------      ---   -----------------------------------------------------------
+ 2023-5-26	 zhoumaowei Add for decoupling of ufs drivers
+ =============================================================================*/
+#include <Uefi.h>
+#include <Library/BaseLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/DebugLib.h>
+#include <Library/IoLib.h>
+#include <Library/PcdLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UncachedMemoryAllocationLib.h>
+#include <Library/ArmLib.h>
+#include <Library/SerialPortShLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/StorSecApp.h>
+#include <Library/UefiCfgLib.h>
+#include <Protocol/BlockIo.h>
+#include <Protocol/BlockIo2.h>
+#include <Protocol/BlockIoCrypto.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/EFICardInfo.h>
+#include <Protocol/EFIClock.h>
+#include <Protocol/EFIHWIO.h>
+#include <Protocol/EFIStorageDeviceMgmt.h>
+#include <Protocol/OplusStorage.h>
+
+#include <Library/GPTListener.h>
+#include <Library/RpmbListener.h>
+#include <Library/RpmbLib.h>
+#include <Protocol/EFIRpmb.h>
+#include <Protocol/EFIEraseBlock.h>
+#include <Protocol/EFIStorageWriteProtect.h>
+#include <Protocol/EFIHALIOMMUProtocol.h>
+
+#include "OplusStorageDxe.h"
+#include "Library/KernelLib.h"
+#include <api/storage/ufs_api.h>
+#include <BootConfig.h>
+#include <api/storage/ufs_upgrade.h>
+
+EFI_OPLUS_STORAGE_PROTOCOL gOplusStorage = {
+	UFSFirmwareOps
+};
+
+EFI_STATUS EFIAPI UFSFirmwareOps(
+    IN EFI_OPLUS_STORAGE_PROTOCOL *This,
+    IN EFI_BLOCK_IO_PROTOCOL *blockio,
+    VOID *in1,
+    VOID *in2
+)
+{
+	int ret = 0;
+	EFI_STATUS Status = EFI_NOT_STARTED;
+	EFI_PHYSICAL_ADDRESS fw_buff_addr = 0;
+	unsigned long long fw_offset = 0;
+	struct ufs_handle *hUFS = NULL;
+	OPLUS_PARTITION_PRIVATE_DATA *PartitionData = NULL;
+        OPLUS_UFS_DEV *UfsDevice = NULL;
+        uint64_t logo_partition_start_lba = 0;
+        
+	if (NULL == This || NULL == blockio)
+	{
+		return EFI_INVALID_PARAMETER;
+	}
+
+	DEBUG ((EFI_D_ERROR, "BOOT: You are calling oplus UFSFirmwareOps function now.0x%x\n", blockio));
+    PartitionData = BASE_CR(blockio, OPLUS_PARTITION_PRIVATE_DATA, BlockIo);
+	if (NULL == PartitionData || NULL == PartitionData->ParentBlockIo)
+	{
+		return EFI_INVALID_PARAMETER;
+	}
+
+    logo_partition_start_lba = PartitionData->Start/PartitionData->BlockSize;
+	UfsDevice = BASE_CR(PartitionData->ParentBlockIo, OPLUS_UFS_DEV, BlkIo);
+	if (!UfsDevice || !(hUFS = (struct ufs_handle *)UfsDevice->DeviceHandle))
+	{
+		DEBUG((EFI_D_ERROR, "UEFI UFS lib is not initilized.\n"));
+		return EFI_NOT_STARTED;
+	}
+	Status = gBS->AllocatePages(AllocateAnyPages, EfiBootServicesCode, 
+							EFI_SIZE_TO_PAGES(FIRMWARE_LENGTH_MAX), &fw_buff_addr);
+	if (EFI_ERROR(Status))
+	{
+		DEBUG((EFI_D_ERROR, "UEFI AllocatePages fail.\n"));
+		return EFI_NOT_STARTED;
+	}
+
+	Status = EFI_NOT_STARTED;
+	in2 = (VOID*)&logo_partition_start_lba;
+	fw_offset = UNIFIED_RESERVE_UFS_FW_OFFSET;
+	if (need_upgrade_ufs_fimware(hUFS, (in1 ? (*(unsigned long long*)in1) : INVALID_LBA),
+						*(unsigned long long*)in2,
+						fw_offset, fw_buff_addr) ||
+						need_upgrade_ufs_fimware(hUFS, (in1 ? (*(unsigned long long*)in1) : INVALID_LBA),
+						*(unsigned long long*)in2,
+						UNIFIED_RESERVE_UFS_FW_OFFSET2,
+						fw_buff_addr))
+	{
+		ret = ufs_firmware_update(hUFS, fw_buff_addr);
+		if (ret == 0)
+		{
+			DEBUG((EFI_D_ERROR, "ufs FW upgrade success.\n"));
+			Status = EFI_SUCCESS;
+		}
+	}
+	gBS->FreePages(fw_buff_addr, EFI_SIZE_TO_PAGES(FIRMWARE_LENGTH_MAX));
+	return Status;
+}
+
+EFI_STATUS
+EFIAPI
+OplusStorageEntry (
+	IN EFI_HANDLE ImageHandle,
+	IN EFI_SYSTEM_TABLE *SystemTable
+)
+{
+	EFI_HANDLE handle = NULL;
+	EFI_STATUS status;
+        DEBUG((EFI_D_ERROR, "start init oplus storage entry.\n"));
+	status = gBS->InstallMultipleProtocolInterfaces(&handle,
+						&gEfiOplusStorageProtocolGuid,
+						(void **)&gOplusStorage,
+						NULL, 
+						NULL,
+						NULL);
+
+	return status;
+}
+
+
diff --git a/drivers/soc/oplus/storage/bp/OplusStorageDxe.h b/drivers/soc/oplus/storage/bp/OplusStorageDxe.h
new file mode 100644
index 000000000..0c95673c8
--- /dev/null
+++ b/drivers/soc/oplus/storage/bp/OplusStorageDxe.h
@@ -0,0 +1,84 @@
+/**
+@file    OplusStorageDxe.h
+@brief   Universal Flash Storage (UFS) DXE Header File
+
+This file contains the definitions of the constants, data structures,
+and interfaces for the OplusStorage driver in UEFI.
+
+ Copyright (c) 2013 - 2018, 2021,2022 OPLUS All rights reserved.
+**/
+
+ /*=============================================================================
+                               EDIT HISTORY
+
+
+ when            who   what, where, why
+ ----------      ---   -----------------------------------------------------------
+2023-5-26   zhoumaowei Add for decoupling of ufs drivers
+ =============================================================================*/
+
+#ifndef _OPLUSSTORAGEDXE_H_
+#define _OPLUSSTORAGEDXE_H_
+#include <Protocol/ComponentName.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/DriverBinding.h>
+#include <Protocol/DiskIo.h>
+#include <Protocol/PartitionInfo.h>
+#include <Protocol/DiskIo2.h>
+typedef struct _EFI_BLOCK_IO_PROTOCOL  EFI_BLOCK_IO_PROTOCOL;
+#define OPLUS_UFS_DEV_SIGNATURE SIGNATURE_32 ('u', 'f', 's', ' ')   /**< -- UFS  */
+
+typedef struct {
+  UINT64                       Signature;
+
+  EFI_HANDLE                   Handle;
+  EFI_DEVICE_PATH_PROTOCOL     *DevicePath;
+  EFI_BLOCK_IO_PROTOCOL        BlockIo;
+  EFI_BLOCK_IO2_PROTOCOL       BlockIo2;
+  EFI_BLOCK_IO_MEDIA           Media;
+  EFI_BLOCK_IO_MEDIA           Media2;//For BlockIO2
+  EFI_PARTITION_INFO_PROTOCOL  PartitionInfo;
+
+  EFI_DISK_IO_PROTOCOL         *DiskIo;
+  EFI_DISK_IO2_PROTOCOL        *DiskIo2;
+  EFI_BLOCK_IO_PROTOCOL        *ParentBlockIo;
+  EFI_BLOCK_IO2_PROTOCOL       *ParentBlockIo2;
+  UINT64                       Start;
+  UINT64                       End;
+  UINT32                       BlockSize;
+  BOOLEAN                      InStop;
+
+  EFI_GUID                     TypeGuid;
+#if defined (QCOM_EDK2_PATCH)
+  EFI_PARTITION_ENTRY          PartEntry;
+
+  EFI_ERASE_BLOCK_PROTOCOL    *ParentEraseBlock;
+  EFI_ERASE_BLOCK_PROTOCOL    BlockErase;
+#endif
+} OPLUS_PARTITION_PRIVATE_DATA;
+
+typedef struct {
+  UINT32                        Signature;
+  EFI_HANDLE                    ClientHandle;  /**< -- Client Handle */
+  EFI_HANDLE                    DeviceHandle;  /**< -- Device Handle */
+  EFI_BLOCK_IO_PROTOCOL         BlkIo;         /**< -- Block I/O */
+  EFI_BLOCK_IO_CRYPTO_PROTOCOL  BlkIoCrypto;   /**< -- Block I/O Crypto */
+  EFI_BLOCK_IO2_PROTOCOL        BlkIo2;        /**< -- Block I/O 2 */
+  EFI_SDCC_RPMB_PROTOCOL        RPMB;          /**< -- RPMB protocol */
+  EFI_MEM_CARDINFO_PROTOCOL     CardInfo;      /**< -- Memory card into */
+  EFI_ERASE_BLOCK_PROTOCOL      EraseBlk;      /**< -- Erase block */
+  EFI_STORAGE_WP_PROTOCOL       WriteProtect;  /**< -- Write Protect */
+  EFI_STORAGE_DEV_MGMT_PROTOCOL DeviceMgmt;    /**< -- Device Management */
+} OPLUS_UFS_DEV;
+
+EFI_STATUS EFIAPI UFSFirmwareOps(
+  IN EFI_OPLUS_STORAGE_PROTOCOL *This,
+  IN EFI_BLOCK_IO_PROTOCOL *blockio,
+  VOID *in1,
+  VOID *in2
+);
+
+#define OPLUS_UFS_DEV_FROM_BLOCKIO(a)   CR (a, OPLUS_UFS_DEV, BlkIo, OPLUS_UFS_DEV_SIGNATURE)
+
+#endif /* _UFS_H_ */
+
diff --git a/drivers/soc/oplus/storage/bp/OplusStorageDxe.inf b/drivers/soc/oplus/storage/bp/OplusStorageDxe.inf
new file mode 100644
index 000000000..3bfb05265
--- /dev/null
+++ b/drivers/soc/oplus/storage/bp/OplusStorageDxe.inf
@@ -0,0 +1,103 @@
+#/** @file UFSDxe.inf
+#
+#  UFSDxe INF file
+#
+#  Copyright (c) 2013, 2015-18, 2020-21,2022 OPLUS
+#  All Rights Reserved.
+#
+#**/
+
+#==============================================================================
+#                              EDIT HISTORY
+#
+#
+# when         who     what, where, why
+# ----------   ---     ---------------------------------------------------------
+# 2023/05/26   zhoumaowei   Add OplusStorageDxe for ufs drivers
+#
+#==============================================================================
+
+[Defines]
+  INF_VERSION                       = 0x00010005
+  BASE_NAME                         = OplusStorageDxe
+  FILE_GUID                         = 454bf7e3-2a68-4732-b41d-7ef50a592c93
+  MODULE_TYPE                       = UEFI_DRIVER
+  VERSION_STRING                    = 1.0
+  ENTRY_POINT                       = OplusStorageEntry
+
+
+[BuildOptions.AARCH64]
+  GCC:*_*_*_CC_FLAGS = -Wno-missing-field-initializers -Wno-missing-braces -Wno-unused-but-set-variable
+
+[Sources.common]
+  OplusStorageDxe.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  EmbeddedPkg/EmbeddedPkg.dec
+  ArmPkg/ArmPkg.dec
+  QcomPkg/QcomPkg.dec
+  QcomSdkPkg/QcomSdkPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  UefiRuntimeServicesTableLib
+  UefiLib
+  UefiBootServicesTableLib
+  BaseMemoryLib
+  DebugLib
+  UefiDriverEntryPoint
+  IoLib
+  UncachedMemoryAllocationLib
+  UefiCfgLib
+  SerialPortLib
+  PrintLib
+  ArmLib
+  MemoryAllocationLib
+  CacheMaintenanceLib
+  TimerLib
+  PcdLib
+  UfsCommonLib
+  RpmbListenerLib
+  BootConfigLib
+  KernelLib
+  LockLib
+  BlkCryptoLib
+
+[Guids]
+  gEfiEventExitBootServicesGuid 
+
+[Protocols]
+  gEfiBlockIoProtocolGuid
+  gEfiBlockIoCryptoProtocolGuid
+  gEfiBlockIo2ProtocolGuid
+  gEfiCpuArchProtocolGuid
+  gEfiDevicePathProtocolGuid
+  gEfiClockProtocolGuid
+  gEfiHwioProtocolGuid
+  gEfiSdccRpmbProtocolGuid
+  gQcomScmProtocolGuid
+  gEfiMemCardInfoProtocolGuid
+  gEfiEraseBlockProtocolGuid
+  gEfiStorageWpProtocolGuid
+  gEfiHalIommuProtocolGuid
+  gEfiStorageDevMgmtProtocolGuid
+  gEfiDtbExtnProtocolGuid
+  gQcomAcpiPlatformProtocolGuid
+  gEfiOplusStorageProtocolGuid
+  gEfiDiskIoProtocolGuid  
+# [Pcd.common]
+#  gQcomTokenSpaceGuid.UFSSlotNumber
+  gEfiDiskIo2ProtocolGuid
+  gEfiDiskIoProtocolGuid
+  gEfiPartitionInfoProtocolGuid
+
+[Depex]
+	TRUE
+#  gEfiClockProtocolGuid
+#  AND
+#  gEfiTimerArchProtocolGuid
+
+[Pcd.common]
+  gQcomTokenSpaceGuid.PcdQTimerEnabled
+
diff --git a/drivers/soc/oplus/storage/common/README.md b/drivers/soc/oplus/storage/common/README.md
new file mode 100644
index 000000000..33340ecca
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/README.md
@@ -0,0 +1,2 @@
+# io_metrics
+存储IO各项性能统计模块，在目录/proc/oplus_storage/io_metrics下会导出相应指标的性能数据
diff --git a/drivers/soc/oplus/storage/common/fmonitor/Kconfig b/drivers/soc/oplus/storage/common/fmonitor/Kconfig
new file mode 100644
index 000000000..b3936ac75
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/fmonitor/Kconfig
@@ -0,0 +1,6 @@
+config OPLUS_FEATURE_FILE_MONITOR
+    tristate "file monitor"
+    default y
+    help
+      Monitor User Mode File Modification.
+
diff --git a/drivers/soc/oplus/storage/common/fmonitor/Makefile b/drivers/soc/oplus/storage/common/fmonitor/Makefile
new file mode 100644
index 000000000..f473f4a8a
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/fmonitor/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# Copyright (C) 2022-2025 Oplus. All rights reserved.
+
+GCOV_PROFILE := y
+LINUXINCLUDE += -I$(srctree)/
+obj-$(CONFIG_OPLUS_FEATURE_FILE_MONITOR)	:= oplus_file_monitor.o
+
diff --git a/drivers/soc/oplus/storage/common/fmonitor/oplus_file_monitor.c b/drivers/soc/oplus/storage/common/fmonitor/oplus_file_monitor.c
new file mode 100644
index 000000000..ae3175470
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/fmonitor/oplus_file_monitor.c
@@ -0,0 +1,326 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2018-2020 Oplus. All rights reserved.
+ */
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/limits.h>
+#include <linux/printk.h>
+#include <linux/mutex.h>
+#include <linux/fcntl.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/atomic.h>
+#include <linux/f2fs_fs.h>
+#include <linux/sched.h>
+#include <linux/pid.h>
+#include <linux/seq_file.h>
+#include <linux/compiler.h>
+#include "fs/f2fs/f2fs.h"
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+#include "trace/events/android_fs.h"
+#else
+#include <linux/fs.h>
+#define MAX_TRACE_PATHBUF_LEN	256
+static inline char *
+android_fstrace_get_pathname(char *buf, int buflen, struct inode *inode)
+{
+	char *path;
+	struct dentry *d;
+	/*
+	 * d_obtain_alias() will either iput() if it locates an existing
+	 * dentry or transfer the reference to the new dentry created.
+	 * So get an extra reference here.
+	 */
+	ihold(inode);
+	d = d_obtain_alias(inode);
+	if (likely(!IS_ERR(d))) {
+		path = dentry_path_raw(d, buf, buflen);
+		if (unlikely(IS_ERR(path))) {
+			strcpy(buf, "ERROR");
+			path = buf;
+		}
+		dput(d);
+	} else {
+		strcpy(buf, "ERROR");
+		path = buf;
+	}
+	return path;
+}
+#endif
+#include <trace/events/f2fs.h>
+static struct proc_dir_entry *file_monitor_procfs = NULL;
+static struct proc_dir_entry *path_filter_file = NULL;
+static struct proc_dir_entry *remove_event_file = NULL;
+static struct proc_dir_entry *unlink_switch_file = NULL;
+static char pfliter_buf[1024] = {0};
+static char pfliter_front[512] = {0};
+static char pfliter_back[512] = {0};
+static char remove_buf[1024] = {0};
+static int g_unlink_switch = 0;
+static int rlen = 0;
+#define FILE_MONITOR_LOG_TAG "[file_monitor]"
+
+static ssize_t remove_proc_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *off)
+{
+	memset(remove_buf, 0, sizeof(remove_buf));
+
+	if (count > sizeof(remove_buf) - 1) {
+		count = sizeof(remove_buf) - 1;
+	}
+
+	if (copy_from_user(remove_buf, buf, count)) {
+		pr_err(FILE_MONITOR_LOG_TAG "%s: read proc input error.\n", __func__);
+		return count;
+	}
+
+	if (count > 0) {
+		remove_buf[count-1] = '\0';
+	}
+
+	return count;
+}
+
+static ssize_t remove_proc_read(struct file *file, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	return simple_read_from_buffer(buf, count, ppos, remove_buf, strlen(remove_buf));
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+static struct proc_ops remove_event_fops = {
+	.proc_read = remove_proc_read,
+	.proc_write = remove_proc_write,
+	.proc_lseek = default_llseek,
+};
+#else
+static struct file_operations remove_event_fops = {
+	.read = remove_proc_read,
+	.write = remove_proc_write,
+	.llseek = default_llseek,
+};
+#endif
+
+static ssize_t pfliter_proc_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *off)
+{
+	char *ptr;
+	memset(pfliter_buf, 0, sizeof(pfliter_buf));
+
+	if (count > sizeof(pfliter_buf) - 1) {
+		count = sizeof(pfliter_buf) - 1;
+	}
+
+	if (copy_from_user(pfliter_buf, buf, count)) {
+		pr_err(FILE_MONITOR_LOG_TAG "%s: read proc input error.\n", __func__);
+		return count;
+	}
+
+	if (count > 0) {
+		pfliter_buf[count-1] = '\0';
+	}
+
+	ptr = strstr(pfliter_buf, "*");
+	if (ptr) {
+		size_t len1 = ptr - pfliter_buf;
+		size_t len2 = count - len1 - 2;
+
+		strncpy(pfliter_front, pfliter_buf, len1);
+		strncpy(pfliter_back, ptr + 1, len2);
+
+		pfliter_front[len1] = '\0';
+		pfliter_back[len2] = '\0';
+	}
+
+	return count;
+}
+
+static ssize_t pfliter_proc_read(struct file *file, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	char bpath[100];
+	size_t len = 0;
+
+	len = snprintf(bpath, sizeof(bpath), "%s", pfliter_buf);
+	return simple_read_from_buffer(buf, count, ppos, bpath, len);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+static struct proc_ops path_filter_fops = {
+	.proc_read = pfliter_proc_read,
+	.proc_write = pfliter_proc_write,
+	.proc_lseek = default_llseek,
+};
+#else
+static struct file_operations path_filter_fops = {
+	.read = pfliter_proc_read,
+	.write = pfliter_proc_write,
+	.llseek = default_llseek,
+};
+#endif
+
+static ssize_t uswitch_proc_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *off)
+{
+	char str[3] = {0};
+
+	if (count > 2 || count < 1) {
+		pr_err(FILE_MONITOR_LOG_TAG "unlink switch invalid parameter\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(str, buf, count)) {
+		pr_err(FILE_MONITOR_LOG_TAG "copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (unlikely(!strncmp(str, "1", 1))) {
+		pr_info(FILE_MONITOR_LOG_TAG "unlink switch enabled\n");
+		g_unlink_switch = 1;
+	} else {
+		pr_info(FILE_MONITOR_LOG_TAG "unlink switch disabled\n");
+		g_unlink_switch = 0;
+	}
+
+	return (ssize_t)count;
+}
+
+static int unlink_switch_show(struct seq_file *s, void *data)
+{
+	if (g_unlink_switch == 1)
+		seq_printf(s, "%d\n", 1);
+	else
+		seq_printf(s, "%d\n", 0);
+
+	return 0;
+}
+
+static int uswitch_proc_open(struct inode *inodp, struct file *filp)
+{
+	return single_open(filp, unlink_switch_show, inodp);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+static struct proc_ops unlink_switch_fops = {
+	.proc_open = uswitch_proc_open,
+	.proc_read = seq_read,
+	.proc_write = uswitch_proc_write,
+	.proc_lseek = default_llseek,
+};
+#else
+static struct file_operations unlink_switch_fops = {
+	.open = uswitch_proc_open,
+	.read = seq_read,
+	.write = uswitch_proc_write,
+	.llseek = default_llseek,
+};
+#endif
+
+static void cb_f2fs_unlink_enter(void *ignore, struct inode *dir,
+                                          struct dentry *dentry)
+{
+	int written = 0;
+	char *file;
+	struct inode *inode = d_inode(dentry);
+	char *path, pathbuf[MAX_TRACE_PATHBUF_LEN];
+
+	if (g_unlink_switch == 0) {
+		return;
+	}
+
+	path = android_fstrace_get_pathname(pathbuf,
+										MAX_TRACE_PATHBUF_LEN,
+										inode);
+	if(strlen(pfliter_front)) {
+		if(strstr(path, pfliter_front) && strstr(path, pfliter_back)) {
+			rlen = strlen(remove_buf);
+			if (rlen >= sizeof(remove_buf) - 1) {
+				memset(remove_buf, 0, sizeof(remove_buf));
+				rlen = 0;
+			}
+			file = strrchr(path, '/');
+			written = snprintf(remove_buf + rlen, sizeof(remove_buf) - rlen -1, "F:%s T:%s \n", file, current->comm);
+			rlen += written;
+		}
+	} else {
+		if(strstr(path, pfliter_buf)) {
+			rlen = strlen(remove_buf);
+			if (rlen >= sizeof(remove_buf) - 1) {
+				memset(remove_buf, 0, sizeof(remove_buf));
+				rlen = 0;
+			}
+			file = strrchr(path, '/');
+			written = snprintf(remove_buf + rlen, sizeof(remove_buf) - rlen -1, "F:%s T:%s \n", file, current->comm);
+			rlen += written;
+		}
+	}
+};
+
+
+static void file_monitor_register_tracepoints(void)
+{
+	int ret;
+
+	ret = register_trace_f2fs_unlink_enter(cb_f2fs_unlink_enter, NULL);
+
+	return;
+}
+
+static void f2fs_unregister_tracepoint_probes(void)
+{
+	unregister_trace_f2fs_unlink_enter(cb_f2fs_unlink_enter, NULL);
+}
+
+int __init file_monitor_init(void)
+{
+	file_monitor_procfs = proc_mkdir("oplus_storage/file_monitor", NULL);
+	if (file_monitor_procfs == NULL) {
+		pr_err(FILE_MONITOR_LOG_TAG" Failed to create file_monitor procfs\n");
+		return -EFAULT;
+	}
+
+	path_filter_file = proc_create("path_filter", 0644, file_monitor_procfs, &path_filter_fops);
+	if (path_filter_file == NULL) {
+		pr_err(FILE_MONITOR_LOG_TAG" Failed to create file oplus_storage/file_monitor/path_filter\n");
+		return -EFAULT;
+	}
+
+	remove_event_file = proc_create("remove_event", 0644, file_monitor_procfs, &remove_event_fops);
+	if (remove_event_file == NULL) {
+		pr_err(FILE_MONITOR_LOG_TAG" Failed to create file oplus_storage/file_monitor/remove_event\n");
+		return -EFAULT;
+	}
+
+	unlink_switch_file = proc_create("unlink_switch", 0644, file_monitor_procfs, &unlink_switch_fops);
+	if (unlink_switch_file == NULL) {
+		pr_err(FILE_MONITOR_LOG_TAG" Failed to create file oplus_storage/file_monitor/unlink_switch\n");
+		return -EFAULT;
+	}
+
+	memset(pfliter_buf, 0, sizeof(pfliter_buf));
+	memset(remove_buf, 0, sizeof(remove_buf));
+	strcpy(pfliter_buf, "file_monitor");
+	file_monitor_register_tracepoints();
+
+	return 0;
+}
+
+void __exit file_monitor_exit(void)
+{
+	remove_proc_entry("path_filter", file_monitor_procfs);
+	remove_proc_entry("remove_event", file_monitor_procfs);
+	remove_proc_entry("unlink_switch", file_monitor_procfs);
+
+	f2fs_unregister_tracepoint_probes();
+}
+
+module_init(file_monitor_init);
+module_exit(file_monitor_exit);
+
+MODULE_DESCRIPTION("oplus file monitor");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/soc/oplus/storage/common/io_metrics/Kconfig b/drivers/soc/oplus/storage/common/io_metrics/Kconfig
new file mode 100644
index 000000000..bd9296a49
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/Kconfig
@@ -0,0 +1,19 @@
+config OPLUS_FEATURE_STORAGE_IO_METRICS_QCOM
+  tristate "config oplus_bsp_storage_io_metrics"
+  help
+    define this config to compile oplus_bsp_storage_io_metrics for device register
+
+config OPLUS_FEATURE_STORAGE_IO_METRICS_MTK
+  tristate "config oplus_bsp_storage_io_metrics"
+  help
+    define this config to compile oplus_bsp_storage_io_metrics for device register
+
+config OPLUS_FEATURE_STORAGE_IO_METRICS_DEBUG
+  tristate "config oplus_bsp_storage_io_metrics"
+  help
+    define this config to compile oplus_bsp_storage_io_metrics for device register
+
+config OPLUS_FEATURE_STORAGE_IO_METRICS
+  tristate "config oplus_bsp_storage_io_metrics"
+  help
+    define this config to compile oplus_bsp_storage_io_metrics for device register
diff --git a/drivers/soc/oplus/storage/common/io_metrics/Makefile b/drivers/soc/oplus/storage/common/io_metrics/Makefile
new file mode 100644
index 000000000..5504297bc
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/Makefile
@@ -0,0 +1,27 @@
+LINUXINCLUDE += -I$(srctree)/
+
+ifeq ($(CONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS_QCOM),y)
+ccflags-y += -DSOC_PLATFORM_IS_QCOM
+else ifeq ($(CONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS_MTK),y)
+ccflags-y += -DSOC_PLATFORM_IS_MTK
+endif
+
+ifeq ($(CONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS_DEBUG),y)
+ccflags-y += -DCONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS_DEBUG=1
+endif
+
+ifeq ($(OPLUS_OUT_OF_TREE_KO),y)
+ccflags-y += -DCONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS=1
+endif
+
+ifeq ($(CONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS),y)
+CONFIG_OPLUS_FEATURE_STORAGE_F2FS=y
+endif
+
+obj-$(CONFIG_OPLUS_FEATURE_STORAGE_IO_METRICS) += oplus_bsp_storage_io_metrics.o
+oplus_bsp_storage_io_metrics-y += procfs.o
+oplus_bsp_storage_io_metrics-y += io_metrics_entry.o
+oplus_bsp_storage_io_metrics-y += block_metrics.o
+oplus_bsp_storage_io_metrics-$(CONFIG_OPLUS_FEATURE_STORAGE_F2FS) += f2fs_metrics.o
+oplus_bsp_storage_io_metrics-y += ufs_metrics.o
+oplus_bsp_storage_io_metrics-y += abnormal_io.o
diff --git a/drivers/soc/oplus/storage/common/io_metrics/abnormal_io.c b/drivers/soc/oplus/storage/common/io_metrics/abnormal_io.c
new file mode 100644
index 000000000..97dbc4d4e
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/abnormal_io.c
@@ -0,0 +1,896 @@
+#include "io_metrics_entry.h"
+#include "abnormal_io.h"
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#include "fs/f2fs/f2fs.h"
+#include "fs/f2fs/segment.h"
+#include "fs/f2fs/node.h"
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+#include "drivers/scsi/ufs/ufs.h"
+#else
+#include <ufs/ufshcd.h>
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#include <trace/events/f2fs.h>
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#include <trace/events/block.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+#include <trace/events/ufs.h>
+#endif
+#include <linux/preempt.h>
+#include <linux/fs.h>
+#include <linux/blk_types.h>
+
+#define BUFFER_SIZE  (1<<20)
+#define CACHELINE_SIZE 64
+#define COUNTER_BIT_SIZE 20
+#define TP_BIT_SIZE 8
+
+#define DAY_TO_SECONDS(n) ((n) * 24 * 3600LL)
+#define DUMP_MINIMUM_INTERVAL (5 * 60)
+#define DUMP_LIMIT_1_DAY 10
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0))
+#define RWBS_PAD 2
+#else
+#define RWBS_PAD 0
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+
+atomic_t abnormal_io_enabled = ATOMIC_INIT(0);
+bool abnormal_io_trigger;
+atomic_t multiple_dump;
+int abnormal_io_dump_min_interval_s;
+int abnormal_io_dump_limit_1_day;
+static time64_t last_dump_seconds;
+static time64_t base_dump_seconds;
+
+enum TP_t {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    F2FS_SUBMIT_PAGE_WRITE = 0,
+    F2FS_SUBMIT_PAGE_BIO,
+    F2FS_FILEMAP_FAULT,
+    F2FS_SUBMIT_READ_BIO,
+    F2FS_SUBMIT_WRITE_BIO,
+    F2FS_MAP_BLOCKS,
+    F2FS_DATAREAD_START,
+    F2FS_DATAREAD_END,
+    F2FS_DATAWRITE_START,
+    F2FS_DATAWRITE_END,
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    BLOCK_RQ_ISSUE,
+    BLOCK_RQ_COMPLETE,
+    BLOCK_GETRQ,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    BLOCK_BIO_FRONTMERGE,
+    BLOCK_BIO_BACKMERGE,
+    BLOCK_BIO_REMAP,
+    UFSHCD_COMMAND
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+};
+
+/* 24Byte */
+struct entry_head_t {
+    u64 magic; /* 0x0a63697274656d6f69 or "iometrics" */
+    u64 timestamp;
+    u32 counter: COUNTER_BIT_SIZE;
+    u32 in_nmi: 1;
+    u32 in_hardirq: 1;
+    u32 in_softirq: 1;
+    u32 in_atomic: 1;
+    u32  tp_t: TP_BIT_SIZE;
+    int pid;
+};
+
+/* 当前结构对tb中具体struct的修改不能超过40B，不然影响性能*/
+struct entry_t {
+    struct entry_head_t head;
+#pragma pack(push, 1)
+    union {
+        char pad[CACHELINE_SIZE - sizeof(struct entry_head_t)];
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+        struct {
+            int major;
+            int minor;
+            u64 ino;
+            u64 index;
+            u64 old_blkaddr;
+            u64 new_blkaddr;
+        } f2fs_submit_page_write; /* (struct page *page, struct f2fs_io_info *fio) */
+        struct {
+            int major;
+            int minor;
+            u64 ino;
+            u64 index;
+            int op;
+            int op_flags;
+            u8 type;
+            u8 temp;
+            u8 pad[6];
+        } f2fs_submit_page_bio;   /* (struct page *page, struct f2fs_io_info *fio) */
+        struct {
+            int major;
+            int minor;
+            u64 ino;
+            u64 index;
+            u64 ret;
+            u64 pad;
+        } f2fs_filemap_fault;     /* (struct inode *inode, pgoff_t index, u64 ret) */
+        struct {
+            int major;
+            int minor;
+            sector_t sector;
+            int op;
+            int op_flags;
+            int type;
+            u32 size;
+            u8 pad[8];
+        } f2fs_submit_read_bio;   /* (struct super_block *sb, int type, struct bio *bio) */
+        struct {
+            int major;
+            int minor;
+            sector_t sector;
+            int op;
+            int op_flags;
+            int type;
+            u32 size;
+            u8 pad[8];
+        } f2fs_submit_write_bio;  /* (struct super_block *sb, int type, struct bio *bio) */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+#define PATHNAME_LEN    16
+        struct {
+            u64 offset;
+            u64 ino;
+            int bytes;
+            pid_t pid;
+            u8 pathname[PATHNAME_LEN];
+        } f2fs_dataread_start;   /* (struct inode *inode, loff_t offset, int bytes, pid_t pid,
+                                    char *pathname, char *command) */
+        struct {
+            u64 offset;
+            u64 ino;
+            int bytes;
+            u8 pad[20];
+        } f2fs_dataread_end;     /* (struct inode *inode, loff_t offset, int bytes) */
+        struct {
+            u64 offset;
+            u64 ino;
+            int bytes;
+            pid_t pid;
+            u8 pathname[PATHNAME_LEN];
+        } f2fs_datawrite_start;  /* (struct inode *inode, loff_t offset, int bytes, pid_t pid,
+                                    char *pathname, char *command) */
+        struct {
+            u64 offset;
+            u64 ino;
+            int bytes;
+            u8 pad[20];
+        } f2fs_datawrite_end;    /* (struct inode *inode, loff_t offset, int bytes) */
+#endif
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+        struct {
+            int major;
+            int minor;
+            sector_t sector;
+            u8 rwbs[RWBS_LEN];   /* 8B */
+            u32 bytes;
+            u8 pad[12 - RWBS_PAD];
+        } block_rq_issue;        /* (struct request *rq) */
+        struct {
+            int major;
+            int minor;
+            sector_t sector;
+            u8 rwbs[RWBS_LEN];   /* 8B */
+            u64 elapsed;
+            u32 bytes;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+            int error;
+#else
+            u8 pad[4 - RWBS_PAD];
+#endif
+        } block_rq_complete;     /* (struct request *rq, int error, u32 nr_bytes) */
+        struct {
+            sector_t sector;
+            u8 comm[TASK_COMM_LEN];
+            u8 rwbs[RWBS_LEN];   /* 8B */
+            u32 bytes;
+            u8 pad[4 - RWBS_PAD];
+        } block_getrq;           /* (struct bio *bio) */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+        struct {
+            sector_t sector;
+            u8 rwbs[RWBS_LEN];   /* 8B */
+            u32 bytes;
+            u8 pad[20 - RWBS_PAD];
+        } block_bio_frontmerge;  /* (struct bio *bio) */
+        struct {
+            sector_t sector;
+            u8 rwbs[RWBS_LEN];   /* 8B */
+            u32 bytes;
+            u8 pad[20 - RWBS_PAD];
+        } block_bio_backmerge;   /* (struct bio *bio) */
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+        struct {
+            int old_major;
+            int old_minor;
+            int new_major;
+            int new_minor;
+            sector_t old_sector;
+            sector_t new_sector;
+            u32 bytes;
+            u8 pad[4];
+        } block_bio_remap;       /* (struct bio *bio, dev_t dev, sector_t from) */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+        struct {
+            u64 lba;
+            u64 elapsed;
+            u32 tag;
+            u32 doorbell;
+            int transfer_len;
+            u32 intr;
+            u8 opcode;
+            u8 group_id;
+            u8 str_t;
+            u8 gear_rx: 4;
+            u8 gear_tx: 4;
+            u8 lane_rx: 4;
+            u8 lane_tx: 4;
+            u8 pwr_rx: 4;
+            u8 pwr_tx: 4;
+            u8 hwq_id;
+            u8 pad[1];
+        } ufshcd_command;       /* (const char *dev_name, enum ufs_trace_str_t str_t, u32 tag,
+                     u32 doorbell, int transfer_len, u32 intr, u64 lba, u8 opcode, u8 group_id)*/
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#endif
+    } tp;
+#pragma pack(pop)
+};
+
+struct ring_buffer_tail {
+    u64 ktime_ns;
+    time64_t utc_seconds; /* seconds since 1970 */
+    int writers;
+};
+struct ring_buffer_t {
+    u32 size;
+    u32 mask;
+    atomic_t cursor;
+    atomic_t writers;
+    char pad[48];
+    char data[BUFFER_SIZE + sizeof(struct ring_buffer_tail)];
+} ring_buffer __attribute__((aligned(CACHELINE_SIZE)));
+
+void ring_buffer_int(void)
+{
+    ring_buffer.size = BUFFER_SIZE;
+    ring_buffer.mask = (ring_buffer.size >> 6) - 1;
+    atomic_set(&ring_buffer.cursor, -1);
+    atomic_set(&ring_buffer.writers, 0);
+}
+
+static __always_inline struct entry_t *get_pentry_from_ring_buffer(enum TP_t tp)
+{
+    struct entry_t* pentry = (struct entry_t*)ring_buffer.data;
+    u32 tmp = 0;
+    u32 slot = 0;
+
+    tmp = (u32)atomic_inc_return(&ring_buffer.cursor);
+    slot = ring_buffer.mask & tmp;
+    pentry = pentry + slot;
+    pentry->head.timestamp = ktime_get_ns();
+    pentry->head.magic = 0x63697274656d6f69;
+    pentry->head.counter = tmp;
+    pentry->head.tp_t = tp;
+    pentry->head.pid = current->pid;
+    pentry->head.in_nmi = in_nmi() ? 1 : 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    pentry->head.in_hardirq = in_hardirq() ? 1 : 0;
+#else
+    pentry->head.in_hardirq = 0;
+#endif
+    pentry->head.in_softirq = in_softirq() ? 1 : 0;
+    pentry->head.in_atomic = in_atomic() ? 1 : 0;
+
+    return pentry;
+}
+
+static  __always_inline void ring_buffer_writer_inc(void)
+{
+    atomic_inc(&ring_buffer.writers);
+}
+
+static  __always_inline void ring_buffer_writer_dec(void)
+{
+    atomic_dec(&ring_buffer.writers);
+}
+
+static int dump_data_to_file(const char *logpath)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0))
+	return 0;
+#else
+    struct file *fp = NULL;
+    int ret = 0;
+    loff_t offset = 0;
+    struct ring_buffer_tail *ptail = NULL;
+
+    ptail = (struct ring_buffer_tail *)(ring_buffer.data + BUFFER_SIZE);
+    ptail->ktime_ns = ktime_get_ns();
+    ptail->utc_seconds = ktime_get_real_seconds();
+    ptail->writers = atomic_read(&ring_buffer.writers);
+    io_metrics_print("writers: %d\n", ptail->writers);
+    fp = filp_open(logpath, O_CREAT | O_WRONLY | O_TRUNC, 0666);
+    if (IS_ERR(fp)) {
+        ret = PTR_ERR(fp);
+    } else {
+        ret = kernel_write(fp, ring_buffer.data, BUFFER_SIZE + sizeof(struct ring_buffer_tail), &offset);
+        if (!ret) {
+           io_metrics_print("kernel_write err: %d\n", ret);
+        }
+        filp_close(fp, NULL);
+    }
+    ring_buffer_int();
+	return ret;
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+void record_f2fs_submit_page_write(void *ignore, struct page *page, struct f2fs_io_info *fio)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_SUBMIT_PAGE_WRITE);
+    pentry->tp.f2fs_submit_page_write.major = MAJOR(page_file_mapping(page)->host->i_sb->s_dev);
+    pentry->tp.f2fs_submit_page_write.minor = MINOR(page_file_mapping(page)->host->i_sb->s_dev);
+    pentry->tp.f2fs_submit_page_write.ino = page_file_mapping(page)->host->i_ino;
+    pentry->tp.f2fs_submit_page_write.index = (u64)page->index;
+    pentry->tp.f2fs_submit_page_write.old_blkaddr = (u64)fio->old_blkaddr;
+    pentry->tp.f2fs_submit_page_write.new_blkaddr = (u64)fio->new_blkaddr;
+    ring_buffer_writer_dec();
+}
+void record_f2fs_submit_page_bio(void *ignore, struct page *page, struct f2fs_io_info *fio)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_SUBMIT_PAGE_BIO);
+    pentry->tp.f2fs_submit_page_bio.major = MAJOR(page_file_mapping(page)->host->i_sb->s_dev);
+    pentry->tp.f2fs_submit_page_bio.minor = MINOR(page_file_mapping(page)->host->i_sb->s_dev);
+    pentry->tp.f2fs_submit_page_bio.ino = page_file_mapping(page)->host->i_ino;
+    pentry->tp.f2fs_submit_page_bio.index = (u64)page->index;
+    pentry->tp.f2fs_submit_page_bio.op = fio->op;
+    pentry->tp.f2fs_submit_page_bio.op_flags = fio->op_flags;
+    pentry->tp.f2fs_submit_page_bio.type = (u8)fio->type;
+    pentry->tp.f2fs_submit_page_bio.temp = (u8)fio->temp;
+    ring_buffer_writer_dec();
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+void record_f2fs_filemap_fault(void *ignore, struct inode *inode, pgoff_t index, unsigned long ret)
+#else
+void record_f2fs_filemap_fault(void *ignore, struct inode *inode, unsigned long index, vm_flags_t flag, vm_fault_t ret)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0) */
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_FILEMAP_FAULT);
+    pentry->tp.f2fs_filemap_fault.major = MAJOR(inode->i_sb->s_dev);
+    pentry->tp.f2fs_filemap_fault.minor = MINOR(inode->i_sb->s_dev);
+    pentry->tp.f2fs_filemap_fault.ino = inode->i_ino;
+    pentry->tp.f2fs_filemap_fault.index = index;
+    pentry->tp.f2fs_filemap_fault.ret = ret;
+    ring_buffer_writer_dec();
+}
+void record_f2fs_submit_read_bio(void *ignore, struct super_block *sb, int type, struct bio *bio)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_SUBMIT_READ_BIO);
+    pentry->tp.f2fs_submit_read_bio.major = MAJOR(sb->s_dev);
+    pentry->tp.f2fs_submit_read_bio.minor = MINOR(sb->s_dev);
+    pentry->tp.f2fs_submit_read_bio.sector = bio->bi_iter.bi_sector;
+    pentry->tp.f2fs_submit_read_bio.op = bio_op(bio);
+    pentry->tp.f2fs_submit_read_bio.op_flags = bio->bi_opf;
+    pentry->tp.f2fs_submit_read_bio.type = type;
+    pentry->tp.f2fs_submit_read_bio.size = bio->bi_iter.bi_size;
+    ring_buffer_writer_dec();
+}
+void record_f2fs_submit_write_bio(void *ignore, struct super_block *sb, int type, struct bio *bio)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_SUBMIT_WRITE_BIO);
+    pentry->tp.f2fs_submit_write_bio.major = MAJOR(sb->s_dev);
+    pentry->tp.f2fs_submit_write_bio.minor = MINOR(sb->s_dev);
+    pentry->tp.f2fs_submit_write_bio.sector = bio->bi_iter.bi_sector;
+    pentry->tp.f2fs_submit_write_bio.op = bio_op(bio);
+    pentry->tp.f2fs_submit_write_bio.op_flags = bio->bi_opf;
+    pentry->tp.f2fs_submit_write_bio.type = type;
+    pentry->tp.f2fs_submit_write_bio.size = bio->bi_iter.bi_size;
+    ring_buffer_writer_dec();
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_f2fs_dataread_start(void *ignore, struct inode *inode, loff_t offset, int bytes,
+                                      pid_t pid, char *pathname, char *command)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_DATAREAD_START);
+    pentry->tp.f2fs_dataread_start.offset = offset;
+    pentry->tp.f2fs_dataread_start.ino = inode->i_ino;
+    pentry->tp.f2fs_dataread_start.bytes = bytes;
+    pentry->tp.f2fs_dataread_start.pid = pid;
+    strncpy(pentry->tp.f2fs_dataread_start.pathname, pathname, PATHNAME_LEN-1);
+    pentry->tp.f2fs_dataread_start.pathname[PATHNAME_LEN-1] = 0;
+    ring_buffer_writer_dec();
+}
+
+void record_f2fs_dataread_end(void *ignore, struct inode *inode, loff_t offset, int bytes)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_DATAREAD_END);
+    pentry->tp.f2fs_dataread_end.offset = offset;
+    pentry->tp.f2fs_dataread_end.ino = inode->i_ino;
+    pentry->tp.f2fs_dataread_end.bytes = bytes;
+    ring_buffer_writer_dec();
+}
+
+void record_f2fs_datawrite_start(void *ignore, struct inode *inode, loff_t offset, int bytes,
+                                      pid_t pid, char *pathname, char *command)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_DATAWRITE_START);
+    pentry->tp.f2fs_datawrite_start.offset = offset;
+    pentry->tp.f2fs_datawrite_start.ino = inode->i_ino;
+    pentry->tp.f2fs_datawrite_start.bytes = bytes;
+    pentry->tp.f2fs_datawrite_start.pid = pid;
+    strncpy(pentry->tp.f2fs_datawrite_start.pathname, pathname, PATHNAME_LEN-1);
+    pentry->tp.f2fs_datawrite_start.pathname[PATHNAME_LEN-1] = 0;
+    ring_buffer_writer_dec();
+}
+
+void record_f2fs_datawrite_end(void *ignore, struct inode *inode, loff_t offset, int bytes)
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(F2FS_DATAWRITE_END);
+    pentry->tp.f2fs_datawrite_end.offset = offset;
+    pentry->tp.f2fs_datawrite_end.ino = inode->i_ino;
+    pentry->tp.f2fs_datawrite_end.bytes = bytes;
+    ring_buffer_writer_dec();
+}
+#endif
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_block_rq_issue(void *ignore, struct request *rq)
+#else
+void record_block_rq_issue(void *ignore, struct request_queue *q,
+                             struct request *rq)
+#endif
+{
+    struct entry_t *pentry = NULL;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+    dev_t dev = rq->rq_disk ? disk_devt(rq->rq_disk) : 0;
+#else
+    dev_t dev = rq->part ? (rq->part->bd_disk ? disk_devt(rq->part->bd_disk) : 0) : 0;
+#endif
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(BLOCK_RQ_ISSUE);
+    pentry->tp.block_rq_issue.major = MAJOR(dev);
+    pentry->tp.block_rq_issue.minor = MINOR(dev);
+    pentry->tp.block_rq_issue.sector = blk_rq_trace_sector(rq);
+    pentry->tp.block_rq_issue.bytes = blk_rq_bytes(rq);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    blk_fill_rwbs(pentry->tp.block_rq_issue.rwbs, rq->cmd_flags);
+#else
+    blk_fill_rwbs(pentry->tp.block_rq_issue.rwbs, rq->cmd_flags, RWBS_LEN);
+#endif
+    ring_buffer_writer_dec();
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+static void record_block_rq_complete(void *ignore, struct request *rq,
+                      int error, unsigned int nr_bytes)
+#else
+static void record_block_rq_complete(void *ignore, struct request *rq,
+                      blk_status_t error, unsigned int nr_bytes)
+#endif
+
+{
+    struct entry_t *pentry = NULL;
+    u64 io_complete_time_ns = ktime_get_ns();
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+        dev_t dev = rq->rq_disk ? disk_devt(rq->rq_disk) : 0;
+#else
+        dev_t dev = rq->part ? (rq->part->bd_disk ? disk_devt(rq->part->bd_disk) : 0) : 0;
+#endif
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(BLOCK_RQ_COMPLETE);
+    pentry->tp.block_rq_complete.major = MAJOR(dev);
+    pentry->tp.block_rq_complete.minor = MINOR(dev);
+    pentry->tp.block_rq_complete.sector = blk_rq_trace_sector(rq);
+    pentry->tp.block_rq_complete.bytes = nr_bytes;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
+    pentry->tp.block_rq_complete.error = error;
+#endif
+    pentry->tp.block_rq_complete.elapsed = (rq->start_time_ns && (io_complete_time_ns > rq->start_time_ns)) ?
+                                           (io_complete_time_ns - rq->start_time_ns) : 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    blk_fill_rwbs(pentry->tp.block_rq_complete.rwbs, rq->cmd_flags);
+#else
+    blk_fill_rwbs(pentry->tp.block_rq_complete.rwbs, rq->cmd_flags, RWBS_LEN);
+#endif
+    ring_buffer_writer_dec();
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_block_getrq(void *ignore, struct bio *bio)
+#else
+void record_block_getrq(void *ignore, struct request_queue *q, struct bio *bio, int rw)
+#endif
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(BLOCK_GETRQ);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    pentry->tp.block_getrq.sector = bio->bi_iter.bi_sector;
+    pentry->tp.block_getrq.bytes = bio_sectors(bio) << 9;
+    blk_fill_rwbs(pentry->tp.block_getrq.rwbs, bio->bi_opf);
+#else
+    pentry->tp.block_getrq.sector = bio ? bio->bi_iter.bi_sector : 0;
+    pentry->tp.block_getrq.bytes = bio ? (bio_sectors(bio) << 9) : 0;
+    blk_fill_rwbs(pentry->tp.block_getrq.rwbs, bio ? bio->bi_opf : 0, bio ? bio_sectors(bio) : 0);
+#endif
+    memcpy(pentry->tp.block_getrq.comm, current->comm, TASK_COMM_LEN);
+    ring_buffer_writer_dec();
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_block_bio_frontmerge(void *ignore, struct bio *bio)
+#else
+void record_block_bio_frontmerge(void *ignore, struct request_queue *q, struct request *rq, struct bio *bio)
+#endif
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(BLOCK_BIO_FRONTMERGE);
+    pentry->tp.block_bio_frontmerge.sector = bio->bi_iter.bi_sector;
+    pentry->tp.block_bio_frontmerge.bytes = bio_sectors(bio) << 9;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    blk_fill_rwbs(pentry->tp.block_bio_frontmerge.rwbs, bio->bi_opf);
+#else
+    blk_fill_rwbs(pentry->tp.block_bio_frontmerge.rwbs, bio->bi_opf, RWBS_LEN);
+#endif
+    ring_buffer_writer_dec();
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_block_bio_backmerge(void *ignore, struct bio *bio)
+#else
+void record_block_bio_backmerge(void *ignore, struct request_queue *q, struct request *rq, struct bio *bio)
+#endif
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(BLOCK_BIO_BACKMERGE);
+    pentry->tp.block_bio_backmerge.sector = bio->bi_iter.bi_sector;
+    pentry->tp.block_bio_backmerge.bytes = bio_sectors(bio) << 9;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    blk_fill_rwbs(pentry->tp.block_bio_backmerge.rwbs, bio->bi_opf);
+#else
+    blk_fill_rwbs(pentry->tp.block_bio_backmerge.rwbs, bio->bi_opf, RWBS_LEN);
+#endif
+    ring_buffer_writer_dec();
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_block_bio_remap(void *ignore, struct bio *bio, dev_t dev, sector_t from)
+#else
+void record_block_bio_remap(void *ignore, struct request_queue *q, struct bio *bio, dev_t dev, sector_t from)
+#endif
+{
+    struct entry_t *pentry = NULL;
+
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(BLOCK_BIO_REMAP);
+    pentry->tp.block_bio_remap.old_major = MAJOR(dev);
+    pentry->tp.block_bio_remap.old_minor = MINOR(dev);
+    pentry->tp.block_bio_remap.new_major = MAJOR(bio_dev(bio));
+    pentry->tp.block_bio_remap.new_minor = MINOR(bio_dev(bio));
+    pentry->tp.block_bio_remap.old_sector = from;
+    pentry->tp.block_bio_remap.new_sector = bio->bi_iter.bi_sector;
+    pentry->tp.block_bio_remap.bytes = bio_sectors(bio) << 9;
+    ring_buffer_writer_dec();
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(6, 1, 0)
+void record_ufshcd_command(void *ignore, const char *dev_name, enum ufs_trace_str_t str_t,
+                    unsigned int tag, u32 doorbell, u32 hwq_id, int transfer_len, u32 intr,
+                    u64 lba, u8 opcode, u8 group_id)
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+void record_ufshcd_command(void *ignore, const char *dev_name, enum ufs_trace_str_t str_t,
+                    unsigned int tag, u32 doorbell, int transfer_len, u32 intr,
+                    u64 lba, u8 opcode, u8 group_id)
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0)
+void record_ufshcd_command(void *ignore, const char *dev_name, const char *str,
+                    unsigned int tag, u32 doorbell, int transfer_len, u32 intr,
+                    u64 lba, u8 opcode, u8 group_id)
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0)
+void record_ufshcd_command(void *ignore, const char *dev_name, const char *str,
+                    unsigned int tag, u32 doorbell, int transfer_len, u32 intr,
+                    u64 lba, u8 opcode)
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0)
+{
+    struct entry_t *pentry = NULL;
+#if 0
+#ifdef CONFIG_ARCH_QCOM || CONFIG_ARCH_MEDIATEK
+    struct ufs_hba * hba = NULL;
+    struct ufshcd_lrb *lrbp = NULL;
+#endif
+#endif
+    if (unlikely(atomic_read(&multiple_dump))) {
+        return;
+    }
+    ring_buffer_writer_inc();
+    pentry = get_pentry_from_ring_buffer(UFSHCD_COMMAND);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    pentry->tp.ufshcd_command.str_t = (u8)str_t;
+#else
+    /* To improve performance, only record completion commands */
+    if (!strcmp(str, "complete")) {
+        pentry->tp.ufshcd_command.str_t = 1; /* UFS_CMD_COMP */
+    } else {
+        pentry->tp.ufshcd_command.str_t = 0XFF; /* N/A */
+    }
+#endif
+    pentry->tp.ufshcd_command.tag = tag;
+    pentry->tp.ufshcd_command.doorbell = doorbell;
+    pentry->tp.ufshcd_command.transfer_len = transfer_len;
+    pentry->tp.ufshcd_command.intr = intr;
+    pentry->tp.ufshcd_command.lba = lba;
+    pentry->tp.ufshcd_command.opcode = opcode;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(6, 1, 0)
+    pentry->tp.ufshcd_command.hwq_id = (u8)hwq_id;
+#else
+    pentry->tp.ufshcd_command.hwq_id = 0;
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0)
+    pentry->tp.ufshcd_command.group_id = group_id;
+#else
+    pentry->tp.ufshcd_command.group_id = 0;
+#endif
+#if 0
+#ifdef CONFIG_ARCH_QCOM
+    hba = ufs_qcom_hosts[0]->hba;
+    lrbp = &hba->lrb[tag];
+    pentry->tp.ufshcd_command.elapsed = (str_t == UFS_CMD_COMP) ?
+              lrbp->compl_time_stamp - lrbp->issue_time_stamp : 0;
+    pentry->tp.ufshcd_command.gear_rx = hba->pwr_info.gear_rx;
+    pentry->tp.ufshcd_command.gear_tx = hba->pwr_info.gear_tx;
+    pentry->tp.ufshcd_command.lane_rx = hba->pwr_info.lane_rx;
+    pentry->tp.ufshcd_command.lane_tx = hba->pwr_info.lane_tx;
+    pentry->tp.ufshcd_command.pwr_rx = hba->pwr_info.pwr_rx;
+    pentry->tp.ufshcd_command.pwr_tx = hba->pwr_info.pwr_tx;
+#endif
+#endif
+    ring_buffer_writer_dec();
+}
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0) */
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+
+void abnormal_io_register_tracepoint_probes(void)
+{
+    int ret;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    ret = register_trace_f2fs_submit_page_write(record_f2fs_submit_page_write, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_submit_page_bio(record_f2fs_submit_page_bio, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_filemap_fault(record_f2fs_filemap_fault, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_submit_read_bio(record_f2fs_submit_read_bio, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_submit_write_bio(record_f2fs_submit_write_bio, NULL);
+    WARN_ON(ret);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    ret = register_trace_f2fs_dataread_start(record_f2fs_dataread_start, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_dataread_end(record_f2fs_dataread_end, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_datawrite_start(record_f2fs_datawrite_start, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_datawrite_end(record_f2fs_datawrite_end, NULL);
+    WARN_ON(ret);
+#endif
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    ret = register_trace_block_rq_issue(record_block_rq_issue, NULL);
+    WARN_ON(ret);
+    ret = register_trace_block_rq_complete(record_block_rq_complete, NULL);
+    WARN_ON(ret);
+    ret = register_trace_block_getrq(record_block_getrq, NULL);
+    WARN_ON(ret);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    ret = register_trace_block_bio_frontmerge(record_block_bio_frontmerge, NULL);
+    WARN_ON(ret);
+    ret = register_trace_block_bio_backmerge(record_block_bio_backmerge, NULL);
+    WARN_ON(ret);
+    ret = register_trace_block_bio_remap(record_block_bio_remap, NULL);
+    WARN_ON(ret);
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0)
+    ret = register_trace_ufshcd_command(record_ufshcd_command, NULL);
+    WARN_ON(ret);
+#endif
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+}
+
+void abnormal_io_unregister_tracepoint_probes(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    unregister_trace_f2fs_submit_page_write(record_f2fs_submit_page_write, NULL);
+    unregister_trace_f2fs_submit_page_bio(record_f2fs_submit_page_bio, NULL);
+    unregister_trace_f2fs_filemap_fault(record_f2fs_filemap_fault, NULL);
+    unregister_trace_f2fs_submit_read_bio(record_f2fs_submit_read_bio, NULL);
+    unregister_trace_f2fs_submit_write_bio(record_f2fs_submit_write_bio, NULL);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
+    unregister_trace_f2fs_dataread_start(record_f2fs_dataread_start, NULL);
+    unregister_trace_f2fs_dataread_end(record_f2fs_dataread_end, NULL);
+    unregister_trace_f2fs_datawrite_start(record_f2fs_datawrite_start, NULL);
+    unregister_trace_f2fs_datawrite_end(record_f2fs_datawrite_end, NULL);
+#endif
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    unregister_trace_block_rq_issue(record_block_rq_issue, NULL);
+    unregister_trace_block_rq_complete(record_block_rq_complete, NULL);
+    unregister_trace_block_getrq(record_block_getrq, NULL);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    unregister_trace_block_bio_frontmerge(record_block_bio_frontmerge, NULL);
+    unregister_trace_block_bio_backmerge(record_block_bio_backmerge, NULL);
+    unregister_trace_block_bio_remap(record_block_bio_remap, NULL);
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0) && (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    unregister_trace_ufshcd_command(record_ufshcd_command, NULL);
+#endif
+    tracepoint_synchronize_unregister();
+}
+
+static bool over_limit_dump(time64_t current_time_seconds)
+{
+    static int dump_limit_1_day = 1;
+
+    /* 当导出日志周期超过1天时重新计数 */
+    if ((current_time_seconds - base_dump_seconds) >= DAY_TO_SECONDS(1)) {
+        base_dump_seconds = current_time_seconds;
+        dump_limit_1_day = 1;
+    } else {
+        /* 1天的导出次数超过上限时不再继续导出 */
+        if (dump_limit_1_day <= abnormal_io_dump_limit_1_day) {
+            dump_limit_1_day++;
+        } else {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+int abnormal_io_dump_to_file(const char *logpath)
+{
+    int ret = 0;
+    time64_t current_time_seconds = ktime_get_boottime_seconds();
+
+    if (!atomic_read(&abnormal_io_enabled)) {
+        io_metrics_print("abnormal_io_enabled is disabled,please enable first");
+        return ret;
+    }
+    /* 控制多人同时导出操作 */
+    if (1 == atomic_inc_return(&multiple_dump)) {
+        if (((current_time_seconds - last_dump_seconds) > abnormal_io_dump_min_interval_s) &&
+                                      (!over_limit_dump(current_time_seconds))) {
+            last_dump_seconds = current_time_seconds;
+            ret = dump_data_to_file(logpath);
+        }
+    }
+    atomic_dec(&multiple_dump);
+
+    return ret;
+}
+void abnormal_io_init(void)
+{
+    if (1 != atomic_inc_return(&abnormal_io_enabled)) {
+        atomic_dec(&abnormal_io_enabled);
+        io_metrics_print("abnormal_io has registerd:%d\n", atomic_read(&abnormal_io_enabled));
+        return;
+    }
+    abnormal_io_trigger = false;
+    atomic_set(&multiple_dump, 0);
+    last_dump_seconds = 0;
+    base_dump_seconds = 0;
+    /* 默认1天导出日志的次数不可超过10次 */
+    abnormal_io_dump_limit_1_day = DUMP_LIMIT_1_DAY;
+    /* 默认两次导出日志时间间隔不得小于5分钟 */
+    abnormal_io_dump_min_interval_s = DUMP_MINIMUM_INTERVAL;
+    ring_buffer_int();
+    abnormal_io_register_tracepoint_probes();
+    if (sizeof(struct entry_t) != CACHELINE_SIZE) {
+        io_metrics_print("sizeof(struct entry_t): %d", (int)sizeof(struct entry_t));
+    } else {
+        io_metrics_print("ok");
+    }
+    io_metrics_print("init\n");
+}
+
+void abnormal_io_exit(void)
+{
+    if (0 != atomic_dec_return(&abnormal_io_enabled)) {
+        atomic_inc(&abnormal_io_enabled);
+        io_metrics_print("abnormal_io has unregisterd:%d\n", atomic_read(&abnormal_io_enabled));
+        return;
+    }
+    abnormal_io_unregister_tracepoint_probes();
+    io_metrics_print("exit\n");
+}
diff --git a/drivers/soc/oplus/storage/common/io_metrics/abnormal_io.h b/drivers/soc/oplus/storage/common/io_metrics/abnormal_io.h
new file mode 100644
index 000000000..2be346aa3
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/abnormal_io.h
@@ -0,0 +1,15 @@
+#ifndef __ABNORMAL_IO_H__
+#define __ABNORMAL_IO_H__
+#include <linux/fs.h>
+#include <linux/f2fs_fs.h>
+
+extern atomic_t abnormal_io_enabled;
+extern bool abnormal_io_trigger;
+extern int abnormal_io_dump_min_interval_s;
+extern int abnormal_io_dump_limit_1_day;
+
+int abnormal_io_dump_to_file(const char *logpath);
+void abnormal_io_init(void);
+void abnormal_io_exit(void);
+
+#endif /* __ABNORMAL_IO_H__ */
diff --git a/drivers/soc/oplus/storage/common/io_metrics/block_metrics.c b/drivers/soc/oplus/storage/common/io_metrics/block_metrics.c
new file mode 100644
index 000000000..84e88add9
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/block_metrics.c
@@ -0,0 +1,666 @@
+#include "io_metrics_entry.h"
+#include "procfs.h"
+#include "block_metrics.h"
+#include <trace/events/block.h>
+
+#define BLK_METRICS_LAT(op, size, layer)   \
+    atomic64_t blk_metrics_lat_##op##_##size##_##layer[LAT_500M_TO_MAX + 1] = {0};
+
+BLK_METRICS_LAT(read,    4k, in_blk);
+BLK_METRICS_LAT(read,    4k, in_drv);
+BLK_METRICS_LAT(write,   4k, in_blk);
+BLK_METRICS_LAT(write,   4k, in_drv);
+BLK_METRICS_LAT(read,  512k, in_blk);
+BLK_METRICS_LAT(read,  512k, in_drv);
+BLK_METRICS_LAT(write, 512k, in_blk);
+BLK_METRICS_LAT(write, 512k, in_drv);
+
+bool block_rq_issue_enabled = false;
+bool block_rq_complete_enabled = false;
+module_param(block_rq_issue_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(block_rq_issue_enabled, " Debug block_rq_issue");
+module_param(block_rq_complete_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(block_rq_complete_enabled, " Debug block_rq_complete");
+
+struct blk_metrics_struct blk_metrics[OP_MAX][CYCLE_MAX][IO_SIZE_MAX] = {0};
+spinlock_t blk_metrics_lock[OP_MAX][CYCLE_MAX][IO_SIZE_MAX];
+
+static void block_stat_update(struct request *rq, enum io_op_type op_type,
+                                                  u64 io_complete_time_ns)
+{
+    unsigned long flags;
+    u64 elapse = 0;
+    int i = 0;
+    u64 in_driver = (io_complete_time_ns > rq->io_start_time_ns) && rq->io_start_time_ns ?
+                    (io_complete_time_ns - rq->io_start_time_ns) : 0;
+    u64 in_block = (rq->io_start_time_ns > rq->start_time_ns) && rq->start_time_ns ?
+                    (rq->io_start_time_ns - rq->start_time_ns) : 0;
+    u64 in_d_and_b = in_driver + in_block;
+    u64 in_driver_lat_range = LAT_500M_TO_MAX;
+    u64 in_block_lat_range = LAT_500M_TO_MAX;
+    enum io_range io_range = IO_SIZE_MAX;
+    u32 nr_bytes = blk_rq_bytes(rq);
+
+    if (nr_bytes >= IO_SIZE_512K_TO_MAX_MASK) {/* [512K, +∞) */
+        io_range = IO_SIZE_512K_TO_MAX;
+    } else if (nr_bytes > IO_SIZE_128K_TO_512K_MASK) {/* (128K, 512K) */
+        io_range = IO_SIZE_128K_TO_512K;
+    } else if (nr_bytes > IO_SIZE_32K_TO_128K_MASK) {/* (32K, 128K] */
+        io_range = IO_SIZE_32K_TO_128K;
+    } else if (nr_bytes > IO_SIZE_4K_TO_32K_MASK) {/* (4K, 32K] */
+        io_range = IO_SIZE_4K_TO_32K;
+    } else {/* (0, 4K] */
+        io_range = IO_SIZE_0_TO_4K;
+    }
+
+    /* 根据不同时间窗口计算一个采样周期内的平均耗时、最大耗时*/
+    for (i = 0; i < CYCLE_MAX; i++) {
+        elapse = io_complete_time_ns - blk_metrics[op_type][i][io_range].timestamp;
+        /* 统计复位(timestamp为0)、统计异常（timestamp比io_complete_time_ns大） */
+        if (unlikely(elapse >= io_complete_time_ns)) {
+            flags = 0;
+            spin_lock_irqsave(&blk_metrics_lock[op_type][i][io_range], flags);
+            blk_metrics[op_type][i][io_range].timestamp = io_complete_time_ns;
+            blk_metrics[op_type][i][io_range].total_cnt = 1;
+            blk_metrics[op_type][i][io_range].total_size = nr_bytes;
+            blk_metrics[op_type][i][io_range].layer[IN_BLOCK].elapse_time = in_block;
+            blk_metrics[op_type][i][io_range].layer[IN_DRIVER].elapse_time = in_driver;
+            blk_metrics[op_type][i][io_range].layer[IN_BLOCK].max_time = in_block;
+            blk_metrics[op_type][i][io_range].layer[IN_DRIVER].max_time = in_driver;
+            blk_metrics[op_type][i][io_range].max_time = in_d_and_b;
+            spin_unlock_irqrestore(&blk_metrics_lock[op_type][i][io_range], flags);
+            elapse = 0;
+            if (op_type == OP_READ) {
+                if (likely(io_range == IO_SIZE_0_TO_4K)) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    memset(&blk_metrics_lat_read_4k_in_blk, 0, sizeof(blk_metrics_lat_read_4k_in_blk));
+                    memset(&blk_metrics_lat_read_4k_in_drv, 0, sizeof(blk_metrics_lat_read_4k_in_drv));
+                    atomic64_set(&blk_metrics_lat_read_4k_in_blk[in_block_lat_range], 1);
+                    atomic64_set(&blk_metrics_lat_read_4k_in_drv[in_driver_lat_range], 1);
+                } else if (io_range == IO_SIZE_512K_TO_MAX) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    memset(&blk_metrics_lat_read_512k_in_blk, 0, sizeof(blk_metrics_lat_read_512k_in_blk));
+                    memset(&blk_metrics_lat_read_512k_in_drv, 0, sizeof(blk_metrics_lat_read_512k_in_drv));
+                    atomic64_set(&blk_metrics_lat_read_512k_in_blk[in_block_lat_range], 1);
+                    atomic64_set(&blk_metrics_lat_read_512k_in_drv[in_driver_lat_range], 1);
+                }
+            } else if (op_type == OP_WRITE) {
+                if (likely(io_range == IO_SIZE_0_TO_4K)) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    memset(&blk_metrics_lat_write_4k_in_blk, 0, sizeof(blk_metrics_lat_write_4k_in_blk));
+                    memset(&blk_metrics_lat_write_4k_in_drv, 0, sizeof(blk_metrics_lat_write_4k_in_drv));
+                    atomic64_set(&blk_metrics_lat_write_4k_in_blk[in_block_lat_range], 1);
+                    atomic64_set(&blk_metrics_lat_write_4k_in_drv[in_driver_lat_range], 1);
+                } else if (io_range == IO_SIZE_512K_TO_MAX) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    memset(&blk_metrics_lat_write_512k_in_blk, 0, sizeof(blk_metrics_lat_write_512k_in_blk));
+                    memset(&blk_metrics_lat_write_512k_in_drv, 0, sizeof(blk_metrics_lat_write_512k_in_drv));
+                    atomic64_set(&blk_metrics_lat_write_512k_in_blk[in_block_lat_range], 1);
+                    atomic64_set(&blk_metrics_lat_write_512k_in_drv[in_driver_lat_range], 1);
+                }
+            }
+        } else { /* 没有满足一个采样周期时更新数据 */
+            flags = 0;
+            spin_lock_irqsave(&blk_metrics_lock[op_type][i][io_range], flags);
+            blk_metrics[op_type][i][io_range].total_cnt += 1;
+            blk_metrics[op_type][i][io_range].total_size += nr_bytes;
+            blk_metrics[op_type][i][io_range].layer[IN_BLOCK].elapse_time += in_block;
+            blk_metrics[op_type][i][io_range].layer[IN_DRIVER].elapse_time += in_driver;
+
+            /* 最大值 */
+            blk_metrics[op_type][i][io_range].layer[IN_BLOCK].max_time =
+               (blk_metrics[op_type][i][io_range].layer[IN_BLOCK].max_time > in_block) ?
+               blk_metrics[op_type][i][io_range].layer[IN_BLOCK].max_time : in_block;
+            blk_metrics[op_type][i][io_range].layer[IN_DRIVER].max_time =
+               (blk_metrics[op_type][i][io_range].layer[IN_DRIVER].max_time > in_driver) ?
+               blk_metrics[op_type][i][io_range].layer[IN_DRIVER].max_time : in_driver;
+            blk_metrics[op_type][i][io_range].max_time =
+               (blk_metrics[op_type][i][io_range].max_time > in_d_and_b) ?
+               blk_metrics[op_type][i][io_range].max_time : in_d_and_b;
+            spin_unlock_irqrestore(&blk_metrics_lock[op_type][i][io_range], flags);
+            if (op_type == OP_READ) {
+                if (likely(io_range == IO_SIZE_0_TO_4K)) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    atomic64_inc(&blk_metrics_lat_read_4k_in_blk[in_block_lat_range]);
+                    atomic64_inc(&blk_metrics_lat_read_4k_in_drv[in_driver_lat_range]);
+                } else if (io_range == IO_SIZE_512K_TO_MAX) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    atomic64_inc(&blk_metrics_lat_read_512k_in_blk[in_block_lat_range]);
+                    atomic64_inc(&blk_metrics_lat_read_512k_in_drv[in_driver_lat_range]);
+                }
+            } else if (op_type == OP_WRITE) {
+                if (likely(io_range == IO_SIZE_0_TO_4K)) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    atomic64_inc(&blk_metrics_lat_write_4k_in_blk[in_block_lat_range]);
+                    atomic64_inc(&blk_metrics_lat_write_4k_in_drv[in_driver_lat_range]);
+                } else if (io_range == IO_SIZE_512K_TO_MAX) {
+                    lat_range_check(in_block, in_block_lat_range);
+                    lat_range_check(in_driver, in_driver_lat_range);
+                    atomic64_inc(&blk_metrics_lat_write_512k_in_blk[in_block_lat_range]);
+                    atomic64_inc(&blk_metrics_lat_write_512k_in_drv[in_driver_lat_range]);
+                }
+            }
+
+        }
+        if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+            /* 过期复位 */
+            flags = 0;
+            spin_lock_irqsave(&blk_metrics_lock[op_type][i][io_range], flags);
+            blk_metrics[op_type][i][io_range].timestamp = 0;
+            spin_unlock_irqrestore(&blk_metrics_lock[op_type][i][io_range], flags);
+        }
+    }
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 11, 0)
+static char *blk_get_disk_name(struct gendisk *hd, int partno, char *buf)
+{
+    if (!partno)
+        snprintf(buf, BDEVNAME_SIZE, "%s", hd->disk_name);
+    else if (isdigit(hd->disk_name[strlen(hd->disk_name)-1]))
+        snprintf(buf, BDEVNAME_SIZE, "%sp%d", hd->disk_name, partno);
+    else
+        snprintf(buf, BDEVNAME_SIZE, "%s%d", hd->disk_name, partno);
+
+    return buf;
+}
+#endif
+
+static void blk_fill_rwbs_private(char *rwbs, unsigned int op, int bytes)
+{
+    int i = 0;
+    if (op & REQ_PREFLUSH)
+        rwbs[i++] = 'F';
+    switch (op & REQ_OP_MASK) {
+    case REQ_OP_WRITE:
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+    case REQ_OP_WRITE_SAME:
+#endif
+        rwbs[i++] = 'W';
+        break;
+    case REQ_OP_DISCARD:
+        rwbs[i++] = 'D';
+        break;
+    case REQ_OP_SECURE_ERASE:
+        rwbs[i++] = 'D';
+        rwbs[i++] = 'E';
+        break;
+    case REQ_OP_FLUSH:
+        rwbs[i++] = 'F';
+        break;
+    case REQ_OP_READ:
+        rwbs[i++] = 'R';
+        break;
+    default:
+        rwbs[i++] = 'N';
+    }
+    if (op & REQ_FUA)
+        rwbs[i++] = 'F';
+    if (op & REQ_RAHEAD)
+        rwbs[i++] = 'A';
+    if (op & REQ_SYNC)
+        rwbs[i++] = 'S';
+    if (op & REQ_META)
+        rwbs[i++] = 'M';
+    rwbs[i] = '\0';
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 15, 0)
+/**
+There is no consistency between Google and the Linux community here.
+The Linux community only one parameter(request) after 5.10.136, But
+Google Revert the Linux community update to the old version
+on Android 12-5.10-LTS, which means the item on 5.10
+No matter how the small version is upgraded, as long as it is an Android 12-5.10
+project, it will have two parameters(request_queue and request)
+https://android-review.googlesource.com/c/kernel/common/+/2201398
+*/
+static void cb_block_rq_issue(void *ignore, struct request_queue *q,
+                             struct request *rq)
+#else
+static void cb_block_rq_issue(void *ignore, struct request *rq)
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(5, 10, 136) */
+{
+    if (unlikely(!io_metrics_enabled)) {
+        return ;
+    }
+    rq->io_start_time_ns = ktime_get_ns();
+    if (unlikely(io_metrics_debug_enabled || block_rq_issue_enabled)) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+        char *devname = rq->rq_disk ? rq->rq_disk->disk_name : "";
+#else
+        char *devname = rq->part ? (rq->part->bd_disk ? rq->part->bd_disk->disk_name : "") : "";
+#endif
+        char rwbs[RWBS_LEN]={};
+        unsigned int nr_bytes = blk_rq_bytes(rq);
+
+        blk_fill_rwbs_private(rwbs, rq->cmd_flags, nr_bytes);
+
+        io_metrics_print("dev:%-6s rwbs:%-4s nr_bytes:%-10d " \
+          "start_time_ns:%-16llu io_start_time_ns:%-16llu \n",
+          devname, rwbs, nr_bytes, rq->start_time_ns, rq->io_start_time_ns);
+    }
+}
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+static void cb_block_rq_complete(void *ignore, struct request *rq,
+                      int error, unsigned int nr_bytes)
+#else
+static void cb_block_rq_complete(void *ignore, struct request *rq,
+                      blk_status_t error, unsigned int nr_bytes)
+#endif
+{
+    u64 io_complete_time_ns = ktime_get_ns();
+    u64 in_driver = (io_complete_time_ns > rq->io_start_time_ns) && rq->io_start_time_ns ?
+                    (io_complete_time_ns - rq->io_start_time_ns) : 0;
+    u64 in_block = (rq->io_start_time_ns > rq->start_time_ns) && rq->start_time_ns ?
+                    (rq->io_start_time_ns - rq->start_time_ns) : 0;
+
+    if (unlikely(!io_metrics_enabled)) {
+        return ;
+    }
+
+    switch (rq->cmd_flags & REQ_OP_MASK) {
+        case REQ_OP_WRITE:
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+        case REQ_OP_WRITE_SAME:
+#endif
+            if (!error && nr_bytes) {
+#if 1
+                block_stat_update(rq, OP_WRITE, io_complete_time_ns);
+#endif
+#if 0
+                if (rq->cmd_flags & REQ_SYNC) {
+                    block_stat_update(rq, OP_WRITE_SYNC, io_complete_time_ns);
+                } else if (rq->cmd_flags & REQ_META) {
+                    block_stat_update(rq, OP_WRITE_META, io_complete_time_ns);
+                } else {
+                    block_stat_update(rq, OP_WRITE, io_complete_time_ns);
+                }
+#endif
+            }
+            break;
+#if 0
+        case REQ_OP_DISCARD:
+            if (!error && nr_bytes) {
+                block_stat_update(rq, OP_DISCARD, io_complete_time_ns);
+            }
+            break;
+        case REQ_OP_SECURE_ERASE:
+            if (!error && nr_bytes) {
+                block_stat_update(rq, OP_SECURE_ERASE, io_complete_time_ns);
+            }
+            break;
+        case REQ_OP_FLUSH:
+            if (!error && nr_bytes) {
+                block_stat_update(rq, OP_FLUSH, io_complete_time_ns);
+            }
+            break;
+#endif
+        case REQ_OP_READ:
+            if (!error && nr_bytes) {
+#if 1
+                block_stat_update(rq, OP_READ, io_complete_time_ns);
+#endif
+#if 0
+                if (rq->cmd_flags & REQ_RAHEAD) {
+                    block_stat_update(rq, OP_RAHEAD, io_complete_time_ns);
+                } else if (rq->cmd_flags & REQ_META) {
+                    block_stat_update(rq, OP_READ_META, io_complete_time_ns);
+                }else {
+                    block_stat_update(rq, OP_READ, io_complete_time_ns);
+                }
+#endif
+            }
+            break;
+        default:
+            break;
+    }
+
+    if (unlikely(io_metrics_debug_enabled || block_rq_complete_enabled)) {
+        char devname[BDEVNAME_SIZE] = {0};
+        char rwbs[RWBS_LEN]={0};
+
+        blk_fill_rwbs_private(rwbs, rq->cmd_flags, nr_bytes);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 11, 0)
+        if (rq->bio && rq->bio->bi_disk) {
+            blk_get_disk_name(rq->bio->bi_disk, rq->bio->bi_partno, devname);
+#else
+        if (rq->bio && rq->bio->bi_bdev) {
+        //todo 通过block_device获取设备名称
+        //disk_name(rq->bio->bi_disk, rq->bio->bi_partno, devname);
+        devname[0] = '\0';
+#endif
+        } else {
+            devname[0] = '\0';
+        }
+
+        io_metrics_print("dev:%-6s rwbs:%-4s nr_bytes:%-10d error:%-3d " \
+            "start_time_ns:%-16llu io_start_time_ns:%-16llu io_complete_time_ns:%-16llu " \
+            "in_driver:%-10llu in_block:%-10llu\n", devname, rwbs, nr_bytes,
+            error, rq->start_time_ns, rq->io_start_time_ns, io_complete_time_ns,
+            in_driver, in_block);
+    }
+    return;
+}
+
+struct {
+    const char *name;
+    void *callback;
+    struct tracepoint *tp;
+    void *data;
+} tracepoint_probes[] = {
+    {"block_rq_issue", cb_block_rq_issue, NULL, NULL},
+    {"block_rq_complete", cb_block_rq_complete, NULL, NULL},
+    {NULL, NULL, NULL, NULL}
+};
+
+void block_register_tracepoint_probes(void)
+{
+    int ret;
+
+    ret = register_trace_block_rq_issue(cb_block_rq_issue, NULL);
+    ret = register_trace_block_rq_complete(cb_block_rq_complete, NULL);
+
+    return;
+}
+
+void block_unregister_tracepoint_probes(void)
+{
+    unregister_trace_block_rq_issue(cb_block_rq_issue, NULL);
+    unregister_trace_block_rq_complete(cb_block_rq_complete, NULL);
+
+    return;
+}
+
+struct {
+    enum io_op_type value;
+    const char * tag;
+} io_op_config[] = {
+    {OP_READ,         "read"      },
+    {OP_WRITE,        "write"     },
+#if 0
+    {OP_RAHEAD,       "rahead"    },
+    {OP_WRITE_SYNC,   "write_sync"},
+    {OP_READ_META,    "read_meta" },
+    {OP_WRITE_META,   "write_meta"},
+    {OP_DISCARD,      "discard"   },
+    {OP_SECURE_ERASE, "erase"     },
+    {OP_FLUSH,        "flush"     },
+#endif
+    {OP_MAX,          NULL        },
+};
+
+/*当前函数理论每个node一天只需要访问一次，因此可以不用太考虑性能，只关注代码紧凑性*/
+static int block_metrics_proc_show(struct seq_file *seq_filp, void *data)
+{
+    int i = 0;
+    enum io_op_type io_op;
+    u64 value = 0;
+    enum sample_cycle_type cycle;
+    struct file *file = (struct file *)seq_filp->private;
+
+    if (unlikely(!io_metrics_enabled)) {
+        seq_printf(seq_filp, "io_metrics_enabled not set to 1:%d\n", io_metrics_enabled);
+        return 0;
+    }
+    if (proc_show_enabled ||unlikely(io_metrics_debug_enabled)) {
+        io_metrics_print("%s(%d) read %s/%s\n",
+            current->comm, current->pid, file->f_path.dentry->d_parent->d_iname,
+            file->f_path.dentry->d_iname);
+    }
+    /* 确定采样周期的值（父目录） */
+    cycle = CYCLE_MAX;
+    for (i = 0; i < CYCLE_MAX; i++) {
+        if(!strcmp(file->f_path.dentry->d_parent->d_iname, sample_cycle_config[i].tag)) {
+            cycle = sample_cycle_config[i].value;
+        }
+    }
+    if (unlikely(cycle == CYCLE_MAX)) {
+        goto err;
+    }
+
+    /* 确定读、写操作命令 */
+    io_op = OP_MAX;
+    for (i = 0; i < OP_MAX; i++) {
+        if (strstr(file->f_path.dentry->d_iname, io_op_config[i].tag)) {
+            io_op = io_op_config[i].value;
+            break;
+        }
+    }
+    if (unlikely(io_op == OP_MAX)) {
+        goto err;
+    }
+    if (OP_MAX == OP_READ) {
+        goto bio_read;
+    } else if (OP_MAX == OP_WRITE) {
+         goto bio_write;
+    }
+
+    /* 确定读的具体是那个节点 */
+bio_read:
+    if (!strcmp(file->f_path.dentry->d_iname, "bio_read_cnt")) {
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            value += blk_metrics[OP_READ][cycle][i].total_cnt;
+        }
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_avg_size")) {
+        unsigned long flags = 0;
+        u64 total_size = 0;
+        u64 total_cnt = 0;
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            flags = 0;
+            spin_lock_irqsave(&blk_metrics_lock[OP_READ][cycle][i], flags);
+            total_size += blk_metrics[OP_READ][cycle][i].total_size;
+            total_cnt += blk_metrics[OP_READ][cycle][i].total_cnt;
+            spin_unlock_irqrestore(&blk_metrics_lock[OP_READ][cycle][i], flags);
+        }
+        value = total_size / total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_size_dist")) {
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", blk_metrics[OP_READ][cycle][i].total_cnt);
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_avg_time")) {
+        u64 total_time = 0;
+        u64 total_cnt = 0;
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            total_time += blk_metrics[OP_READ][cycle][i].layer[IN_BLOCK].elapse_time;
+            total_time += blk_metrics[OP_READ][cycle][i].layer[IN_DRIVER].elapse_time;
+            total_cnt += blk_metrics[OP_READ][cycle][i].total_cnt;
+        }
+        value = total_time / total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_max_time")) {
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            value = (value > blk_metrics[OP_READ][cycle][i].max_time) ?
+                      value : blk_metrics[OP_READ][cycle][i].max_time;
+        }
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_4k_blk_avg_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_0_TO_4K].layer[IN_BLOCK].elapse_time /
+                blk_metrics[OP_READ][cycle][IO_SIZE_0_TO_4K].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_4k_blk_max_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_0_TO_4K].layer[IN_BLOCK].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_4k_blk_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_read_4k_in_blk[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_4k_drv_avg_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_0_TO_4K].layer[IN_DRIVER].elapse_time /
+                blk_metrics[OP_READ][cycle][IO_SIZE_0_TO_4K].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_4k_drv_max_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_0_TO_4K].layer[IN_DRIVER].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_4k_drv_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_read_4k_in_drv[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_512k_blk_avg_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_512K_TO_MAX].layer[IN_BLOCK].elapse_time /
+                blk_metrics[OP_READ][cycle][IO_SIZE_512K_TO_MAX].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_512k_blk_max_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_512K_TO_MAX].layer[IN_BLOCK].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_512k_blk_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_read_512k_in_blk[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_512k_drv_avg_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_512K_TO_MAX].layer[IN_DRIVER].elapse_time /
+                blk_metrics[OP_READ][cycle][IO_SIZE_512K_TO_MAX].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_512k_drv_max_time")) {
+        value = blk_metrics[OP_READ][cycle][IO_SIZE_512K_TO_MAX].layer[IN_DRIVER].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_read_512k_drv_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_read_512k_in_drv[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    }
+
+bio_write:
+    if (!strcmp(file->f_path.dentry->d_iname, "bio_write_cnt")) {
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            value += blk_metrics[OP_WRITE][cycle][i].total_cnt;
+        }
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_avg_size")) {
+        unsigned long flags = 0;
+        u64 total_size = 0;
+        u64 total_cnt = 0;
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            flags = 0;
+            spin_lock_irqsave(&blk_metrics_lock[OP_WRITE][cycle][i], flags);
+            total_size += blk_metrics[OP_WRITE][cycle][i].total_size;
+            total_cnt += blk_metrics[OP_WRITE][cycle][i].total_cnt;
+            spin_unlock_irqrestore(&blk_metrics_lock[OP_WRITE][cycle][i], flags);
+        }
+        value = total_size / total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_size_dist")) {
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", blk_metrics[OP_WRITE][cycle][i].total_cnt);
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_avg_time")) {
+        u64 total_time = 0;
+        u64 total_cnt = 0;
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            total_time += blk_metrics[OP_WRITE][cycle][i].layer[IN_BLOCK].elapse_time;
+            total_time += blk_metrics[OP_WRITE][cycle][i].layer[IN_DRIVER].elapse_time;
+            total_cnt += blk_metrics[OP_WRITE][cycle][i].total_cnt;
+        }
+        value = total_time / total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_max_time")) {
+        value = 0;
+        for (i = 0; i < IO_SIZE_MAX; i++) {
+            value = (value > blk_metrics[OP_WRITE][cycle][i].max_time) ?
+                      value : blk_metrics[OP_WRITE][cycle][i].max_time;
+        }
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_4k_blk_avg_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_0_TO_4K].layer[IN_BLOCK].elapse_time /
+                blk_metrics[OP_WRITE][cycle][IO_SIZE_0_TO_4K].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_4k_blk_max_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_0_TO_4K].layer[IN_BLOCK].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_4k_blk_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_write_4k_in_blk[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_4k_drv_avg_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_0_TO_4K].layer[IN_DRIVER].elapse_time /
+                blk_metrics[OP_WRITE][cycle][IO_SIZE_0_TO_4K].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_4k_drv_max_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_0_TO_4K].layer[IN_DRIVER].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_4k_drv_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_write_4k_in_drv[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_512k_blk_avg_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_512K_TO_MAX].layer[IN_BLOCK].elapse_time /
+                blk_metrics[OP_WRITE][cycle][IO_SIZE_512K_TO_MAX].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_512k_blk_max_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_512K_TO_MAX].layer[IN_BLOCK].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_512k_blk_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_write_512k_in_blk[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_512k_drv_avg_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_512K_TO_MAX].layer[IN_DRIVER].elapse_time /
+                blk_metrics[OP_WRITE][cycle][IO_SIZE_512K_TO_MAX].total_cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_512k_drv_max_time")) {
+        value = blk_metrics[OP_WRITE][cycle][IO_SIZE_512K_TO_MAX].layer[IN_DRIVER].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "bio_write_512k_drv_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&blk_metrics_lat_write_512k_in_drv[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    }
+
+    seq_printf(seq_filp, "%llu\n", value);
+
+    return 0;
+
+err:
+    io_metrics_print("%s(%d) I don't understand what the operation: %s/%s\n",
+    current->comm,current->pid,
+    file->f_path.dentry->d_parent->d_iname, file->f_path.dentry->d_iname);
+    return -1;
+}
+
+int block_metrics_proc_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, block_metrics_proc_show, file);
+}
+
+void block_metrics_reset(void)
+{
+    /* 此处可以优化，如果blk_metrics_struct中有锁成员时 */
+    memset(blk_metrics, 0, OP_MAX * CYCLE_MAX * IO_SIZE_MAX
+                         * sizeof(struct blk_metrics_struct));
+    io_metrics_print("size:%lu\n", OP_MAX * CYCLE_MAX * IO_SIZE_MAX
+                              * sizeof(struct blk_metrics_struct));
+    memset(&blk_metrics_lat_read_4k_in_blk, 0, sizeof(blk_metrics_lat_read_4k_in_blk));
+    memset(&blk_metrics_lat_read_4k_in_drv, 0, sizeof(blk_metrics_lat_read_4k_in_drv));
+    memset(&blk_metrics_lat_write_4k_in_blk, 0, sizeof(blk_metrics_lat_write_4k_in_blk));
+    memset(&blk_metrics_lat_write_4k_in_drv, 0, sizeof(blk_metrics_lat_write_4k_in_drv));
+    memset(&blk_metrics_lat_read_512k_in_blk, 0, sizeof(blk_metrics_lat_read_512k_in_blk));
+    memset(&blk_metrics_lat_read_512k_in_drv, 0, sizeof(blk_metrics_lat_read_512k_in_drv));
+    memset(&blk_metrics_lat_write_512k_in_blk, 0, sizeof(blk_metrics_lat_write_512k_in_blk));
+    memset(&blk_metrics_lat_write_512k_in_drv, 0, sizeof(blk_metrics_lat_write_512k_in_drv));
+}
+
+void block_metrics_init(void)
+{
+    int i, j, k;
+
+    block_metrics_reset();
+    for (i = 0; i < OP_MAX; i++) {
+        for (j = 0; j < CYCLE_MAX; j++) {
+            for (k = 0; k < IO_SIZE_MAX; k++) {
+                spin_lock_init(&blk_metrics_lock[i][j][k]);
+            }
+        }
+    }
+}
diff --git a/drivers/soc/oplus/storage/common/io_metrics/block_metrics.h b/drivers/soc/oplus/storage/common/io_metrics/block_metrics.h
new file mode 100644
index 000000000..7569cf2e6
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/block_metrics.h
@@ -0,0 +1,73 @@
+#ifndef __BLOCK_METRICS_H__
+#define __BLOCK_METRICS_H__
+
+#include <linux/fs.h>
+
+#define IO_SIZE_4K_TO_32K_MASK       4096
+#define IO_SIZE_32K_TO_128K_MASK     32768
+#define IO_SIZE_128K_TO_512K_MASK    131072
+#define IO_SIZE_512K_TO_MAX_MASK     524288
+
+/* IO大小分布 */
+enum io_range {
+    IO_SIZE_0_TO_4K = 0,  /* (0, 4K]      */
+    IO_SIZE_4K_TO_32K,    /* (4K, 32K]    */
+    IO_SIZE_32K_TO_128K,  /* (32K, 128K]  */
+    IO_SIZE_128K_TO_512K, /* (128K, 512K) */
+    IO_SIZE_512K_TO_MAX, /*  [512K, +∞)   */
+    IO_SIZE_MAX /* 记录总的流量,不分大小 */
+};
+
+/* IO操作类型 */
+enum io_op_type {
+    OP_READ = 0,
+    OP_WRITE,
+#if 0
+    OP_RAHEAD,
+    OP_WRITE_SYNC,
+    OP_READ_META,
+    OP_WRITE_META,
+    OP_DISCARD,
+    OP_SECURE_ERASE,
+    OP_FLUSH,
+#endif
+    OP_MAX
+};
+
+/* 不同层IO的耗时 */
+enum layer_type {
+    IN_DRIVER = 0,/* IO在driver层的耗时 */
+    IN_BLOCK,     /* IO在block层的耗时  */
+    LAYER_MAX
+};
+
+//Ensure cache line alignment
+struct blk_metrics_struct {
+    /* 开始统计的时间戳 */
+    u64 timestamp;
+    /* IO计数 */
+    u64 total_cnt;
+    /* IO总的大小 */
+    u64 total_size;
+    /* block+driver的最大耗时 */
+    u64 max_time;
+    struct {
+        /* 累计耗时 */
+        u64 elapse_time;
+        /* 最大耗时 */
+        u64 max_time;
+    } layer[LAYER_MAX];//对block、driver层分别统计
+};
+
+extern bool block_rq_issue_enabled;
+extern bool block_rq_complete_enabled;
+extern struct blk_metrics_struct blk_metrics[OP_MAX][CYCLE_MAX][IO_SIZE_MAX];
+extern spinlock_t blk_metrics_lock[OP_MAX][CYCLE_MAX][IO_SIZE_MAX];
+
+void block_register_tracepoint_probes(void);
+void block_unregister_tracepoint_probes(void);
+int block_metrics_proc_open(struct inode *inode, struct file *file);
+void block_metrics_reset(void);
+void block_metrics_init(void);
+
+#endif /* __BLOCK_METRICS_H__ */
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.c b/drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.c
new file mode 100644
index 000000000..027eb8a7c
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.c
@@ -0,0 +1,431 @@
+#include "io_metrics_entry.h"
+#include "f2fs_metrics.h"
+#include "procfs.h"
+#include "fs/f2fs/f2fs.h"
+#include "fs/f2fs/segment.h"
+#include "fs/f2fs/node.h"
+#include <trace/events/f2fs.h>
+
+bool f2fs_issue_discard_enabled = false;
+bool f2fs_gc_begin_enabled = false;
+bool f2fs_gc_end_enabled = false;
+bool f2fs_write_checkpoint_enabled = false;
+bool f2fs_sync_file_enter_enabled = false;
+bool f2fs_sync_file_exit_enabled = false;
+bool f2fs_dataread_start_enabled = false;
+bool f2fs_dataread_end_enabled = false;
+bool f2fs_datawrite_start_enabled = false;
+bool f2fs_datawrite_end_enabled = false;
+
+module_param(f2fs_issue_discard_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_issue_discard_enabled, " Debug f2fs_issue_discard");
+module_param(f2fs_gc_begin_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_gc_begin_enabled, " Debug f2fs_gc_begin");
+module_param(f2fs_gc_end_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_gc_end_enabled, " Debug f2fs_gc_end");
+module_param(f2fs_write_checkpoint_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_write_checkpoint_enabled, " Debug f2fs_write_checkpoint");
+module_param(f2fs_sync_file_enter_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_sync_file_enter_enabled, " Debug f2fs_sync_file_enter");
+module_param(f2fs_sync_file_exit_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_sync_file_exit_enabled, " Debug f2fs_sync_file_exit");
+module_param(f2fs_dataread_start_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_dataread_start_enabled, " Debug f2fs_dataread_start");
+module_param(f2fs_dataread_end_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_dataread_end_enabled, " Debug f2fs_dataread_end");
+module_param(f2fs_datawrite_start_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_datawrite_start_enabled, " Debug f2fs_datawrite_start");
+module_param(f2fs_datawrite_end_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(f2fs_datawrite_end_enabled, " Debug f2fs_datawrite_end");
+
+enum {
+    GC_BG = 0,  //后台GC
+    GC_FG,      //前台GC
+    GC_MAX
+};
+atomic64_t f2fs_metrics_timestamp[CYCLE_MAX];
+/* gc自己有锁保护，没有竞争，因此无需自定义锁 */
+struct {
+    /* 累计耗时 */
+    u64 elapse_time;
+    /* 最近一次gc开始时间 */
+    u64 begin_time;
+    /* gc总次数 */
+    u64 cnt;
+    /* 平均一次gc的耗时 */
+    u64 avg_time;
+    /* 回收的总的segment数 */
+    u64 segs;
+    /* 平均一次gc回收的segment数 */
+    u64 avg_segs;
+    /* 每次GC中有效block占比的平均值 */
+    u64 efficiency;
+    char padding[8];
+} f2fs_gc_metrics[CYCLE_MAX][GC_MAX];//对不同层统计
+
+/* cp自己有gc锁保护，没有竞争，因此无需自定义锁 */
+struct {
+    /* cp总次数 */
+    u64 cnt;
+    /* 累计耗时 */
+    u64 elapse_time;
+    /* 最近一次gc开始时间 */
+    u64 begin_time;
+    /* 平均耗时 */
+    u64 avg_time;
+    /* 最大耗时 */
+    u64 max_time;
+    /* 本地更新次数 */
+    u32 inplace_count;
+    char padding[20];
+} f2fs_cp_metrics[CYCLE_MAX] = {0};
+
+struct {
+    /* discard次数 */
+    u64 discard_cnt;
+    u64 discard_len;
+    u64 ipu_cnt;
+    u64 fsync_cnt;
+    char padding[32];
+} f2fs_metrics[CYCLE_MAX] = {0};
+
+static void cb_f2fs_issue_discard(void *ignore, struct block_device *dev,
+                                          block_t blkstart, block_t blklen)
+{
+    int i;
+    u64 current_time_ns, elapse;
+
+    if (unlikely(!io_metrics_enabled)) {
+        return;
+    }
+    current_time_ns = ktime_get_ns();
+
+    for (i = 0; i < CYCLE_MAX; i++) {
+        elapse = current_time_ns - atomic64_read(&f2fs_metrics_timestamp[i]);
+        /* 统计复位(timestamp为0)、统计异常（timestamp比current_time_ns大） */
+        if (unlikely(elapse >= current_time_ns)) {
+            atomic64_set(&f2fs_metrics_timestamp[i], current_time_ns);
+            f2fs_metrics[i].discard_cnt = 1;
+            f2fs_metrics[i].discard_len = blklen;
+            elapse = 0;
+        } else {
+            f2fs_metrics[i].discard_cnt += 1;
+            f2fs_metrics[i].discard_len += blklen;
+        }
+        if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+            atomic64_set(&f2fs_metrics_timestamp[i], 0);
+        }
+    }
+    if (unlikely(io_metrics_debug_enabled || f2fs_issue_discard_enabled)) {
+        io_metrics_print("current_time_ns:%llu\n", current_time_ns);
+    }
+};
+int gc_t;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+static void cb_f2fs_gc_begin(void *ignore, struct super_block *sb, bool sync,
+            bool background, long long dirty_nodes, long long dirty_dents,
+            long long dirty_imeta, unsigned int free_sec,
+            unsigned int free_seg, int reserved_seg,
+            unsigned int prefree_seg)
+#else
+static void cb_f2fs_gc_begin(void *ignore, struct super_block *sb, int gc_type, bool no_bg_gc,
+            unsigned int nr_free_secs,
+            long long dirty_nodes, long long dirty_dents,
+            long long dirty_imeta, unsigned int free_sec,
+            unsigned int free_seg, int reserved_seg,
+            unsigned int prefree_seg)
+#endif
+{
+    int i;
+    u64 current_time_ns, elapse;
+
+    if (unlikely(!io_metrics_enabled)) {
+        return;
+    }
+    current_time_ns = ktime_get_ns();
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+    gc_t = background ? GC_BG : GC_FG;
+#else
+    gc_t = no_bg_gc ? GC_FG : GC_BG;
+#endif
+    for (i = 0; i < CYCLE_MAX; i++) {
+        elapse = current_time_ns - atomic64_read(&f2fs_metrics_timestamp[i]);
+        if (unlikely(elapse >= current_time_ns)) {
+            atomic64_set(&f2fs_metrics_timestamp[i], current_time_ns);
+            f2fs_gc_metrics[i][gc_t].elapse_time = 0;
+            f2fs_gc_metrics[i][gc_t].begin_time = current_time_ns;
+            f2fs_gc_metrics[i][gc_t].cnt = 0;
+            f2fs_gc_metrics[i][gc_t].avg_time = 0;
+            f2fs_gc_metrics[i][gc_t].segs = 0;
+            f2fs_gc_metrics[i][gc_t].avg_segs = 0;
+            f2fs_gc_metrics[i][gc_t].efficiency = 0;
+            elapse = 0;
+        } else {
+            f2fs_gc_metrics[i][gc_t].begin_time = current_time_ns;
+        }
+        if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+            atomic64_set(&f2fs_metrics_timestamp[i], 0);
+        }
+    }
+    if (unlikely(io_metrics_debug_enabled || f2fs_gc_begin_enabled)) {
+        io_metrics_print("current_time_ns:%llu\n", current_time_ns);
+    }
+};
+
+static void cb_f2fs_gc_end(void *ignore, struct super_block *sb, int ret,
+            int seg_freed, int sec_freed, long long dirty_nodes,
+            long long dirty_dents, long long dirty_imeta,
+            unsigned int free_sec, unsigned int free_seg,
+            int reserved_seg, unsigned int prefree_seg)
+{
+    int i;
+    u64 current_time_ns, gc_elapse = 0;
+
+    if (unlikely(!io_metrics_enabled)) {
+        return;
+    }
+    if (unlikely(!(sb->s_flags & SB_ACTIVE))) {
+        return;
+    }
+    if (gc_t > GC_FG) {
+        if (unlikely(io_metrics_debug_enabled)) {
+            io_metrics_print("gc_t(%d) is not a expected value\n", gc_t);
+        }
+        return;
+    }
+    current_time_ns = ktime_get_ns();
+    for (i = 0; i < CYCLE_MAX; i++) {
+        /* 考虑到gc开始会后有外界复位操作，导致数据错乱 */
+        if (likely(f2fs_gc_metrics[i][gc_t].begin_time)) {
+            gc_elapse = current_time_ns - f2fs_gc_metrics[i][gc_t].begin_time;
+            f2fs_gc_metrics[i][gc_t].elapse_time += gc_elapse;
+            f2fs_gc_metrics[i][gc_t].cnt += 1;
+            f2fs_gc_metrics[i][gc_t].segs += free_seg;/* todo */
+            f2fs_gc_metrics[i][gc_t].avg_time = f2fs_gc_metrics[i][gc_t].elapse_time /
+                                               f2fs_gc_metrics[i][gc_t].cnt;
+            /* todo */
+            f2fs_gc_metrics[i][gc_t].avg_segs = f2fs_gc_metrics[i][gc_t].segs /
+                                               f2fs_gc_metrics[i][gc_t].cnt;
+            f2fs_gc_metrics[i][gc_t].begin_time = 0;
+        }
+    }
+    if (unlikely(io_metrics_debug_enabled || f2fs_gc_end_enabled)) {
+        const char *gc_type[] = {"Background", "Foreground"};
+        io_metrics_print("%s gc elapse:%llu  count:%llu\n", gc_type[gc_t], gc_elapse,
+                                                f2fs_gc_metrics[CYCLE_MAX-1][gc_t].cnt);
+    }
+};
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 15, 0)
+static void cb_f2fs_write_checkpoint(void *ignore, struct super_block *sb,
+                                                    int reason, char *msg)
+#else
+static void cb_f2fs_write_checkpoint(void *ignore, struct super_block *sb,
+                                               int reason, const char *msg)
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(5, 15, 0) */
+{
+    int i;
+    u64 current_time_ns, elapse, cp_elapse = 0;
+#ifdef CONFIG_F2FS_STAT_FS
+    struct f2fs_sb_info *sbi = F2FS_SB(sb);
+#endif
+
+    if (unlikely(!io_metrics_enabled)) {
+        return;
+    }
+    current_time_ns = ktime_get_ns();
+    if (!strcmp(msg, "start block_ops")) {
+        for (i = 0; i < CYCLE_MAX; i++) {
+            elapse = current_time_ns - atomic64_read(&f2fs_metrics_timestamp[i]);
+            if (unlikely(elapse >= current_time_ns)) {
+                atomic64_set(&f2fs_metrics_timestamp[i], current_time_ns);
+                f2fs_cp_metrics[i].begin_time = current_time_ns;
+                f2fs_cp_metrics[i].cnt = 0;
+                f2fs_cp_metrics[i].elapse_time = 0;
+                f2fs_cp_metrics[i].avg_time = 0;
+                f2fs_cp_metrics[i].max_time = 0;
+                elapse = 0;
+            } else {
+                f2fs_cp_metrics[i].begin_time = current_time_ns;
+            }
+#ifdef CONFIG_F2FS_STAT_FS
+            f2fs_cp_metrics[i].inplace_count = atomic_read(&sbi->inplace_count);
+#endif
+            if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+                atomic64_set(&f2fs_metrics_timestamp[i], 0);
+            }
+        }
+        if (unlikely(io_metrics_debug_enabled || f2fs_write_checkpoint_enabled)) {
+            io_metrics_print("current_time_ns:%llu\n", current_time_ns);
+        }
+    } else if (!strcmp(msg, "finish checkpoint")) {
+        for (i = 0; i < CYCLE_MAX; i++) {
+            /* 考虑到cp开始会后有外界复位操作，导致数据错乱 */
+            if (likely(f2fs_cp_metrics[i].begin_time)) {
+                cp_elapse = current_time_ns - f2fs_cp_metrics[i].begin_time;
+                f2fs_cp_metrics[i].elapse_time += cp_elapse;
+                f2fs_cp_metrics[i].cnt += 1;
+                f2fs_cp_metrics[i].avg_time = f2fs_cp_metrics[i].elapse_time /
+                                              f2fs_cp_metrics[i].cnt;
+                f2fs_cp_metrics[i].max_time = f2fs_cp_metrics[i].max_time >= cp_elapse ?
+                                              f2fs_cp_metrics[i].max_time : cp_elapse;
+                f2fs_cp_metrics[i].begin_time = 0;
+            }
+        }
+        if (unlikely(io_metrics_debug_enabled || f2fs_write_checkpoint_enabled)) {
+            io_metrics_print("checkpoint elapse:%llu  count:%llu\n", cp_elapse,
+                                            f2fs_cp_metrics[CYCLE_MAX-1].cnt);
+        }
+    }
+};
+
+static void cb_f2fs_sync_file_enter(void *ignore, struct inode *inode)
+{
+    int i;
+    u64 current_time_ns, elapse;
+
+    if (unlikely(!io_metrics_enabled)) {
+        return;
+    }
+    current_time_ns = ktime_get_ns();
+    for (i = 0; i < CYCLE_MAX; i++) {
+        elapse = current_time_ns - atomic64_read(&f2fs_metrics_timestamp[i]);
+        if (unlikely(elapse >= current_time_ns)) {
+            atomic64_set(&f2fs_metrics_timestamp[i], current_time_ns);
+            f2fs_metrics[i].fsync_cnt = 1;
+            elapse = 0;
+        } else {
+            f2fs_metrics[i].fsync_cnt += 1;
+        }
+        if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+            atomic64_set(&f2fs_metrics_timestamp[i], 0);
+        }
+    }
+    if (unlikely(io_metrics_debug_enabled || f2fs_sync_file_enter_enabled)) {
+        io_metrics_print("current_time_ns:%llu count:%llu\n", current_time_ns,
+                                       f2fs_metrics[CYCLE_MAX-1].fsync_cnt);
+    }
+};
+
+static void cb_f2fs_sync_file_exit(void *ignore, struct inode *inode,
+                                   int cp_reason, int datasync, int ret)
+{
+    if (unlikely(!io_metrics_enabled)) {
+        return;
+    }
+    if (unlikely(io_metrics_debug_enabled || f2fs_sync_file_exit_enabled)) {
+        io_metrics_print("here\n");
+    }
+};
+
+void f2fs_register_tracepoint_probes(void)
+{
+    int ret;
+    ret = register_trace_f2fs_issue_discard(cb_f2fs_issue_discard, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_gc_begin(cb_f2fs_gc_begin, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_gc_end(cb_f2fs_gc_end, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_write_checkpoint(cb_f2fs_write_checkpoint, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_sync_file_enter(cb_f2fs_sync_file_enter, NULL);
+    WARN_ON(ret);
+    ret = register_trace_f2fs_sync_file_exit(cb_f2fs_sync_file_exit, NULL);
+    WARN_ON(ret);
+}
+
+void f2fs_unregister_tracepoint_probes(void)
+{
+    unregister_trace_f2fs_issue_discard(cb_f2fs_issue_discard, NULL);
+    unregister_trace_f2fs_gc_begin(cb_f2fs_gc_begin, NULL);
+    unregister_trace_f2fs_gc_end(cb_f2fs_gc_end, NULL);
+    unregister_trace_f2fs_write_checkpoint(cb_f2fs_write_checkpoint, NULL);
+    unregister_trace_f2fs_sync_file_enter(cb_f2fs_sync_file_enter, NULL);
+    unregister_trace_f2fs_sync_file_exit(cb_f2fs_sync_file_exit, NULL);
+}
+
+static int f2fs_metrics_proc_show(struct seq_file *seq_filp, void *data)
+{
+    int i = 0;
+    u64 value = 123;
+    struct file *file = (struct file *)seq_filp->private;
+    enum sample_cycle_type cycle;
+
+    if (unlikely(!io_metrics_enabled)) {
+        seq_printf(seq_filp, "io_metrics_enabled not set to 1:%d\n", io_metrics_enabled);
+        return 0;
+    }
+
+    if (proc_show_enabled || unlikely(io_metrics_debug_enabled)) {
+        io_metrics_print("%s(%d) read %s/%s\n",
+            current->comm, current->pid, file->f_path.dentry->d_parent->d_iname,
+            file->f_path.dentry->d_iname);
+    }
+    /* 确定采样周期的值（父目录） */
+    cycle = CYCLE_MAX;
+    for (i = 0; i < CYCLE_MAX; i++) {
+        if(!strcmp(file->f_path.dentry->d_parent->d_iname, sample_cycle_config[i].tag)) {
+            cycle = sample_cycle_config[i].value;
+        }
+    }
+    if (unlikely(cycle == CYCLE_MAX)) {
+        goto err;
+    }
+    if(!strcmp(file->f_path.dentry->d_iname, "f2fs_discard_cnt")) {
+        value = f2fs_metrics[cycle].discard_cnt;
+    } else if(!strcmp(file->f_path.dentry->d_iname, "f2fs_discard_len")) {
+        value = f2fs_metrics[cycle].discard_len;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_fg_gc_cnt")) {
+        value = f2fs_gc_metrics[cycle][GC_FG].cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_fg_gc_avg_time")) {
+        value = f2fs_gc_metrics[cycle][GC_FG].avg_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_fg_gc_seg_cnt")) {
+        value = f2fs_gc_metrics[cycle][GC_FG].segs;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_bg_gc_cnt")) {
+        value = f2fs_gc_metrics[cycle][GC_BG].cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_bg_gc_avg_time")) {
+        value = f2fs_gc_metrics[cycle][GC_BG].avg_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_bg_gc_seg_cnt")) {
+        value = f2fs_gc_metrics[cycle][GC_BG].segs;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_cp_cnt")) {
+        value = f2fs_cp_metrics[cycle].cnt;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_cp_avg_time")) {
+        value = f2fs_cp_metrics[cycle].avg_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_cp_max_time")) {
+        value = f2fs_cp_metrics[cycle].max_time;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_ipu_cnt")) {
+        value = f2fs_cp_metrics[cycle].inplace_count;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "f2fs_fsync_cnt")) {
+        value = f2fs_metrics[cycle].fsync_cnt;
+    }
+    seq_printf(seq_filp, "%llu\n", value);
+
+    return 0;
+
+err:
+    io_metrics_print("%s(%d) I don't understand what the operation: %s/%s\n",
+                                                      current->comm,current->pid,
+             file->f_path.dentry->d_parent->d_iname, file->f_path.dentry->d_iname);
+    return -1;
+}
+
+int f2fs_metrics_proc_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, f2fs_metrics_proc_show, file);
+}
+
+void f2fs_metrics_reset(void)
+{
+    int i = 0;
+    for (i = 0; i < CYCLE_MAX; i++) {
+        atomic64_set(&f2fs_metrics_timestamp[i], 0);
+    }
+    memset(&f2fs_gc_metrics, 0, sizeof(f2fs_gc_metrics));
+    memset(&f2fs_cp_metrics, 0, sizeof(f2fs_cp_metrics));
+    memset(&f2fs_metrics, 0, sizeof(f2fs_metrics));
+}
+void f2fs_metrics_init(void)
+{
+    f2fs_metrics_reset();
+    gc_t = 0;
+}
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.h b/drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.h
new file mode 100644
index 000000000..050f05e95
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/f2fs_metrics.h
@@ -0,0 +1,12 @@
+#ifndef __F2FS_METRICS_H__
+#define __F2FS_METRICS_H__
+#include <linux/fs.h>
+#include <linux/f2fs_fs.h>
+
+void f2fs_register_tracepoint_probes(void);
+void f2fs_unregister_tracepoint_probes(void);
+int f2fs_metrics_proc_open(struct inode *inode, struct file *file);
+void f2fs_metrics_reset(void);
+void f2fs_metrics_init(void);
+
+#endif /* __F2FS_METRICS_H__ */
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.c b/drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.c
new file mode 100644
index 000000000..f6e4b7d4a
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.c
@@ -0,0 +1,73 @@
+#include "io_metrics_entry.h"
+#include <trace/events/block.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#include "f2fs_metrics.h"
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#include "block_metrics.h"
+#include "ufs_metrics.h"
+#include "procfs.h"
+#include "abnormal_io.h"
+
+bool io_metrics_enabled = false;
+bool io_metrics_debug_enabled = false;
+
+static void io_metrics_register_tracepoints(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    /* filesystem layer */
+    f2fs_register_tracepoint_probes();
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    /* block layer */
+    block_register_tracepoint_probes();
+    /* ufs layer */
+    ufs_register_tracepoint_probes();
+}
+
+static void io_metrics_unregister_tracepoints(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    /* filesystem layer */
+    f2fs_unregister_tracepoint_probes();
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    /* block layer */
+    block_unregister_tracepoint_probes();
+    /* ufs layer */
+    ufs_unregister_tracepoint_probes();
+    tracepoint_synchronize_unregister();
+
+    return;
+}
+
+static int __init io_metrics_init(void)
+{
+    io_metrics_print("Startting...\n");
+    io_metrics_enabled = false;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    f2fs_metrics_init();
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    block_metrics_init();
+    ufs_metrics_reset();
+    io_metrics_register_tracepoints();
+    if (io_metrics_procfs_init())
+    {
+        io_metrics_print("io_metrics_procfs_init failed\n");
+    }
+    io_metrics_enabled = true;
+    io_metrics_print("Start OK\n");
+    return 0;
+}
+
+static void __exit io_metrics_exit(void)
+{
+    io_metrics_enabled = false;
+    io_metrics_print("io_metrics_exit\n");
+    io_metrics_unregister_tracepoints();
+    io_metrics_procfs_exit();
+}
+
+module_init(io_metrics_init);
+module_exit(io_metrics_exit);
+
+MODULE_DESCRIPTION("oplus_bsp_storage_io_metrics");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.h b/drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.h
new file mode 100644
index 000000000..73c68aecf
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/io_metrics_entry.h
@@ -0,0 +1,94 @@
+#ifndef __IO_METRICS_ENTRY_H__
+#define __IO_METRICS_ENTRY_H__
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/blkdev.h>
+#include <linux/percpu.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/export.h>
+#include <linux/time.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/task_io_accounting_ops.h>
+#include <linux/trace_clock.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/namei.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/tracepoint.h>
+#include <linux/fs.h>
+#include <linux/bio.h>
+#include <linux/printk.h>
+
+#define io_metrics_print(fmt, arg...) \
+    printk("[IO_METRICS] [%-16s] %20s:%-4d "fmt, current->comm, __func__, __LINE__, ##arg)
+
+/* 统计周期 */
+enum sample_cycle_type {
+//    CYCLE_SECOND_10 = 0,
+//    CYCLE_MINUTES_1,
+//    CYCLE_MINUTES_10,
+//    CYCLE_HOUR_1,
+//    CYCLE_DAY_1,
+//    CYCLE_WEEK_1,
+    /* 记录总的流量 */
+    CYCLE_FOREVER = 0,
+    CYCLE_MAX
+};
+
+#define LAT_0_TO_100U_MASK      100000
+#define LAT_100U_TO_200U_MASK   200000
+#define LAT_200U_TO_500U_MASK   500000
+#define LAT_500U_TO_2M_MASK     2000000
+#define LAT_2M_TO_20M_MASK      20000000
+#define LAT_20M_TO_100M_MASK    100000000
+#define LAT_100M_TO_500M_MASK   500000000
+
+/* 延迟分布 */
+enum lat_range {
+    LAT_0_TO_100U = 0,   /* (0, 100us]      */
+    LAT_100U_TO_200U,    /* (100us, 200us]  */
+    LAT_200U_TO_500U,    /* (200us, 500us]  */
+    LAT_500U_TO_2M,      /* (500us, 2ms)    */
+    LAT_2M_TO_20M,       /* [2ms, 20ms)     */
+    LAT_20M_TO_100M,     /* [20ms, 200ms)   */
+    LAT_100M_TO_500M,    /* [100ms, 500ms)  */
+    LAT_500M_TO_MAX,     /* [500ms, +∞)     */
+};
+
+#define lat_range_check(elapsed, lat_range) \
+do { \
+    if (likely(elapsed <= LAT_0_TO_100U_MASK)) {   \
+        lat_range = LAT_0_TO_100U;         \
+    } else if (elapsed <= LAT_100U_TO_200U_MASK) { \
+        lat_range = LAT_100U_TO_200U;      \
+    } else if (elapsed <= LAT_200U_TO_500U_MASK) { \
+        lat_range = LAT_200U_TO_500U;      \
+    } else if (elapsed <= LAT_500U_TO_2M_MASK) {   \
+        lat_range = LAT_500U_TO_2M;        \
+    } else if (elapsed <= LAT_2M_TO_20M_MASK) {    \
+        lat_range = LAT_2M_TO_20M;         \
+    } else if (elapsed <= LAT_20M_TO_100M_MASK) {  \
+        lat_range = LAT_20M_TO_100M;       \
+    } else if (elapsed <= LAT_100M_TO_500M_MASK) { \
+        lat_range = LAT_100M_TO_500M;      \
+    }  else {                                        \
+        lat_range = LAT_500M_TO_MAX;       \
+    }                                                \
+} while (0)
+
+
+struct sample_cycle {
+    enum sample_cycle_type value;
+    const char * tag;
+    const u64 cycle_value;
+};
+
+extern bool io_metrics_enabled;
+extern bool io_metrics_debug_enabled;
+
+#endif /* __IO_METRICS_ENTRY_H__ */
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/common/io_metrics/procfs.c b/drivers/soc/oplus/storage/common/io_metrics/procfs.c
new file mode 100644
index 000000000..c5caefbb9
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/procfs.c
@@ -0,0 +1,492 @@
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+#include <linux/dcache.h>
+
+#include "procfs.h"
+#include "block_metrics.h"
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#include "f2fs_metrics.h"
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+#include "ufs_metrics.h"
+#include "abnormal_io.h"
+
+#define STORAGE_DIR_NODE "oplus_storage"
+#define IO_METRICS_DIR_NODE "io_metrics"
+#define IO_METRICS_CONTROL_DIR_NODE "control"
+#define DUMP_PATH_LEN 1024
+static char abnormal_io_dump_path[DUMP_PATH_LEN];
+bool proc_show_enabled = true;
+module_param(proc_show_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(proc_show_enabled, " Debug proc");
+
+#define LABEL_BUF_LEN 50
+static char label_buf[LABEL_BUF_LEN] = {"common"};
+static struct proc_dir_entry *storage_procfs;
+static struct proc_dir_entry *io_metrics_procfs;
+static struct proc_dir_entry *io_metrics_control_procfs;
+static struct proc_dir_entry *sample_dir[CYCLE_MAX] = {0};
+
+struct sample_cycle sample_cycle_config[] = {
+//    { CYCLE_SECOND_10,  "second_10", 10000000000        }, /* 10秒均值 */
+//    { CYCLE_MINUTES_1,  "minutes_1", 60000000000        }, /* 1分钟均值 */
+//    {CYCLE_MINUTES_10, "minutes_10", 600000000000       }, /* 10分钟均值 */
+//    {    CYCLE_HOUR_1,       "hour", 3600000000000      }, /* 1小时均值 */
+//    {     CYCLE_DAY_1,        "day", 86400000000000     }, /* 1天均值 */
+//    {    CYCLE_WEEK_1,       "week", 604800000000000    }, /* 1周均值 */
+    {   CYCLE_FOREVER,    "forever", 3153600000000000000}, /* 总流量 */
+};
+
+#define CREATE_IO_METRICS_CONTROL_NODE(__name, __parent)            \
+    proc_create(#__name, S_IRUGO | S_IWUGO, __parent, &__name ## _proc_ops)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+#define DEFINE_IO_METRICS_CONTROL(__name)                           \
+static int __name ## _open(struct inode *inode, struct file *file)  \
+{                                                                   \
+    return single_open(file, __name ## _show, file);     \
+}                                                                   \
+                                                                    \
+static const struct proc_ops __name ## _proc_ops = {                \
+    .proc_open  = __name ## _open,                                  \
+    .proc_read  = seq_read,                                         \
+    .proc_write = __name ## _write,                                 \
+    .proc_lseek = seq_lseek,                                        \
+    .proc_release   = single_release,                               \
+}
+
+static const struct proc_ops block_metrics_proc_fops = {
+    .proc_open      = block_metrics_proc_open,
+    .proc_read      = seq_read,
+    .proc_lseek     = seq_lseek,
+    .proc_release   = single_release,
+};
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+static const struct proc_ops f2fs_metrics_proc_fops = {
+    .proc_open      = f2fs_metrics_proc_open,
+    .proc_read      = seq_read,
+    .proc_lseek     = seq_lseek,
+    .proc_release   = single_release,
+};
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+static const struct proc_ops ufs_metrics_proc_fops = {
+    .proc_open      = ufs_metrics_proc_open,
+    .proc_read      = seq_read,
+    .proc_lseek     = seq_lseek,
+    .proc_release   = single_release,
+};
+#else
+#define DEFINE_IO_METRICS_CONTROL(__name)                           \
+static int __name ## _open(struct inode *inode, struct file *file)  \
+{                                                                   \
+    return single_open(file, __name ## _show, file);     \
+}                                                                   \
+                                                                    \
+static const struct file_operations __name ## _proc_ops = {         \
+    .open   = __name ## _open,                                      \
+    .read   = seq_read,                                             \
+    .write  = __name ## _write,                                     \
+    .llseek = seq_lseek,                                            \
+    .release    = single_release,                                   \
+}
+
+static const struct file_operations block_metrics_proc_fops = {
+    .open      = block_metrics_proc_open,
+    .read      = seq_read,
+    .llseek     = seq_lseek,
+    .release   = single_release,
+};
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+static const struct file_operations f2fs_metrics_proc_fops = {
+    .open      = f2fs_metrics_proc_open,
+    .read      = seq_read,
+    .llseek     = seq_lseek,
+    .release   = single_release,
+};
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+static const struct file_operations ufs_metrics_proc_fops = {
+    .open      = ufs_metrics_proc_open,
+    .read      = seq_read,
+    .llseek     = seq_lseek,
+    .release   = single_release,
+};
+#endif
+
+static int io_metrics_control_show(struct seq_file *seq_filp, void *data)
+{
+    struct file *file = (struct file *)seq_filp->private;
+
+    if (proc_show_enabled || unlikely(io_metrics_debug_enabled)) {
+        io_metrics_print("%s(%d) read %s/%s\n",
+            current->comm, current->pid, file->f_path.dentry->d_parent->d_iname,
+            file->f_path.dentry->d_iname);
+    }
+
+    if (!strcmp(file->f_path.dentry->d_iname, "enable")) {
+       seq_printf(seq_filp, "%d\n", io_metrics_enabled);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "debug_enable")) {
+        seq_printf(seq_filp, "%d\n", io_metrics_debug_enabled);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_enabled")) {
+        seq_printf(seq_filp, "%d\n", atomic_read(&abnormal_io_enabled));
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_trigger")) {
+        seq_printf(seq_filp, "%d\n", abnormal_io_trigger);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_dump_min_interval_s")) {
+        seq_printf(seq_filp, "%d\n", abnormal_io_dump_min_interval_s);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_dump_limit_1_day")) {
+        seq_printf(seq_filp, "%d\n", abnormal_io_dump_limit_1_day);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_dump_path")) {
+        abnormal_io_dump_path[DUMP_PATH_LEN - 1] = '\0';
+        seq_printf(seq_filp, "%s\n", abnormal_io_dump_path);
+    }
+
+    return 0;
+}
+
+static ssize_t io_metrics_control_write(struct file *file,
+                       const char __user *buf, size_t len, loff_t *ppos)
+{
+    enum  {
+        INT_VALUE = 0,
+        BOOL_VALUE,
+        STR_VALUE
+    } val_t = INT_VALUE;
+#define DATA_LEN    DUMP_PATH_LEN
+    char buffer[DATA_LEN+1] = {0};
+    int ret = 0;
+    int value = 0;
+
+    len = (len > DATA_LEN) ? DATA_LEN : len;
+    //kstrtoint_from_user
+    if (copy_from_user(buffer, buf, len)) {
+        return -EFAULT;
+    }
+    buffer[len] = '\0';
+
+    if (!strcmp(file->f_path.dentry->d_iname, "enable")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+        WRITE_ONCE(io_metrics_enabled, value);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "debug_enable")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+        WRITE_ONCE(io_metrics_debug_enabled, value);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "reset_stat")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+        if (value == 1) {
+            io_metrics_print("reset_stat start\n");
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+            f2fs_metrics_reset();
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+            block_metrics_reset();
+            ufs_metrics_reset();
+            strcpy(label_buf, "common");
+        }
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_enabled")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+        if (0 == value) {
+            abnormal_io_exit();
+        } else if (1 == value) {
+            abnormal_io_init();
+        }
+#else
+        io_metrics_print("kernel-6.6 do not support abnormal io\n");
+#endif
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_trigger")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+        if (value == 1) {
+            ret = abnormal_io_dump_to_file("/data/persist_log/DCS/de/storage/storage_io.hex");
+            if (!ret) {
+                io_metrics_print("abnormal_io_dump_to_file err(%d)\n", ret);
+            }
+        }
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_dump_min_interval_s")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+        WRITE_ONCE(abnormal_io_dump_min_interval_s, value);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_dump_limit_1_day")) {
+        ret = kstrtoint(strstrip(buffer), len, &value);
+        if (ret) {
+            return ret;
+        }
+        val_t = INT_VALUE;
+        WRITE_ONCE(abnormal_io_dump_limit_1_day, value);
+    } else if (!strcmp(file->f_path.dentry->d_iname, "abnormal_io_dump_path")) {
+        val_t = STR_VALUE;
+        if (strncpy(abnormal_io_dump_path, strstrip(buffer), len)) {
+            if (strcat(abnormal_io_dump_path, "/storage_io.hex")) {
+                ret = abnormal_io_dump_to_file((const char *)abnormal_io_dump_path);
+                if (!ret) {
+                    io_metrics_print("abnormal_io_dump_to_file err(%d)\n", ret);
+                }
+            }
+        }
+    }
+    /* update log */
+    if (val_t == INT_VALUE) {
+        io_metrics_print("%s(%d) write %d to %s/%s\n", current->comm, current->pid, value,
+                     file->f_path.dentry->d_parent->d_iname, file->f_path.dentry->d_iname);
+    } else if (val_t == STR_VALUE) {
+        io_metrics_print("%s(%d) write %s to %s/%s\n", current->comm, current->pid, buffer,
+                     file->f_path.dentry->d_parent->d_iname, file->f_path.dentry->d_iname);
+    }
+    *ppos += len;
+
+    return len;
+}
+
+int io_metrics_control_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, io_metrics_control_show, file);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+static const struct proc_ops io_metrics_control_proc_fops = {
+    .proc_open      = io_metrics_control_open,
+    .proc_read      = seq_read,
+    .proc_write     = io_metrics_control_write,
+    .proc_lseek     = seq_lseek,
+    .proc_release   = single_release,
+};
+#else
+static const struct file_operations io_metrics_control_proc_fops = {
+    .open      = io_metrics_control_open,
+    .read      = seq_read,
+    .write     = io_metrics_control_write,
+    .llseek     = seq_lseek,
+    .release   = single_release,
+};
+#endif
+
+enum node_type {
+    F2FS = 0,
+    BLOCK,
+    UFS,
+    CONTROL,
+};
+
+struct {
+    const char *name;
+    enum node_type node_type;
+    umode_t mode;
+} io_metrics_procfs_node[] = {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    /* filesystem layer */
+    {"f2fs_discard_cnt",             F2FS, S_IRUGO},
+    {"f2fs_discard_len",             F2FS, S_IRUGO},
+    {"f2fs_fg_gc_cnt",               F2FS, S_IRUGO},
+    {"f2fs_fg_gc_avg_time",          F2FS, S_IRUGO},
+    {"f2fs_fg_gc_seg_cnt",           F2FS, S_IRUGO},
+    {"f2fs_bg_gc_cnt",               F2FS, S_IRUGO},
+    {"f2fs_bg_gc_avg_time",          F2FS, S_IRUGO},
+    {"f2fs_bg_gc_seg_cnt",           F2FS, S_IRUGO},
+    {"f2fs_cp_cnt",                  F2FS, S_IRUGO},
+    {"f2fs_cp_avg_time",             F2FS, S_IRUGO},
+    {"f2fs_cp_max_time",             F2FS, S_IRUGO},
+    {"f2fs_ipu_cnt",                 F2FS, S_IRUGO},
+    {"f2fs_fsync_cnt",                F2FS, S_IRUGO},
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+    /* block layer */
+    {"bio_read_cnt",                BLOCK, S_IRUGO},
+    {"bio_read_avg_size",           BLOCK, S_IRUGO},
+    {"bio_read_size_dist",          BLOCK, S_IRUGO},
+    {"bio_read_avg_time",           BLOCK, S_IRUGO},
+    {"bio_read_max_time",           BLOCK, S_IRUGO},
+    {"bio_read_4k_blk_avg_time",    BLOCK, S_IRUGO},
+    {"bio_read_4k_blk_max_time",    BLOCK, S_IRUGO},
+    {"bio_read_4k_blk_lat_dist",    BLOCK, S_IRUGO},
+    {"bio_read_4k_drv_avg_time",    BLOCK, S_IRUGO},
+    {"bio_read_4k_drv_max_time",    BLOCK, S_IRUGO},
+    {"bio_read_4k_drv_lat_dist",    BLOCK, S_IRUGO},
+    {"bio_read_512k_blk_avg_time",  BLOCK, S_IRUGO},
+    {"bio_read_512k_blk_max_time",  BLOCK, S_IRUGO},
+    {"bio_read_512k_blk_lat_dist",  BLOCK, S_IRUGO},
+    {"bio_read_512k_drv_avg_time",  BLOCK, S_IRUGO},
+    {"bio_read_512k_drv_max_time",  BLOCK, S_IRUGO},
+    {"bio_read_512k_drv_lat_dist",  BLOCK, S_IRUGO},
+    {"bio_write_cnt",               BLOCK, S_IRUGO},
+    {"bio_write_avg_size",          BLOCK, S_IRUGO},
+    {"bio_write_size_dist",         BLOCK, S_IRUGO},
+    {"bio_write_avg_time",          BLOCK, S_IRUGO},
+    {"bio_write_max_time",          BLOCK, S_IRUGO},
+    {"bio_write_4k_blk_avg_time",   BLOCK, S_IRUGO},
+    {"bio_write_4k_blk_max_time",   BLOCK, S_IRUGO},
+    {"bio_write_4k_blk_lat_dist",   BLOCK, S_IRUGO},
+    {"bio_write_4k_drv_avg_time",   BLOCK, S_IRUGO},
+    {"bio_write_4k_drv_max_time",   BLOCK, S_IRUGO},
+    {"bio_write_4k_drv_lat_dist",   BLOCK, S_IRUGO},
+    {"bio_write_512k_blk_avg_time", BLOCK, S_IRUGO},
+    {"bio_write_512k_blk_max_time", BLOCK, S_IRUGO},
+    {"bio_write_512k_blk_lat_dist", BLOCK, S_IRUGO},
+    {"bio_write_512k_drv_avg_time", BLOCK, S_IRUGO},
+    {"bio_write_512k_drv_max_time", BLOCK, S_IRUGO},
+    {"bio_write_512k_drv_lat_dist", BLOCK, S_IRUGO},
+    /* ufs layer */
+    {"ufs_total_read_size_mb",        UFS, S_IRUGO},
+    {"ufs_total_read_time_ms",        UFS, S_IRUGO},
+    {"ufs_total_write_size_mb",       UFS, S_IRUGO},
+    {"ufs_total_write_time_ms",       UFS, S_IRUGO},
+    {"ufs_read_lat_dist",             UFS, S_IRUGO},
+    {"ufs_write_lat_dist",            UFS, S_IRUGO},
+    /* control */
+    {"enable",                    CONTROL, S_IRUGO | S_IWUGO},
+    {"debug_enable",              CONTROL, S_IRUGO | S_IWUGO},
+    {"reset_stat",                CONTROL, S_IRUGO | S_IWUGO},
+    {"abnormal_io_enabled",       CONTROL, S_IRUGO | S_IWUGO},
+    {"abnormal_io_trigger",       CONTROL, S_IRUGO | S_IWUGO},
+    {"abnormal_io_dump_min_interval_s", CONTROL, S_IRUGO | S_IWUGO},
+    {"abnormal_io_dump_limit_1_day",        CONTROL, S_IRUGO | S_IWUGO},
+    {"abnormal_io_dump_path",               CONTROL, S_IRUGO | S_IWUGO},
+    {NULL,                               0,                 0}
+};
+
+static int label_show(struct seq_file *seq_filp, void *data)
+{
+    struct file *file = (struct file *)seq_filp->private;
+    seq_printf(seq_filp, "%s\n", label_buf);
+    if (proc_show_enabled) {
+        io_metrics_print("%s(%d) read %s/%s: %s\n",
+            current->comm, current->pid, file->f_path.dentry->d_parent->d_iname,
+            file->f_path.dentry->d_iname, label_buf);
+    }
+
+    return 0;
+}
+
+static ssize_t label_write(struct file *file,
+                       const char __user *buf, size_t len, loff_t *ppos)
+{
+    len = len < (LABEL_BUF_LEN - 1) ? len : (LABEL_BUF_LEN - 1);
+    if (copy_from_user(label_buf, buf, len)) {
+        return -EFAULT;
+    }
+    label_buf[LABEL_BUF_LEN - 1] = '\0';
+    *ppos += len;
+    io_metrics_print("%s(%d) write %s to %s/%s\n", current->comm, current->pid, label_buf,
+                     file->f_path.dentry->d_parent->d_iname, file->f_path.dentry->d_iname);
+
+    return len;
+}
+DEFINE_IO_METRICS_CONTROL(label);
+
+int io_metrics_procfs_init(void)
+{
+    int i = 0;
+    int j = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+    struct proc_ops *proc_ops = NULL;
+#else
+    struct file_operations *proc_ops = NULL;
+#endif
+
+    struct proc_dir_entry *pnode;
+    /* /proc/oplus_storage */
+    storage_procfs = proc_mkdir(STORAGE_DIR_NODE, NULL);
+    if (!storage_procfs) {
+        io_metrics_print("Can't create procfs node\n");
+        goto error_out;
+    }
+    /* /proc/oplus_storage/io_metrics */
+    io_metrics_procfs = proc_mkdir(IO_METRICS_DIR_NODE, storage_procfs);
+    if (!io_metrics_procfs) {
+        io_metrics_print("Can't create procfs node\n");
+        goto error_out;
+    }
+    /* /proc/oplus_storage/io_metrics/control */
+    io_metrics_control_procfs = proc_mkdir(IO_METRICS_CONTROL_DIR_NODE, io_metrics_procfs);
+    if (!io_metrics_control_procfs) {
+        io_metrics_print("Can't create procfs node\n");
+        goto error_out;
+    }
+    /* 在/proc/oplus_storage/io_metrics下面创建按照周期统计的目录 */
+    for (i = 0; i < CYCLE_MAX; i++) {
+        sample_dir[i] = proc_mkdir(sample_cycle_config[i].tag, io_metrics_procfs);
+        if (!sample_dir[i]) {
+            io_metrics_print("Can't create procfs node\n");
+            goto error_out;
+        }
+    }
+    for (i = 0; io_metrics_procfs_node[i].name; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+        if (io_metrics_procfs_node[i].node_type == BLOCK) {
+            proc_ops = (struct proc_ops *)&block_metrics_proc_fops;
+        }
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+		else if (io_metrics_procfs_node[i].node_type == F2FS) {
+            proc_ops = (struct proc_ops *)&f2fs_metrics_proc_fops;
+        }
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+		else if (io_metrics_procfs_node[i].node_type == UFS) {
+            proc_ops = (struct proc_ops *)&ufs_metrics_proc_fops;
+        }
+#else
+        if (io_metrics_procfs_node[i].node_type == F2FS) {
+            proc_ops = (struct file_operations *)&f2fs_metrics_proc_fops;
+        } else if (io_metrics_procfs_node[i].node_type == BLOCK) {
+            proc_ops = (struct file_operations *)&block_metrics_proc_fops;
+        } else if (io_metrics_procfs_node[i].node_type == UFS) {
+            proc_ops = (struct file_operations *)&ufs_metrics_proc_fops;
+        }
+#endif
+        if (io_metrics_procfs_node[i].node_type == CONTROL) {
+            pnode = proc_create(io_metrics_procfs_node[i].name,
+                                io_metrics_procfs_node[i].mode,
+                                io_metrics_control_procfs,
+                                &io_metrics_control_proc_fops);
+            if (!pnode) {
+                io_metrics_print("Can't create %s\n", io_metrics_procfs_node[i].name);
+                goto error_out;
+            }
+        } else {
+            for (j = 0; j < CYCLE_MAX; j++) {
+                pnode = proc_create(io_metrics_procfs_node[i].name,
+                                    io_metrics_procfs_node[i].mode,
+                                    sample_dir[j],
+                                    proc_ops);
+                if (!pnode) {
+                    io_metrics_print("Can't create %s\n", io_metrics_procfs_node[i].name);
+                    goto error_out;
+                }
+            }
+        }
+    }
+    CREATE_IO_METRICS_CONTROL_NODE(label, io_metrics_control_procfs);
+
+    return 0;
+
+error_out:
+    return -1;
+}
+void io_metrics_procfs_exit(void)
+{
+    if (storage_procfs) {
+        if (io_metrics_procfs) {
+            remove_proc_entry(IO_METRICS_DIR_NODE, storage_procfs);
+        }
+        remove_proc_entry(STORAGE_DIR_NODE, NULL);
+    }
+}
diff --git a/drivers/soc/oplus/storage/common/io_metrics/procfs.h b/drivers/soc/oplus/storage/common/io_metrics/procfs.h
new file mode 100644
index 000000000..76035d1e1
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/procfs.h
@@ -0,0 +1,10 @@
+#ifndef __PROFS_H__
+#define __PROFS_H__
+#include "io_metrics_entry.h"
+
+extern bool proc_show_enabled;
+extern struct sample_cycle sample_cycle_config[CYCLE_MAX];
+int io_metrics_procfs_init(void);
+void io_metrics_procfs_exit(void);
+
+#endif /* __PROFS_H__ */
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.c b/drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.c
new file mode 100644
index 000000000..c911c0878
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.c
@@ -0,0 +1,259 @@
+#include "io_metrics_entry.h"
+#include "procfs.h"
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(6, 1, 0)
+#include "drivers/scsi/ufs/ufshcd.h"
+#else
+#include <scsi/scsi_cmnd.h>
+#include <ufs/ufshcd.h>
+#endif
+#include "ufs_metrics.h"
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+#include <trace/hooks/ufshcd.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+#include <trace/hooks/oplus_ufs.h>
+#endif
+
+#define UFS_METRICS_LAT(op)   \
+    atomic64_t ufs_metrics_lat_##op[LAT_500M_TO_MAX + 1] = {0};
+
+UFS_METRICS_LAT(write);
+UFS_METRICS_LAT(read);
+
+bool ufs_compl_command_enabled = false;
+module_param(ufs_compl_command_enabled, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(ufs_compl_command_enabled, " Debug android_vh_ufs_compl_command");
+
+atomic64_t ufs_metrics_timestamp[CYCLE_MAX];
+
+struct {
+    atomic64_t read_size;
+    atomic64_t read_cnt;
+    atomic64_t read_elapse;
+    atomic64_t write_size;
+    atomic64_t write_cnt;
+    atomic64_t write_elapse;
+    char padding[16];
+} ufs_metrics[CYCLE_MAX] = {0};
+
+void cb_android_vh_ufs_compl_command(void *ignore, struct ufs_hba *hba,
+                                     struct ufshcd_lrb *lrbp)
+{
+    ktime_t elapsed_in_ufs;
+    int transfer_len = 0;
+    u64 ufs_lat_range = 0;
+
+    if (unlikely(!io_metrics_enabled)) {
+        return ;
+    }
+    if (!lrbp->cmd) {
+        goto exit;
+    }
+    /*complete*/
+    elapsed_in_ufs = lrbp->compl_time_stamp - lrbp->issue_time_stamp;
+    switch(lrbp->cmd->cmnd[0]) {
+        case READ_6:
+        case READ_10:
+        case READ_16:
+        {
+            int i;
+            u64 current_time_ns, elapse;
+            transfer_len = be32_to_cpu(lrbp->ucd_req_ptr->sc.exp_data_transfer_len);
+            current_time_ns = lrbp->compl_time_stamp;
+            for (i = 0; i < CYCLE_MAX; i++) {
+                elapse = current_time_ns - atomic64_read(&ufs_metrics_timestamp[i]);
+                if (unlikely(elapse >= current_time_ns)) {
+                    atomic64_set(&ufs_metrics_timestamp[i], current_time_ns);
+                    atomic64_set(&ufs_metrics[i].read_cnt, 1);
+                    atomic64_set(&ufs_metrics[i].read_size, transfer_len);
+                    atomic64_set(&ufs_metrics[i].read_elapse, elapsed_in_ufs);
+                    elapse = 0;
+                    lat_range_check(elapsed_in_ufs, ufs_lat_range);
+                    memset(&ufs_metrics_lat_read, 0, sizeof(ufs_metrics_lat_read));
+                    atomic64_set(&ufs_metrics_lat_read[ufs_lat_range], 1);
+                } else {
+                    atomic64_inc(&ufs_metrics[i].read_cnt);
+                    atomic64_add(transfer_len, &ufs_metrics[i].read_size);
+                    atomic64_add(elapsed_in_ufs, &ufs_metrics[i].read_elapse);
+                    lat_range_check(elapsed_in_ufs, ufs_lat_range);
+                    atomic64_inc(&ufs_metrics_lat_read[ufs_lat_range]);
+                }
+                if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+                    /* 过期复位 */
+                    atomic64_set(&ufs_metrics_timestamp[i], 0);
+                }
+            }
+            if (unlikely(ufs_compl_command_enabled || io_metrics_debug_enabled)) {
+                io_metrics_print("read %d bytes cost %llu ns\n",
+                                 transfer_len, elapsed_in_ufs);
+            }
+            break;
+        }
+        case WRITE_6:
+        case WRITE_10:
+        case WRITE_16:
+        {
+            int i;
+            u64 current_time_ns, elapse;
+            transfer_len = be32_to_cpu(lrbp->ucd_req_ptr->sc.exp_data_transfer_len);
+            current_time_ns = lrbp->compl_time_stamp;
+            for (i = 0; i < CYCLE_MAX; i++) {
+                elapse = current_time_ns - atomic64_read(&ufs_metrics_timestamp[i]);
+                if (unlikely(elapse >= current_time_ns)) {
+                    atomic64_set(&ufs_metrics_timestamp[i], current_time_ns);
+                    atomic64_set(&ufs_metrics[i].write_cnt, 1);
+                    atomic64_set(&ufs_metrics[i].write_size, transfer_len);
+                    atomic64_set(&ufs_metrics[i].write_elapse, elapsed_in_ufs);
+                    elapse = 0;
+                    lat_range_check(elapsed_in_ufs, ufs_lat_range);
+                    memset(&ufs_metrics_lat_write, 0, sizeof(ufs_metrics_lat_write));
+                    atomic64_set(&ufs_metrics_lat_write[ufs_lat_range], 1);
+                } else {
+                    atomic64_inc(&ufs_metrics[i].write_cnt);
+                    atomic64_add(transfer_len, &ufs_metrics[i].write_size);
+                    atomic64_add(elapsed_in_ufs, &ufs_metrics[i].write_elapse);
+                    lat_range_check(elapsed_in_ufs, ufs_lat_range);
+                    atomic64_inc(&ufs_metrics_lat_write[ufs_lat_range]);
+                }
+                if (unlikely(elapse >= sample_cycle_config[i].cycle_value)) {
+                    /* 过期复位 */
+                    atomic64_set(&ufs_metrics_timestamp[i], 0);
+                }
+            }
+            if (unlikely(ufs_compl_command_enabled || io_metrics_debug_enabled)) {
+                io_metrics_print("write %d bytes cost %llu ns\n",
+                                 transfer_len, elapsed_in_ufs);
+            }
+            break;
+        }
+        case UNMAP:
+        {
+            if (unlikely(ufs_compl_command_enabled || io_metrics_debug_enabled)) {
+                transfer_len = be32_to_cpu(lrbp->ucd_req_ptr->sc.exp_data_transfer_len);
+                io_metrics_print("unmap %d bytes cost %llu ns\n",
+                                 transfer_len, elapsed_in_ufs);
+            }
+            break;
+        }
+        default:
+            goto exit;
+    }
+
+exit:
+    return;
+}
+
+void ufs_register_tracepoint_probes(void)
+{
+    int ret = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0)
+    ret = register_trace_android_vh_ufs_compl_command(cb_android_vh_ufs_compl_command, NULL);
+    WARN_ON(ret);
+#endif
+    io_metrics_print("run:%d\n", ret);
+}
+
+void ufs_unregister_tracepoint_probes(void)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0)
+    unregister_trace_android_vh_ufs_compl_command(cb_android_vh_ufs_compl_command, NULL);
+#endif
+    return;
+}
+
+static int ufs_metrics_proc_show(struct seq_file *seq_filp, void *data)
+{
+    u64 value = 123;
+    struct file *file = (struct file *)seq_filp->private;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+    int i = 0;
+    enum sample_cycle_type cycle;
+#endif
+
+    if (unlikely(!io_metrics_enabled)) {
+        seq_printf(seq_filp, "io_metrics_enabled not set to 1:%d\n", io_metrics_enabled);
+        return 0;
+    }
+
+    if (proc_show_enabled || unlikely(io_metrics_debug_enabled)) {
+        io_metrics_print("%s(%d) read %s/%s\n",
+            current->comm, current->pid, file->f_path.dentry->d_parent->d_iname,
+            file->f_path.dentry->d_iname);
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+    /* 确定采样周期的值（父目录） */
+    cycle = CYCLE_MAX;
+    for (i = 0; i < CYCLE_MAX; i++) {
+        if(!strcmp(file->f_path.dentry->d_parent->d_iname, sample_cycle_config[i].tag)) {
+            cycle = sample_cycle_config[i].value;
+        }
+    }
+    if (unlikely(cycle == CYCLE_MAX)) {
+        goto err;
+    }
+    if(!strcmp(file->f_path.dentry->d_iname, "ufs_total_read_size_mb")) {
+        value = atomic64_read(&ufs_metrics[cycle].read_size) >> 20;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "ufs_total_read_time_ms")) {
+        /*1ns=1/(1000*1000)ms≈1/(1024*1024)ms=1>>20ms,Precision=95.1%*/
+        value = atomic64_read(&ufs_metrics[cycle].read_elapse) >> 20;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "ufs_read_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&ufs_metrics_lat_read[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "ufs_total_write_size_mb")) {
+        value = atomic64_read(&ufs_metrics[cycle].write_size) >> 20;;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "ufs_total_write_time_ms")) {
+        value = atomic64_read(&ufs_metrics[cycle].write_elapse) >> 20;
+    } else if (!strcmp(file->f_path.dentry->d_iname, "ufs_write_lat_dist")) {
+        for (i = 0; i <= LAT_500M_TO_MAX; i++) {
+            seq_printf(seq_filp, "%llu,", atomic64_read(&ufs_metrics_lat_write[i]));
+        }
+        seq_printf(seq_filp, "\n");
+        return 0;
+    }
+#else
+    value = 0;
+#endif
+    seq_printf(seq_filp, "%llu\n", value);
+
+    return 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+err:
+    io_metrics_print("%s(%d) I don't understand what the operation: %s/%s\n",
+             current->comm,current->pid, file->f_path.dentry->d_parent->d_iname,
+             file->f_path.dentry->d_iname);
+    return -1;
+#endif
+}
+
+int ufs_metrics_proc_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, ufs_metrics_proc_show, file);
+}
+
+void ufs_metrics_reset(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+    int i = 0;
+
+    for (i = 0; i < CYCLE_MAX; i++) {
+        atomic64_set(&ufs_metrics_timestamp[i], 0);
+        atomic64_set(&ufs_metrics[i].read_size, 0);
+        atomic64_set(&ufs_metrics[i].read_cnt, 0);
+        atomic64_set(&ufs_metrics[i].read_elapse, 0);
+        atomic64_set(&ufs_metrics[i].write_size, 0);
+        atomic64_set(&ufs_metrics[i].write_cnt, 0);
+        atomic64_set(&ufs_metrics[i].write_elapse, 0);
+    }
+    memset(&ufs_metrics_lat_write, 0, sizeof(ufs_metrics_lat_write));
+    memset(&ufs_metrics_lat_read, 0, sizeof(ufs_metrics_lat_read));
+#else
+    return;
+#endif
+}
+void ufs_metrics_init(void)
+{
+    ufs_metrics_reset();
+}
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.h b/drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.h
new file mode 100644
index 000000000..16a24ace5
--- /dev/null
+++ b/drivers/soc/oplus/storage/common/io_metrics/ufs_metrics.h
@@ -0,0 +1,12 @@
+#ifndef __UFS_METRICS_H__
+#define __UFS_METRICS_H__
+
+#include <linux/fs.h>
+
+void ufs_register_tracepoint_probes(void);
+void ufs_unregister_tracepoint_probes(void);
+int ufs_metrics_proc_open(struct inode *inode, struct file *file);
+void ufs_metrics_reset(void);
+void ufs_metrics_init(void);
+
+#endif /* __UFS_METRICS_H__ */
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/include/storage.h b/drivers/soc/oplus/storage/include/storage.h
new file mode 100644
index 000000000..79d3f5236
--- /dev/null
+++ b/drivers/soc/oplus/storage/include/storage.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+* Copyright (C) 2020 Oplus. All rights reserved.
+*/
+
+#ifndef _STORAGE_H
+#define _STORAGE_H
+
+extern int pr_storage(const char *fmt, ...);
+
+#endif /*_STORAGE_H*/
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/Kconfig b/drivers/soc/oplus/storage/storage_feature_in_module/Kconfig
new file mode 100644
index 000000000..4d9876374
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/Kconfig
@@ -0,0 +1,5 @@
+source "drivers/soc/oplus/storage/common/storage_log/Kconfig"
+source "drivers/soc/oplus/storage/common/oplus_uprobe/Kconfig"
+source "drivers/soc/oplus/storage/common/ufs_oplus_dbg/Kconfig"
+source "drivers/soc/oplus/storage/common/oplus_f2fslog_storage/Kconfig"
+source "drivers/soc/oplus/storage/common/wq_dynamic_priority/Kconfig"
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/Makefile b/drivers/soc/oplus/storage/storage_feature_in_module/Makefile
new file mode 100644
index 000000000..e366ce37f
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/Makefile
@@ -0,0 +1,6 @@
+GCOV_PROFILE := y
+
+obj-y	+= common/storage_log/
+obj-y	+= common/oplus_uprobe/
+obj-y	+= common/oplus_f2fslog_storage/
+obj-y	+= common/wq_dynamic_priority/
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Kconfig b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Kconfig
new file mode 100644
index 000000000..21992dde6
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Kconfig
@@ -0,0 +1,7 @@
+
+config OPLUS_F2FSLOG_STORAGE
+    tristate "f2fs log storage"
+    default n
+    help
+      define this config to enable f2fs log storage.
+
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Makefile b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Makefile
new file mode 100644
index 000000000..1bab20e7b
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# Copyright (C) 2022-2030 Oplus. All rights reserved.
+
+LINUXINCLUDE += -I$(srctree)/
+obj-$(CONFIG_OPLUS_F2FSLOG_STORAGE) += oplus_f2fslog_storage.o
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/oplus_f2fslog_storage.c b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/oplus_f2fslog_storage.c
new file mode 100644
index 000000000..59327e34f
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_f2fslog_storage/oplus_f2fslog_storage.c
@@ -0,0 +1,229 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kprobes.h>
+#include <linux/printk.h>
+#include <linux/errno.h>
+#include <linux/f2fs_fs.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include "fs/f2fs/f2fs.h"
+#include <linux/proc_fs.h>
+#include <linux/mutex.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/suspend.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/rwsem.h>
+#include <linux/timer.h>
+#include <linux/reboot.h>
+#include <linux/signal.h>
+#include "kernel/trace/trace_probe.h"
+#include <linux/kstrtox.h>
+#include <linux/ctype.h>
+#include <linux/debugfs.h>
+#include <linux/of.h>
+#include <linux/rtc.h>
+#include <linux/kthread.h>
+#include <linux/moduleparam.h>
+#include <linux/namei.h>
+#include <linux/uprobes.h>
+#include <linux/time64.h>
+#include <linux/sched/clock.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/err.h>
+
+#define WRITE_BUFSIZE        4
+#define OPLUS_F2FS_PRINTK "[F2FS]"
+#define SIGVOLD_GET_LOG (SIGRTMIN + 0x13)
+#define BOOT_MAX_ERRLOG_NUM  2
+#define LOGLEVEL_BASE        48
+#define KERN_EME_LEVEL       0
+#define KERN_ERR_LEVEL       3
+#define KERN_WAEN_LEVEL      4
+#define KERN_DBG_LEVEL       7
+#define DElTA_T              60
+static int boot_geterrlog_num = 0;
+static struct proc_dir_entry *oplus_f2fslog_storage_procfs;
+static struct proc_dir_entry *oplus_f2fslog_level;
+extern int pr_storage(const char *fmt, ...);
+static int f2fslog_level = KERN_WAEN_LEVEL;
+static u64 timestamp[2] = {0};
+
+static struct task_struct *f2fs_get_task_struct_by_comm(const char *comm) {
+    struct task_struct *task;
+
+    for_each_process(task) {
+        if (strcmp(task->comm, comm) == 0) {
+            return task;
+        }
+    }
+
+    return NULL;
+}
+
+static int oplus_f2fslog_storage_show(struct seq_file *m, void *v)
+{
+    seq_printf(m, "f2fslog level: %d\n", f2fslog_level);
+    pr_storage("f2fslog level: %d\n", f2fslog_level);
+    return 0;
+}
+
+static int oplus_f2fslog_storage_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, oplus_f2fslog_storage_show, inode->i_private);
+}
+
+static ssize_t oplus_f2fslog_storage_write(struct file *file, const char __user *buffer,
+                size_t count, loff_t *ppos)
+{
+    char kbuf[5] = {0};
+    int ret = 0, tmp = 0;
+
+    if (count > WRITE_BUFSIZE) {
+        printk("input str is too long %s %d\n", __FUNCTION__, __LINE__);
+        return -EINVAL;
+    }
+
+    tmp = f2fslog_level;
+
+    if (copy_from_user(kbuf, buffer, count)) {
+        printk("copy data from user buffer failed %s %d\n", __FUNCTION__, __LINE__);
+    }
+
+    ret = kstrtoint(kbuf, 10, &f2fslog_level);
+    if(ret == 0){
+        printk("kstrtoint success %s %d %s %d\n",kbuf, f2fslog_level, __FUNCTION__, __LINE__);
+    } else {
+        printk("kstrtoint fail\n");
+    }
+
+    if(f2fslog_level > KERN_DBG_LEVEL || f2fslog_level < KERN_EME_LEVEL) {
+        f2fslog_level = tmp;
+        printk("f2fs log level set error %d %s %d\n", f2fslog_level, __FUNCTION__, __LINE__);
+    }
+
+    return count;
+}
+
+static struct proc_ops oplus_f2fsloglevel_proc_ops = {
+    .proc_open          = oplus_f2fslog_storage_open,
+    .proc_read          = seq_read,
+    .proc_write         = oplus_f2fslog_storage_write,
+    .proc_release       = single_release,
+    .proc_lseek         = default_llseek,
+};
+
+void f2fs_printk_wrapper(struct f2fs_sb_info *sbi, const char *fmt, ...)
+{
+    va_list args;
+    char buf[1024];
+    int level, log_level;
+    struct va_format vaf;
+    struct task_struct *task;
+    unsigned long ts = 0;
+
+    level = printk_get_level(fmt);
+    log_level = level - LOGLEVEL_BASE;
+    if(log_level > f2fslog_level || log_level < KERN_EME_LEVEL || log_level > KERN_DBG_LEVEL) {
+        return;
+    }
+
+    ts = local_clock();
+    do_div(ts, 1000000000);
+    timestamp[1] = ts;
+
+    va_start(args, fmt);
+    vaf.fmt = printk_skip_level(fmt);
+    vaf.va = &args;
+
+    //skip printk_skip_level for print
+    fmt = printk_skip_level(fmt);
+
+    vsnprintf(buf, sizeof(buf), fmt, args);
+    va_end(args);
+    pr_storage(OPLUS_F2FS_PRINTK "[%s][%c]: %s\n", sbi ? sbi->sb->s_id : "unknown", level , buf);
+
+    if(boot_geterrlog_num < BOOT_MAX_ERRLOG_NUM && log_level <= KERN_ERR_LEVEL) {
+        if(timestamp[1] - timestamp[0] > DElTA_T) {
+            task = f2fs_get_task_struct_by_comm("Binder:vold");
+            printk("%s, %d\n", __FUNCTION__, __LINE__);
+            if (!task) {
+                pr_err(OPLUS_F2FS_PRINTK "No task_struct found for process\n");
+                pr_storage(OPLUS_F2FS_PRINTK "No task_struct found for process\n");
+            } else{
+                send_sig_info(SIGVOLD_GET_LOG, SEND_SIG_PRIV, task);
+            }
+
+            boot_geterrlog_num ++;
+            timestamp[0] = timestamp[1];
+        }
+    }
+}
+
+static int handler_f2fslog_storage_pre(struct kprobe *p, struct pt_regs *regs)
+{
+    struct f2fs_sb_info *sbi = (struct f2fs_sb_info *)regs->regs[0];
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+    const char *fmt = (const char *)regs->regs[1];
+    unsigned long arg2 = regs->regs[2];
+    unsigned long arg3 = regs->regs[3];
+
+    f2fs_printk_wrapper(sbi, fmt, arg2, arg3);
+
+#else
+    const char *fmt = (const char *)regs->regs[2];
+    unsigned long arg3 = regs->regs[3];
+    unsigned long arg4 = regs->regs[4];
+
+    f2fs_printk_wrapper(sbi, fmt, arg3, arg4);
+#endif
+    return 0;
+}
+
+static struct kprobe oplus_f2fs_printk_kp = {
+    .symbol_name = "f2fs_printk",
+    .pre_handler = handler_f2fslog_storage_pre,
+};
+
+static int __init oplus_f2fshook_init(void) {
+    int ret;
+    printk("oplus_f2fshook_init\n");
+    ret = register_kprobe(&oplus_f2fs_printk_kp);
+    if (ret < 0) {
+        printk(" register_kprobe f2fs kprobe_register_kp failed, return %d\n", ret);
+        return ret;
+    }
+
+    oplus_f2fslog_storage_procfs = proc_mkdir("f2fslog_storage", NULL);
+    if (!oplus_f2fslog_storage_procfs) {
+        printk(" Failed to create oplus_f2fs_debug procfs\n");
+        return -EFAULT;
+    }
+
+    oplus_f2fslog_level = proc_create("f2fslog_level", 0644, oplus_f2fslog_storage_procfs, &oplus_f2fsloglevel_proc_ops);
+    if (oplus_f2fslog_level == NULL) {
+        printk(" Failed to create storage_reliable procfs\n");
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+static void __exit oplus_f2fshook_exit(void)
+{
+    unregister_kprobe(&oplus_f2fs_printk_kp);
+    if(NULL == oplus_f2fslog_storage_procfs || NULL == oplus_f2fslog_level) {
+        printk(" oplus_f2fshook_register or oplus_f2fshook_unregister is NULL\n");
+        return;
+    }
+
+    remove_proc_entry("f2fslog_storage", oplus_f2fslog_storage_procfs);
+    remove_proc_entry("f2fslog_level", oplus_f2fslog_level);
+}
+
+module_init(oplus_f2fshook_init);
+module_exit(oplus_f2fshook_exit);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Kconfig b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Kconfig
new file mode 100644
index 000000000..ea1ad010e
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Kconfig
@@ -0,0 +1,7 @@
+
+config OPLUS_FEATURE_OPLUS_UPROBE
+    tristate "oplus uprobe"
+    default n
+    help
+      define this config to enable oplus uprobe feature.
+
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Makefile b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Makefile
new file mode 100644
index 000000000..67a0780f2
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# Copyright (C) 2022-2030 Oplus. All rights reserved.
+
+GCOV_PROFILE := y
+LINUXINCLUDE += -I$(srctree)/
+obj-$(CONFIG_OPLUS_FEATURE_OPLUS_UPROBE) += oplus_uprobe.o
+
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.c b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.c
new file mode 100644
index 000000000..de9b4f4dc
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.c
@@ -0,0 +1,1296 @@
+#include <linux/module.h>
+#include <linux/ptrace.h>
+#include <linux/uprobes.h>
+#include <linux/namei.h>
+#include <linux/moduleparam.h>
+#include <linux/kthread.h>
+#include <linux/rtc.h>
+#include <linux/proc_fs.h>
+#include <linux/mutex.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/suspend.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/rwsem.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/kstrtox.h>
+#include <linux/slab.h>
+#include <linux/reboot.h>
+#include <linux/signal.h>
+#include <linux/kprobes.h>
+#include "kernel/trace/trace_probe.h"
+#define OPLUS_UPROBE_LOG_TAG "[oplus_uprobe]"
+
+#define WRITE_BUFSIZE  4096
+#define MAX_COMM_LENGTH 256
+#define WHITELIST_SIZE 48
+#define MAX_UPROBE_COUNT 47
+#define REG_VAL_MAX 64
+#define SIGVOLD_GET_LOG (SIGRTMIN + 0x13)
+#define SIGOLC_GET_LOG (SIGRTMIN + 0x14)
+#define SIGCONTROL_RUN_TIME (SIGRTMIN + 0x15)
+#define oplus_procedure_link_pointer(regs)	((regs)->regs[30])
+
+extern int pr_storage(const char *fmt, ...);
+static LIST_HEAD(uprobe_event_list);
+static struct proc_dir_entry *reliable_procfs;
+static struct proc_dir_entry *storage_reliable_procfs;
+struct proc_dir_entry *proc_fs_uprobe;
+struct proc_dir_entry *proc_fs_uprobe_enable;
+static int oplus_uprobe_enable = 0;
+static atomic_t uprobe_count = ATOMIC_INIT(0);
+typedef int (*uprobe_register_t)(struct inode *, loff_t, struct uprobe_consumer *);
+typedef void (*uprobe_unregister_t)(struct inode *, loff_t , struct uprobe_consumer *);
+uprobe_register_t uprobe_register_funcptr = NULL;
+uprobe_unregister_t uprobe_unregister_funcptr = NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+typedef int (*kern_path_t)(const char *name, unsigned int flags, struct path *path);
+typedef void (*path_put_t)(const struct path *path);
+kern_path_t kern_path_funcptr = NULL;
+path_put_t path_put_funcptr = NULL;
+#endif
+DECLARE_RWSEM(oplus_event_sem);
+
+struct ou_param {
+	struct timer_list       timer;
+	unsigned int            timeout;
+	unsigned int            nr_args;
+	struct probe_arg        args[];
+};
+
+enum OPLUS_ACTION {
+	A_PANIC,
+	A_LOG,
+	A_OLC,
+	A_RUNTIME,
+	A_RESET_MEDIA,
+	A_RESET_SYSTEM,
+	A_REBOOT,
+	A_KILL,
+	A_NONE,
+};
+
+struct oplus_uprobe {
+	struct list_head        head;
+	struct uprobe_consumer  consumer;
+	struct path             path;
+	struct inode            *inode;
+	char                    *filename;
+	unsigned int            userid;
+	unsigned int            runtime;
+	unsigned long           offset;
+	int                     action;
+	char*                   raw_cmd;
+	struct ou_param         param;
+};
+
+struct oplus_pt_regs_offset {
+	const char *name;
+	int offset;
+};
+
+#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}
+#define REG_OFFSET_END {.name = NULL, .offset = 0}
+#define GPR_OFFSET_NAME(r) \
+	{.name = "x" #r, .offset = offsetof(struct pt_regs, regs[r])}
+
+static const struct oplus_pt_regs_offset oplus_regoffset_table[] = {
+	GPR_OFFSET_NAME(0),
+	GPR_OFFSET_NAME(1),
+	GPR_OFFSET_NAME(2),
+	GPR_OFFSET_NAME(3),
+	GPR_OFFSET_NAME(4),
+	GPR_OFFSET_NAME(5),
+	GPR_OFFSET_NAME(6),
+	GPR_OFFSET_NAME(7),
+	GPR_OFFSET_NAME(8),
+	GPR_OFFSET_NAME(9),
+	GPR_OFFSET_NAME(10),
+	GPR_OFFSET_NAME(11),
+	GPR_OFFSET_NAME(12),
+	GPR_OFFSET_NAME(13),
+	GPR_OFFSET_NAME(14),
+	GPR_OFFSET_NAME(15),
+	GPR_OFFSET_NAME(16),
+	GPR_OFFSET_NAME(17),
+	GPR_OFFSET_NAME(18),
+	GPR_OFFSET_NAME(19),
+	GPR_OFFSET_NAME(20),
+	GPR_OFFSET_NAME(21),
+	GPR_OFFSET_NAME(22),
+	GPR_OFFSET_NAME(23),
+	GPR_OFFSET_NAME(24),
+	GPR_OFFSET_NAME(25),
+	GPR_OFFSET_NAME(26),
+	GPR_OFFSET_NAME(27),
+	GPR_OFFSET_NAME(28),
+	GPR_OFFSET_NAME(29),
+	GPR_OFFSET_NAME(30),
+	{.name = "lr", .offset = offsetof(struct pt_regs, regs[30])},
+	REG_OFFSET_NAME(sp),
+	REG_OFFSET_NAME(pc),
+	REG_OFFSET_NAME(pstate),
+	REG_OFFSET_END,
+};
+
+static char ou_whitelist[WHITELIST_SIZE][MAX_COMM_LENGTH] = {
+	"/system/bin/vold",
+	"/system/bin/vold_prepare_subdirs",
+	"/system/bin/ueventd",
+	"/system/bin/init",
+	"/system/bin/rm",
+	"/system/bin/cp",
+	"/system/bin/mkdir",
+	"/system/bin/rmdir",
+	"/system/bin/chown",
+	"/system/bin/chgrp",
+};
+
+
+static int is_event_in_whitelist(const char *event)
+{
+	int i;
+
+	for (i = 0; i < WHITELIST_SIZE; i++) {
+		if (strcmp(event, ou_whitelist[i]) == 0) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "is_event_in_whitelist true\n");
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+struct task_struct *get_task_struct_by_comm(const char *comm) {
+	struct task_struct *task;
+
+	for_each_process(task) {
+		if (strcmp(task->comm, comm) == 0) {
+			return task;
+		}
+	}
+
+	return NULL;
+}
+
+struct task_struct *get_media_task_struct(const char *comm, unsigned int userid) {
+	struct task_struct *task;
+
+	for_each_process(task) {
+		if (!strcmp(task->comm, comm) && (userid == (task->real_cred->uid.val/100000))) {
+			return task;
+		}
+	}
+
+	return NULL;
+}
+
+static int process_action_insn(int action, unsigned int	userid, unsigned int runtime)
+{
+	struct task_struct *task;
+	kernel_siginfo_t si;
+
+	switch (action) {
+	case A_PANIC:
+		panic("oplus uprobe trriger panic!");
+		break;
+	case A_LOG:
+		task = get_task_struct_by_comm("Binder:vold");
+		if (!task) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			pr_storage(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			break;
+		}
+		send_sig_info(SIGVOLD_GET_LOG, SEND_SIG_PRIV, task);
+		break;
+	case A_OLC:
+		task = get_task_struct_by_comm("Binder:vold");
+		if (!task) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			pr_storage(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			break;
+		}
+		send_sig_info(SIGOLC_GET_LOG, SEND_SIG_PRIV, task);
+		break;
+	case A_RUNTIME:
+		clear_siginfo(&si);
+		si.si_signo = SIGCONTROL_RUN_TIME;
+		si.si_errno = 0;
+		si.si_code  = -1;
+		si.si_int = runtime;
+		task = get_task_struct(current);
+		if (!task) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			pr_storage(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			break;
+		}
+		send_sig_info(SIGCONTROL_RUN_TIME, &si, task);
+		put_task_struct(current);
+		break;
+	case A_RESET_MEDIA:
+		task = get_media_task_struct("rs.media.module", userid);
+		if (!task) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			pr_storage(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			break;
+		}
+		send_sig_info(SIGKILL, SEND_SIG_PRIV, task);
+		break;
+	case A_RESET_SYSTEM:
+		task = get_task_struct_by_comm("system_server");
+		if (!task) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			pr_storage(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			break;
+		}
+		send_sig_info(SIGKILL, SEND_SIG_PRIV, task);
+		break;
+	case A_REBOOT:
+		kernel_restart(NULL);
+		break;
+	case A_NONE:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void uprobe_timed_out_timer(struct timer_list *t)
+{
+	struct ou_param *op = container_of(t, struct ou_param, timer);
+	struct oplus_uprobe *ou = container_of(op, struct oplus_uprobe, param);
+
+	pr_storage(OPLUS_UPROBE_LOG_TAG "uprobe_timed_out_timer\n");
+	if (!ou) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "get uprobe object failed\n");
+		return;
+	}
+	if (ou->action != A_REBOOT) {
+		process_action_insn(ou->action, ou->userid, ou->runtime);
+	}
+}
+
+static int timer_handler_pre(struct uprobe_consumer *self, struct pt_regs *regs)
+{
+	struct oplus_uprobe *ou = container_of(self, struct oplus_uprobe, consumer);
+
+	timer_setup(&ou->param.timer, uprobe_timed_out_timer, 0);
+	pr_storage(OPLUS_UPROBE_LOG_TAG "timer_handler_pre\n");
+	mod_timer(&ou->param.timer, jiffies + msecs_to_jiffies(ou->param.timeout));
+    return 0;
+}
+
+static int timer_handler_ret(struct uprobe_consumer *self,
+                                unsigned long func,
+                                struct pt_regs *regs)
+{
+	struct oplus_uprobe *ou = container_of(self, struct oplus_uprobe, consumer);
+
+	pr_storage(OPLUS_UPROBE_LOG_TAG "oplus_uprobe handler_ret\n");
+	del_timer_sync(&ou->param.timer);
+	return 0;
+}
+
+static inline void oplus_regs_set_return_value(struct pt_regs *regs, unsigned long rc)
+{
+  	regs->regs[0] = rc;
+}
+
+static inline void oplus_instruction_pointer_set(struct pt_regs *regs,
+  		unsigned long val)
+{
+  	regs->pc = val;
+}
+
+static int oplus_regs_query_register_offset(const char *name)
+{
+	const struct oplus_pt_regs_offset *roff;
+
+	for (roff = oplus_regoffset_table; roff->name != NULL; roff++)
+		if (!strcmp(roff->name, name))
+			return roff->offset;
+	return -EINVAL;
+}
+
+static int
+process_fetch_insn(struct fetch_insn *code, void *rec, void *dest,
+		   void *base,int action, unsigned int userid, unsigned int runtime)
+{
+	struct pt_regs *regs = rec;
+	unsigned long long val;
+	unsigned long long comp_val;
+	unsigned long long set_val;
+	unsigned int offset;
+	char *reg;
+	char *reg_val;
+	int ret;
+	struct task_struct *task;
+	pid_t current_tgid, tgid;
+	char *reg_string;
+
+	switch (code->op) {
+	case FETCH_OP_REG:
+		reg_string = kmalloc(REG_VAL_MAX, GFP_KERNEL);
+		strncpy(reg_string, (char*)code->data, REG_VAL_MAX);
+		reg = strsep(&reg_string, "=");
+		if (!reg) {
+			kfree(reg_string);
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register reg failed\n");
+			return -EINVAL;
+		}
+		reg_val = strsep(&reg_string, "=");
+		if (!reg_val) {
+			kfree(reg_string);
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register reg_val failed\n");
+			return -EINVAL;
+		}
+		pr_storage(OPLUS_UPROBE_LOG_TAG"oplus_parse_arg reg(%s) regval(%s)\n", reg,  reg_val);
+		if (isdigit(reg_val[0])) {
+			ret = kstrtoull(reg_val, 0, &comp_val);
+			if (ret) {
+				kfree(reg_string);
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse register kstrtoull failed\n");
+				return -EINVAL;
+			}
+		} else {
+			kfree(reg_string);
+			return -EINVAL;
+		}
+
+		ret = oplus_regs_query_register_offset(reg);
+		if (ret < 0) {
+			kfree(reg_string);
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register failed\n");
+			return -EINVAL;
+		}
+
+                offset = ret;
+		val = regs_get_register(regs, offset);
+		pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_REG val(0x%llx) offset(%u) comp_val(0x%llx)\n", val, offset, comp_val);
+		if (comp_val == val) {
+			pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_REG val(0x%llx) comp_val(0x%llx)\n", val, comp_val);
+			process_action_insn(action, userid, runtime);
+		}
+		kfree(reg_string);
+		break;
+	case FETCH_OP_MOD_BF:
+		reg_string = kmalloc(REG_VAL_MAX, GFP_KERNEL);
+		strncpy(reg_string, (char*)code->data, REG_VAL_MAX);
+		reg = strsep(&reg_string, "=");
+		if (!reg) {
+			kfree(reg_string);
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register reg failed\n");
+			return -EINVAL;
+		}
+		reg_val = strsep(&reg_string, "=");
+		if (!reg_val) {
+			kfree(reg_string);
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register reg_val failed\n");
+			return -EINVAL;
+		}
+		if (isdigit(reg_val[0])) {
+			ret = kstrtoull(reg_val, 0, &set_val);
+			if (ret) {
+				kfree(reg_string);
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse register kstrtoull failed\n");
+				return -EINVAL;
+			}
+		} else {
+			kfree(reg_string);
+			return -EINVAL;
+		}
+
+		offset = (unsigned int)oplus_regs_query_register_offset(reg);
+		if (offset < 0) {
+			pr_storage(OPLUS_UPROBE_LOG_TAG"oplus_parse_arg 2 reg(%s) offset(%d) regval(0x%llx)\n", reg, offset, set_val);
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register failed\n");
+			kfree(reg_string);
+			return -EINVAL;
+		} else if (offset >= 0) {
+			offset >>= 3;
+			pt_regs_write_reg(regs, offset, (unsigned long)set_val);
+			pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_MOD_BF offset(%d) set_val(0x%llx)\n", offset, set_val);
+		}
+
+		kfree(reg_string);
+		break;
+	case FETCH_OP_DATA:
+		oplus_regs_set_return_value(regs, code->offset);
+		oplus_instruction_pointer_set(regs, oplus_procedure_link_pointer(regs));
+		val = regs_return_value(regs);
+		pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_DATA set ret val(%d) offset(%d)\n", val, code->offset);
+		process_action_insn(action, userid, runtime);
+		break;
+	case FETCH_OP_RETVAL:
+		val = regs_return_value(regs);
+		if(val == code->offset) {
+			pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_RETVAL get ret val(%llu) offset(%d)\n", val, code->offset);
+			process_action_insn(action, userid, runtime);
+		}
+		break;
+	case FETCH_OP_COMM:
+		current_tgid = task_tgid_nr(current);
+		pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_COMM current_tgid(%d) \n",current_tgid);
+		task = get_task_struct_by_comm(code->data);
+		if (!task) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "No task_struct found for process\n");
+			break;
+		}
+		tgid = task->tgid;
+		pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_COMM tgid(%d) \n",tgid);
+		if (current_tgid == tgid) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "FETCH_OP_COMM\n");
+			pr_storage(OPLUS_UPROBE_LOG_TAG "FETCH_OP_COMM\n");
+			process_action_insn(action, userid, runtime);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int none_handler_pre(struct uprobe_consumer *self, struct pt_regs *regs)
+{
+	struct oplus_uprobe *ou = container_of(self, struct oplus_uprobe, consumer);
+
+	process_action_insn(ou->action, ou->userid, ou->runtime);
+	return 0;
+
+}
+
+static int keyvalue_handler_pre(struct uprobe_consumer *self, struct pt_regs *regs)
+{
+	struct oplus_uprobe *ou = container_of(self, struct oplus_uprobe, consumer);
+	int argc = ou->param.nr_args;
+	int action = ou->action;
+	unsigned int userid = ou->userid;
+	unsigned int runtime = ou->runtime;
+	int i;
+	for (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {
+		struct probe_arg *parg = &ou->param.args[i];
+		if (parg->code->op != FETCH_OP_RETVAL)
+			process_fetch_insn(parg->code, regs, NULL, NULL, action, userid, runtime);
+	}
+	pr_storage(OPLUS_UPROBE_LOG_TAG "keyvalue_handler_pre end\n");
+
+	return 0;
+
+}
+
+static int keyvalue_handler_ret(struct uprobe_consumer *self, unsigned long func, struct pt_regs *regs)
+{
+	struct oplus_uprobe *ou = container_of(self, struct oplus_uprobe, consumer);
+	int argc = ou->param.nr_args;
+	int action = ou->action;
+	unsigned int userid = ou->userid;
+	unsigned int runtime = ou->runtime;
+	int i;
+	for (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {
+		struct probe_arg *parg = &ou->param.args[i];
+		if (parg->code->op == FETCH_OP_RETVAL)
+			process_fetch_insn(parg->code, regs, NULL, NULL, action, userid, runtime);
+	}
+	pr_storage(OPLUS_UPROBE_LOG_TAG "keyvalue_handler_ret end\n");
+
+	return 0;
+}
+
+static int parse_probe_vars(char *arg, const struct fetch_type *t,
+			struct fetch_insn *code, int offs, char *value, unsigned int flags)
+{
+	int retval;
+	unsigned long param;
+	int ret = 0;
+	int len;
+
+	if (!strcmp(arg, "retval") && (flags & TPARG_FL_RETURN)) {
+		code->op = FETCH_OP_RETVAL;
+		ret = kstrtoint(value, 0, &retval);
+		if (ret) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse get retvalue failed\n");
+			goto inval_var;
+		}
+		code->offset = retval;
+	} else if (!strcmp(arg, "setret")) {
+		pr_storage(OPLUS_UPROBE_LOG_TAG "setret\n");
+		if(oplus_uprobe_enable == 1) {
+			code->op = FETCH_OP_DATA;
+			ret = kstrtoint(value, 0, &retval);
+			if (ret) {
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse set retvalue failed\n");
+				goto inval_var;
+			}
+			code->offset = retval;
+			return ret;
+		}
+		return -EINVAL;
+	} else if ((len = str_has_prefix(arg, "stack"))) {
+		if (arg[len] == '\0') {
+			code->op = FETCH_OP_STACKP;
+		} else if (isdigit(arg[len])) {
+			ret = kstrtoul(arg + len, 10, &param);
+			if (ret) {
+				goto inval_var;
+			} else {
+				code->op = FETCH_OP_STACK;
+				code->param = (unsigned int)param;
+			}
+		} else
+			goto inval_var;
+	} else if (strcmp(arg, "comm") == 0) {
+		code->op = FETCH_OP_COMM;
+		code->data = kstrdup(value, GFP_KERNEL);
+		if (!code->data)
+			return -ENOMEM;
+	} else
+		goto inval_var;
+
+	return ret;
+
+inval_var:
+	return -EINVAL;
+}
+
+static int parse_probe_reg(char *arg, struct fetch_insn *code)
+{
+	char *value;
+	int ret = 0;
+
+	if (strstr(arg, "setreg")) {
+		pr_storage(OPLUS_UPROBE_LOG_TAG "parse register setreg\n");
+		if(oplus_uprobe_enable == 1) {
+			value = strrchr(arg, ':');
+			if (!value) {
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse register value failed\n");
+				return -EINVAL;
+			}
+			*value++ = '\0';
+			code->op = FETCH_OP_MOD_BF;
+			code->data = kstrdup(value, GFP_KERNEL);
+			if (!code->data)
+				return -ENOMEM;
+			return ret;
+		}
+		return -EINVAL;
+	} else if (strstr(arg, "getreg")) {
+		pr_storage(OPLUS_UPROBE_LOG_TAG "parse register getreg\n");
+		value = strrchr(arg, ':');
+		if (!value) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register reg failed\n");
+			return -EINVAL;
+		}
+		*value++ = '\0';
+		code->op = FETCH_OP_REG;
+		code->data = kstrdup(value, GFP_KERNEL);
+		if (!code->data )
+			return -ENOMEM;
+	} else {
+			pr_err(OPLUS_UPROBE_LOG_TAG "parse register ending failed arg(%s)\n",arg);
+			return -EINVAL;
+	}
+
+	return ret;
+}
+static int oplus_parse_arg(char *arg, const struct fetch_type *type,
+								struct fetch_insn **pcode, struct fetch_insn *end,
+								unsigned int flags, int offs, bool is_return)
+{
+	struct fetch_insn *code = *pcode;
+	unsigned long param;
+	long offset = 0;
+	int ret = 0;
+	char *value;
+
+	switch (arg[0]) {
+	case '#':
+		value = strrchr(arg + 1, '=');
+		if (!value) {
+			return -EINVAL;
+		}
+		*value++ = '\0';
+		ret = parse_probe_vars(arg + 1, type, code, offs, value, is_return ? TPARG_FL_RETURN : 0);
+		break;
+
+	case '%':
+		ret = parse_probe_reg(arg + 1, code);
+		break;
+
+	case '@':
+		pr_storage(OPLUS_UPROBE_LOG_TAG"oplus_parse_arg 3 arg(%s)\n", arg + 1);
+		if (isdigit(arg[1])) {
+			ret = kstrtoul(arg + 1, 0, &param);
+			if (ret) {
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse memory-offset failed\n");
+				break;
+			}
+			code->op = FETCH_OP_IMM;
+			code->immediate = param;
+		} else if (arg[1] == '+') {
+			if (flags & TPARG_FL_KERNEL) {
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse memory-offset failed\n");
+				return -EINVAL;
+			}
+			ret = kstrtol(arg + 2, 0, &offset);
+			if (ret) {
+				pr_err(OPLUS_UPROBE_LOG_TAG "parse memory-offset failed\n");
+				break;
+			}
+
+			code->op = FETCH_OP_FOFFS;
+			code->immediate = (unsigned long)offset;  // imm64?
+		} else {
+			code->op = FETCH_NOP_SYMBOL;
+			code->data = kstrdup(arg + 1, GFP_KERNEL);
+			if (!code->data)
+				return -ENOMEM;
+			if (++code == end) {
+				pr_err(OPLUS_UPROBE_LOG_TAG "too many options\n");
+				return -EINVAL;
+			}
+			code->op = FETCH_OP_IMM;
+			code->immediate = 0;
+		}
+		if (++code == end) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "too many options\n");
+			return -EINVAL;
+		}
+
+		*pcode = code;
+		code->op = FETCH_OP_DEREF;
+		code->offset = offset;
+		break;
+	default:
+		return -EINVAL;
+
+	}
+	if (ret) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "BAD_FETCH_ARG\n");
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+int parse_keyvalue_body_arg(struct ou_param *op, int i, char *argv, bool is_return)
+{
+	struct probe_arg *parg = &op->args[i];
+	int ret = 0;
+	char *arg;
+	unsigned int flags = TPARG_FL_KERNEL;
+	arg = strchr(argv, ':');
+	if (!arg) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "key_value param is invalid, find no:\n");
+		goto err;
+	}
+	*arg++ = '\0';
+	pr_storage(OPLUS_UPROBE_LOG_TAG "parse arg(%s)\n", arg);
+	parg->code = kzalloc(sizeof(*parg->code), GFP_KERNEL);
+	if (!parg->code) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "kcalloc failed\n");
+		goto err;
+	}
+
+	ret = oplus_parse_arg(arg, parg->type, &parg->code, &parg->code[FETCH_INSN_MAX - 1], flags, 0, is_return);
+	if (ret) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "parse arg failed\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	if(parg->code)
+		kfree(parg->code);
+	return -EINVAL;
+}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+static int __nocfi kern_path_fn(const char *name, unsigned int flags, struct path *path)
+{
+	int ret = 0;
+
+	ret = kern_path_funcptr(name, flags, path);
+
+	return ret;
+}
+
+static void __nocfi path_put_fn(const struct path *path)
+{
+	path_put_funcptr(path);
+}
+#endif
+static struct oplus_uprobe* parse_uprobe_cmd(int argc, char **argv)
+{
+	char *arg;
+	struct path path;
+	char *event_name = "uprobe";
+	char *filename;
+	char *action;
+	unsigned long offset;
+	struct oplus_uprobe *ou = NULL;
+	int ret;
+	int i;
+	unsigned long timeout;
+	unsigned long userid;
+	unsigned long runtime;
+	bool is_return = false;
+	int type;
+
+	if (argc < 4) {
+		pr_err(OPLUS_UPROBE_LOG_TAG"argc %d is not invalid\n", argc);
+        return NULL;
+	}
+
+	type = argv[0][0];
+	switch (type) {
+	case 'r':
+		is_return = true;
+		break;
+	case 'p':
+		break;
+	default:
+		pr_err(OPLUS_UPROBE_LOG_TAG "cmd type(%c) is not supported\n", type);
+		return NULL;
+	}
+	if (argv[0][1] == ':') {
+		event_name = &argv[0][2];
+	}
+
+	filename = kstrdup(argv[1], GFP_KERNEL);
+	if (!filename)
+		return NULL;
+
+	arg = strrchr(filename, ':');
+	if (!arg || !isdigit(arg[1])) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "filename %s is not invalid\n", filename);
+		goto err;
+	}
+	*arg++ = '\0';
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+	ret = kern_path_fn(filename, LOOKUP_FOLLOW, &path);
+#else
+	ret = kern_path(filename, LOOKUP_FOLLOW, &path);
+#endif
+	if (ret < 0) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "kern_path failed, ret %d, filename %s\n", ret, filename);
+		goto err;
+	}
+	if (is_event_in_whitelist(filename)) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "is_event_in_whitelist false\n");
+		goto err;
+	}
+	ret = kstrtoul(arg, 0, &offset);
+	if (ret) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "offset param is invalid, %s\n", arg);
+		goto err;
+	}
+	argc -= 3;
+	pr_storage(OPLUS_UPROBE_LOG_TAG "filename(%s), offset(0x%lx) argc(%d)\n", filename, offset, argc);
+	ou = kzalloc(struct_size(ou, param.args, argc), GFP_KERNEL);
+	if (!ou) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "alloc ou failed\n");
+		goto err;
+	}
+	argv += 2;
+	pr_storage(OPLUS_UPROBE_LOG_TAG "argv[0](%s)\n", argv[0]);
+	if (0 == strncmp(argv[0], "timer", strlen("timer"))) {
+		arg = strrchr(argv[0], ':');
+		if (!arg || !isdigit(arg[1])) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "argv[0] param is invalid, %s\n", argv[0]);
+			goto err;
+		}
+
+		*arg++ = '\0';
+		ret = kstrtoul(arg, 0, &timeout);
+		if (ret) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "timer timeout param is invalid (%s)\n", arg);
+			goto err;
+		}
+		ou->param.timeout = timeout;
+		ou->consumer.handler = timer_handler_pre;
+		ou->consumer.ret_handler = timer_handler_ret;
+	} else if (0 == strncmp(argv[0], "key_value", strlen("key_value"))) {
+		//argv += 2;
+		pr_storage(OPLUS_UPROBE_LOG_TAG "key_value argc(%d)\n", argc);
+		for (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {
+			ret = parse_keyvalue_body_arg(&ou->param, i, argv[i], is_return);
+			if (ret)
+				goto err;
+		}
+		ou->param.nr_args = argc;
+		ou->consumer.handler = keyvalue_handler_pre;
+		if (is_return)
+			ou->consumer.ret_handler = keyvalue_handler_ret;
+	} else if (0 == strncmp(argv[0], "none", strlen("none"))) {
+		ou->consumer.handler = none_handler_pre;
+	} else {
+		pr_err(OPLUS_UPROBE_LOG_TAG " invalid argv[2] (%s)\n", argv[2]);
+		goto err;
+	}
+
+	action = argv[argc];
+	if (!action) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "action is NULL \n");
+		goto err;
+	}
+	pr_storage(OPLUS_UPROBE_LOG_TAG "action(%s)\n", action);
+	if (0 == strncmp(action, "panic", strlen("panic"))) {
+		ou->action = A_PANIC;
+	} else if(0 == strncmp(action, "vlog", strlen("vlog"))) {
+		ou->action = A_LOG;
+	} else if(0 == strncmp(action, "rtime", strlen("rtime"))) {
+		arg = strrchr(action, ':');
+		if (!arg || !isdigit(arg[1])) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "action is invalid, %s\n", action);
+			goto err;
+		}
+
+		*arg++ = '\0';
+		ret = kstrtoul(arg, 0, &runtime);
+		if (ret) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "timer userid is invalid (%s)\n", arg);
+			goto err;
+		}
+		ou->runtime = runtime;
+		ou->action = A_RUNTIME;
+	} else if(0 == strncmp(action, "olog", strlen("olog"))) {
+		ou->action = A_OLC;
+	} else if(0 == strncmp(action, "rmedia", strlen("rmedia"))) {
+		arg = strrchr(action, ':');
+		if (!arg || !isdigit(arg[1])) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "action is invalid, %s\n", action);
+			goto err;
+		}
+
+		*arg++ = '\0';
+		ret = kstrtoul(arg, 0, &userid);
+		if (ret) {
+			pr_err(OPLUS_UPROBE_LOG_TAG "timer userid is invalid (%s)\n", arg);
+			goto err;
+		}
+		ou->userid = userid;
+		ou->action = A_RESET_MEDIA;
+	} else if(0 == strncmp(action, "rsystem", strlen("rsystem"))) {
+		ou->action = A_RESET_SYSTEM;
+	} else if(0 == strncmp(action, "reboot", strlen("reboot"))) {
+		ou->action = A_REBOOT;
+	} else if(0 == strncmp(action, "none", strlen("none"))) {
+		ou->action = A_NONE;
+	} else {
+		pr_storage(OPLUS_UPROBE_LOG_TAG "invalid action\n");
+		pr_err(OPLUS_UPROBE_LOG_TAG "invalid action\n");
+		goto err;
+	}
+	ou->offset = offset;
+	ou->path = path;
+	ou->filename = filename;
+	return ou;
+
+err:
+	if (ou)
+		kfree(ou);
+
+	if (filename)
+		kfree(filename);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+	if (path.mnt && path.dentry)
+		path_put_fn(&path);
+#else
+	if (path.mnt && path.dentry)
+		path_put(&path);
+#endif
+
+	return NULL;
+}
+
+void ou_param_cleanup(struct probe_arg *arg)
+{
+	struct fetch_insn *code = arg->code;
+
+	if (code->op == FETCH_OP_COMM) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "ou_param_cleanup code->data \n");
+		kfree(code->data);
+	}
+
+	kfree(arg->code);
+}
+
+int __nocfi uprobe_register_fn(struct inode *inode, unsigned long offset, struct uprobe_consumer *consumer)
+{
+	int ret = 0;
+
+	ret = uprobe_register_funcptr(inode, offset, consumer);
+
+	return ret;
+}
+
+void __nocfi uprobe_unregister_fn(struct inode *inode, unsigned long offset, struct uprobe_consumer *consumer)
+{
+	uprobe_unregister_funcptr(inode, offset, consumer);
+}
+
+static void delete_uprobe_cmd(int argc, char **argv)
+{
+	int ret;
+	char *arg;
+	char *filename;
+	unsigned long offset;
+	struct oplus_uprobe *comp;
+	struct path path;
+	struct inode *comp_inode;
+	int i;
+
+	if (argc < 2) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "argc %d is not invalid\n", argc);
+		return;
+	}
+
+	filename = argv[1];
+	if (!strchr(filename, '/')) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "filename %s is not invalid\n", filename);
+		return;
+	}
+
+	arg = strrchr(filename, ':');
+	if (!arg || !isdigit(arg[1])) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "filename %s is not invalid\n", filename);
+		return;
+	}
+	*arg++ = '\0';
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+	ret = kern_path_fn(filename, LOOKUP_FOLLOW, &path);
+#else
+	ret = kern_path(filename, LOOKUP_FOLLOW, &path);
+#endif
+	if (ret < 0) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "kern_path failed, ret %d, filename %s\n", ret, filename);
+		return;
+	}
+
+	ret = kstrtoul(arg, 0, &offset);
+	if (ret) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "offset param is invalid, %s\n", arg);
+		return;
+	}
+	down_write(&oplus_event_sem);
+	list_for_each_entry(comp, &uprobe_event_list, head) {
+		comp_inode = d_real_inode(comp->path.dentry);
+		if (comp_inode == d_real_inode(path.dentry) && (comp->offset == offset)) {
+			list_del(&comp->head);
+			uprobe_unregister_fn(comp->inode, comp->offset, &comp->consumer);
+			comp->inode = NULL;
+			for (i = 0; i < comp->param.nr_args && i < MAX_TRACE_ARGS; i++) {
+				ou_param_cleanup(&comp->param.args[i]);
+			}
+			kfree(comp->filename);
+			kfree(comp->raw_cmd);
+			kfree(comp);
+			atomic_dec(&uprobe_count);
+			pr_storage(OPLUS_UPROBE_LOG_TAG "ou_param_cleanup done \n");
+			break;
+		}
+	}
+	up_write(&oplus_event_sem);
+}
+
+static int oplus_uprobe_register(struct oplus_uprobe *ou)
+{
+	int ret;
+
+	ou->inode = d_real_inode(ou->path.dentry);
+	pr_err(OPLUS_UPROBE_LOG_TAG "oplus_uprobe_register\n");
+	ret = uprobe_register_fn(ou->inode, ou->offset, &ou->consumer);
+	if (ret)
+		ou->inode = NULL;
+
+	return ret;
+}
+
+static ssize_t oplus_uprobe_proc_write(struct file *file, const char __user *buffer,
+			    size_t count, loff_t *ppos)
+{
+	char *kbuf = NULL;
+	int argc = 0;
+	char **argv = NULL;
+	struct oplus_uprobe *ou = NULL;
+	struct oplus_uprobe *comp;
+	struct inode *comp_inode;
+	int ret;
+
+    if (count > WRITE_BUFSIZE) {
+        return -EINVAL;
+	}
+	kbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);
+	if (!kbuf) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kbuf, buffer, count)) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "copy data from user buffer failed\n");
+		goto err;
+	}
+
+	kbuf[count] = '\0';
+
+	argv = argv_split(GFP_KERNEL, kbuf, &argc);
+	if (!argv) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "argv_split fail\n");
+		goto err;
+	}
+
+	if (argv[0][0] == '-') {
+		delete_uprobe_cmd(argc, argv);
+		goto out;
+	}
+
+    if (atomic_read(&uprobe_count) > MAX_UPROBE_COUNT) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "uprobe_count Maximum limit\n");
+		pr_storage(OPLUS_UPROBE_LOG_TAG "uprobe_count Maximum limit uprobe_count(%d)\n", atomic_read(&uprobe_count));
+		goto err;
+	}
+
+	ou = parse_uprobe_cmd(argc, argv);
+	if (!ou) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "parse_uprobe_cmd fail\n");
+		goto err;
+	}
+	ou->raw_cmd = kbuf;
+	INIT_LIST_HEAD(&ou->head);
+
+	down_write(&oplus_event_sem);
+	list_for_each_entry(comp, &uprobe_event_list, head) {
+		comp_inode = d_real_inode(comp->path.dentry);
+		if (comp_inode == d_real_inode(ou->path.dentry) && (comp->offset == ou->offset)) {
+			up_write(&oplus_event_sem);
+			pr_storage(OPLUS_UPROBE_LOG_TAG "the same event exist, filename %s, offset 0x%lx\n", comp->filename, comp->offset);
+			goto err;
+		}
+	}
+	list_add_tail(&ou->head, &uprobe_event_list);
+	up_write(&oplus_event_sem);
+
+	ret = oplus_uprobe_register(ou);
+	if (ret) {
+		kfree(ou->filename);
+		//uprobe_unregister(ou->inode, ou->offset, &ou->consumer);
+		uprobe_unregister_fn(ou->inode, ou->offset, &ou->consumer);
+		down_write(&oplus_event_sem);
+		list_del(&ou->head);
+		up_write(&oplus_event_sem);
+		pr_err(OPLUS_UPROBE_LOG_TAG "create_uprobe_cmd failed, ret %d\n", ret);
+		goto err;
+	}
+	atomic_inc(&uprobe_count);
+out:
+	argv_free(argv);
+	pr_storage(OPLUS_UPROBE_LOG_TAG "proc write succeed\n");
+	return count;
+
+err:
+	if (kbuf) {
+		kfree(kbuf);
+	}
+
+	if (argv) {
+		argv_free(argv);
+	}
+
+	if (ou) {
+		kfree(ou);
+	}
+
+	pr_storage(OPLUS_UPROBE_LOG_TAG "proc write failed\n");
+	return -1;
+}
+
+static int oplus_uprobe_proc_show(struct seq_file *m, void *v)
+{
+	struct oplus_uprobe* tmp;
+
+	down_write(&oplus_event_sem);
+	list_for_each_entry(tmp, &uprobe_event_list, head) {
+		seq_printf(m, "%s\n", tmp->raw_cmd);
+		pr_storage("%s\n", tmp->raw_cmd);
+	}
+	up_write(&oplus_event_sem);
+
+	return 0;
+}
+
+static int oplus_uprobe_proc_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, oplus_uprobe_proc_show, inode->i_private);
+}
+
+static struct proc_ops oplus_uprobe_proc_ops = {
+	.proc_open			= oplus_uprobe_proc_open,
+	.proc_read			= seq_read,
+	.proc_write			= oplus_uprobe_proc_write,
+	.proc_release			= single_release,
+	.proc_lseek			= default_llseek,
+};
+
+static ssize_t uprobe_enable_proc_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *off)
+{
+	char str[3] = {0};
+
+	if (count > 2 || count < 1) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(str, buf, count)) {
+		pr_err(OPLUS_UPROBE_LOG_TAG "copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (unlikely(!strncmp(str, "1", 1))) {
+		pr_info(OPLUS_UPROBE_LOG_TAG "oplus uprobe enable\n");
+		oplus_uprobe_enable = 1;
+	} else {
+		pr_info(OPLUS_UPROBE_LOG_TAG "oplus uprobe disabled\n");
+		oplus_uprobe_enable = 0;
+	}
+
+	return (ssize_t)count;
+}
+
+static int uprobe_enable_show(struct seq_file *s, void *data)
+{
+	if (oplus_uprobe_enable == 1)
+		seq_printf(s, "%d\n", 1);
+	else
+		seq_printf(s, "%d\n", 0);
+
+	return 0;
+}
+
+static int uprobe_enable_proc_open(struct inode *inodp, struct file *filp)
+{
+	return single_open(filp, uprobe_enable_show, inodp);
+}
+
+static struct proc_ops uprobe_enable_fops = {
+	.proc_open		= uprobe_enable_proc_open,
+	.proc_read		= seq_read,
+	.proc_write		= uprobe_enable_proc_write,
+	.proc_release		= single_release,
+	.proc_lseek		= default_llseek,
+};
+
+static struct kprobe uprobe_register_kp = {
+	.symbol_name = "uprobe_register"
+};
+static struct kprobe uprobe_unregister_kp = {
+	.symbol_name = "uprobe_unregister"
+};
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+static struct kprobe kern_path_kp = {
+	.symbol_name = "kern_path"
+};
+static struct kprobe path_put_kp = {
+	.symbol_name = "path_put"
+};
+#endif
+static int __init oplus_uprobe_init(void) {
+
+	int ret;
+	ret = register_kprobe(&uprobe_register_kp);
+	if (ret < 0) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" register_kprobe uprobe_register_kp failed, return %d\n", ret);
+		return ret;
+	} else {
+		uprobe_register_funcptr = (uprobe_register_t)uprobe_register_kp.addr;
+		unregister_kprobe(&uprobe_register_kp);
+		pr_err(OPLUS_UPROBE_LOG_TAG" uprobe_register func addr:0x%lx\n", (unsigned long)uprobe_register_funcptr);
+	}
+
+	ret = register_kprobe(&uprobe_unregister_kp);
+	if (ret < 0) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" register_kprobe uprobe_unregister_kp failed, return %d\n", ret);
+		return ret;
+	} else {
+		uprobe_unregister_funcptr = (uprobe_unregister_t)uprobe_unregister_kp.addr;
+		unregister_kprobe(&uprobe_unregister_kp);
+		pr_err(OPLUS_UPROBE_LOG_TAG" uprobe_unregister func addr:0x%lx\n", (unsigned long)uprobe_unregister_funcptr);
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+	ret = register_kprobe(&kern_path_kp);
+	if (ret < 0) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" register_kprobe kern_path_kp failed, return %d\n", ret);
+		return ret;
+	} else {
+		kern_path_funcptr = (kern_path_t)kern_path_kp.addr;
+		unregister_kprobe(&kern_path_kp);
+		//pr_err(OPLUS_UPROBE_LOG_TAG" uprobe_register func addr:0x%lx\n", (unsigned long)kern_path_kp);
+	}
+
+	ret = register_kprobe(&path_put_kp);
+	if (ret < 0) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" register_kprobe path_put_kp failed, return %d\n", ret);
+		return ret;
+	} else {
+		path_put_funcptr = (path_put_t)uprobe_unregister_kp.addr;
+		unregister_kprobe(&path_put_kp);
+		//pr_err(OPLUS_UPROBE_LOG_TAG" uprobe_unregister func addr:0x%lx\n",(unsigned long) path_put_kp);
+	}
+#endif
+	if(NULL == uprobe_register_funcptr || NULL == uprobe_unregister_funcptr) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" uprobe_register or uprobe_unregister is NULL\n");
+		return -EFAULT;
+	}
+
+	reliable_procfs = proc_mkdir("oplus_reliable", NULL);
+	if (!reliable_procfs) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" Failed to create oplus_reliable procfs\n");
+		return -EFAULT;
+	}
+
+	storage_reliable_procfs = proc_mkdir("storage_reliable", reliable_procfs);
+	if (storage_reliable_procfs == NULL) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" Failed to create storage_reliable procfs\n");
+		return -EFAULT;
+	}
+
+	proc_fs_uprobe = proc_create("oplus_uprobe", 0644, storage_reliable_procfs, &oplus_uprobe_proc_ops);
+	if (proc_fs_uprobe == NULL) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" Failed to create file oplus_storage/storage_reliable/oplus_uprobe\n");
+		return -EFAULT;
+	}
+
+	proc_fs_uprobe_enable = proc_create("uprobe_enable", 0600, storage_reliable_procfs, &uprobe_enable_fops);
+	if (proc_fs_uprobe_enable == NULL) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" Failed to create file oplus_storage/storage_reliable/uprobe_enable\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void __exit oplus_uprobe_exit(void)
+{
+
+	if(NULL == uprobe_register_funcptr || NULL == uprobe_unregister_funcptr) {
+		pr_err(OPLUS_UPROBE_LOG_TAG" uprobe_register or uprobe_unregister is NULL\n");
+		return;
+	}
+
+
+	remove_proc_entry("oplus_uprobe", proc_fs_uprobe);
+	remove_proc_entry("uprobe_enable", proc_fs_uprobe_enable);
+}
+
+module_init(oplus_uprobe_init);
+module_exit(oplus_uprobe_exit);
+
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+MODULE_AUTHOR("Cheng");
+MODULE_DESCRIPTION("oplus uprobe driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.h b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.h
new file mode 100644
index 000000000..0a17f1ab0
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/oplus_uprobe/oplus_uprobe.h
@@ -0,0 +1,4 @@
+#ifdef _OPLUS_UPROBE_H
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Kconfig b/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Kconfig
new file mode 100644
index 000000000..86620fbe4
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Kconfig
@@ -0,0 +1,7 @@
+
+config OPLUS_FEATURE_STORAGE_LOG
+   tristate "config storage log"
+   default n
+   help
+     General Configuration of Storage Log
+
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Makefile b/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Makefile
new file mode 100644
index 000000000..32d1b7242
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/Makefile
@@ -0,0 +1,3 @@
+GCOV_PROFILE := y
+obj-$(CONFIG_OPLUS_FEATURE_STORAGE_LOG) += oplus_storage_log.o
+oplus_storage_log-y := storage_log.o
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/storage_log.c b/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/storage_log.c
new file mode 100644
index 000000000..4e2577dc6
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/storage_log/storage_log.c
@@ -0,0 +1,240 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/time64.h>
+#include <linux/sched/clock.h>
+
+#define LOG_BUFFER_SIZE 1048576
+#define LOG_LINE_MAX    1024
+#define CLEAR_STORAGE_LOG "clear storage log"
+#define STORAGE_LOG_HEAD "storage log begin:\n"
+
+struct storage_log_data {
+    char* buf; /* ring buffer */
+    loff_t pos;
+    ssize_t len;
+    ssize_t head_len;
+    ssize_t show_len;
+    spinlock_t lock;
+    struct proc_dir_entry *storage;
+    struct proc_dir_entry *buf_log;
+};
+
+struct storage_log_data *log_data;
+
+#define STORAGE_LOG_HEAD_LEN log_data->head_len
+
+static size_t add_timestamp(char *buf)
+{
+    u64 ts = local_clock();
+    unsigned long rem_nsec = do_div(ts, 1000000000);
+
+    return sprintf(buf, "[%5lu.%06lu] ", (unsigned long)ts, rem_nsec / 1000);
+}
+
+#define STORAGE_LOG_WRITE(buffer, count, flags)                                  \
+    do {                                                                         \
+        char _timestamp[64];                                                     \
+        ssize_t _len = add_timestamp(_timestamp);                                \
+        spin_lock_irqsave(&log_data->lock, flags);                               \
+        if (log_data->pos + count + _len < LOG_BUFFER_SIZE) {                    \
+            memcpy(log_data->buf + log_data->pos, _timestamp, _len);              \
+            log_data->pos += _len;                                                \
+            memcpy(log_data->buf + log_data->pos, buffer, count);                  \
+            log_data->pos += count;                                                \
+        } else {                                                                  \
+            memcpy(log_data->buf, _timestamp, _len);                              \
+            memcpy(log_data->buf + _len , buffer, count);                         \
+            log_data->pos = _len + count;                                         \
+        }                                                                         \
+        log_data->len = min_t(size_t, (log_data->len + _len + count), LOG_BUFFER_SIZE); \
+        spin_unlock_irqrestore(&log_data->lock, flags);                                 \
+    } while (0)
+
+static void* log_start(struct seq_file *m, loff_t *pos)
+{
+    return (*pos >= log_data->len) ? NULL : log_data;
+}
+
+static void* log_next(struct seq_file *m, void *v, loff_t *pos)
+{
+    *pos += log_data->show_len;
+    return (*pos >= log_data->len) ? NULL : log_data;
+}
+
+static int log_show(struct seq_file *m, void *v)
+{
+    ssize_t len;
+
+    pr_debug("log show, size:%lu, count:%lu, read pos:%lu, log pos:%lu, log len:%lu\n",
+            m->size, m->count, (unsigned long)m->read_pos, (unsigned long)log_data->pos, log_data->len);
+
+    len = min_t(size_t, m->size, (log_data->len - m->read_pos));
+    memcpy(m->buf, log_data->buf + m->read_pos, len);
+    m->count = len;
+    log_data->show_len = len;
+    return 0;
+}
+
+static void log_stop(struct seq_file *m, void *v)
+{
+    log_data->show_len = 0;
+}
+
+static struct seq_operations log_ops = {
+    .start = log_start,
+    .stop = log_stop,
+    .next  = log_next,
+    .show = log_show
+};
+
+static int log_open(struct inode *inode, struct file *file)
+{
+    int err = -1;
+
+    err = seq_open(file, &log_ops);
+    if (!err)
+        ((struct seq_file *)file->private_data)->private = log_data;
+
+    return err;
+}
+
+static ssize_t log_write(struct file *file,
+               const char __user *buf,
+               size_t count,
+               loff_t *pos)
+{
+    unsigned long flags;
+    ssize_t len;
+    static char data_buf[LOG_LINE_MAX];
+
+    if (!count)
+        return 0;
+
+    if (count > LOG_LINE_MAX) {
+        pr_err("count(%lu) is larger than log line max(%d)\n", count, LOG_LINE_MAX);
+        return -1;
+    }
+
+    len = min_t(size_t, count, LOG_LINE_MAX);
+    if (copy_from_user(data_buf, buf, len)) {
+        pr_err("log write, copy data failed, count:%lu\n", count);
+        return -1;
+    }
+
+    pr_debug("log write, count:%lu, len:%lu, log pos:%u, log len:%lu\n",
+            count, len, (unsigned int)log_data->pos, log_data->len);
+
+    if (strncmp(CLEAR_STORAGE_LOG, data_buf, strlen(CLEAR_STORAGE_LOG)) == 0) {
+        pr_err("clear all storage log\n");
+        spin_lock_irqsave(&log_data->lock, flags);
+        log_data->len = STORAGE_LOG_HEAD_LEN;
+        log_data->pos = STORAGE_LOG_HEAD_LEN;
+        spin_unlock_irqrestore(&log_data->lock, flags);
+        return count;
+    }
+
+    STORAGE_LOG_WRITE(data_buf, len, flags);
+    return len;
+}
+
+static const struct proc_ops log_fops = {
+    .proc_open = log_open,
+    .proc_read = seq_read,
+    .proc_write = log_write,
+    .proc_release = seq_release,
+    .proc_lseek = default_llseek,
+};
+
+int pr_storage(const char *fmt, ...)
+{
+    static char text_buf[LOG_LINE_MAX];
+    va_list args;
+    int count;
+    unsigned long flags;
+
+    va_start(args, fmt);
+    count = vsnprintf(text_buf, LOG_LINE_MAX, fmt, args);
+    va_end(args);
+
+    STORAGE_LOG_WRITE(text_buf, count, flags);
+    return count;
+}
+
+EXPORT_SYMBOL_GPL(pr_storage);
+
+static void log_data_init(void)
+{
+    log_data->head_len = strlen(STORAGE_LOG_HEAD);
+    log_data->len = log_data->head_len;
+    log_data->pos = log_data->head_len;
+
+    spin_lock_init(&log_data->lock);
+}
+
+static int __init storage_log_init(void)
+{
+    log_data = kmalloc(sizeof(struct storage_log_data), GFP_KERNEL);
+    if (!log_data) {
+        pr_err("kmalloc error, storage_log init failed\n");
+        goto out;
+    }
+
+    log_data_init();
+
+    log_data->buf = vmalloc(LOG_BUFFER_SIZE);
+    if (!log_data->buf) {
+        pr_err("vmalloc error, storage_log init failed\n");
+        goto out_kfree;
+    }
+    memcpy(log_data->buf, STORAGE_LOG_HEAD, STORAGE_LOG_HEAD_LEN);
+
+    log_data->storage = proc_mkdir("storage", NULL);
+    if (!log_data->storage) {
+        pr_err("create storage error, storage init failed\n");
+        goto out_vfree;
+    }
+
+    log_data->buf_log = proc_create_data("buf_log", S_IRWXUGO, log_data->storage,
+            &log_fops, log_data);
+    if (!log_data->buf_log) {
+        pr_err("create buf log error, buf_log init failed\n");
+        goto out_remove;
+    }
+
+    pr_info("storage_log init succeed\n");
+    return 0;
+
+out_remove:
+    remove_proc_entry("storage", NULL);
+out_vfree:
+    vfree(log_data->buf);
+out_kfree:
+    kfree(log_data);
+out:
+    return -1;
+}
+
+static void __exit storage_log_exit(void)
+{
+    remove_proc_entry("buf_log", log_data->storage);
+    remove_proc_entry("storage", NULL);
+
+    vfree(log_data->buf);
+    kfree(log_data);
+
+    pr_info("storage_log exit succeed\n");
+}
+
+module_init(storage_log_init);
+module_exit(storage_log_exit);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Kconfig b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Kconfig
new file mode 100644
index 000000000..6797d2b18
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Kconfig
@@ -0,0 +1,9 @@
+config OPLUS_UFS_DRIVER
+  tristate "config oplus ufs driver"
+  help
+    define this config to compile ufs-oplus-dbg for device register
+
+config OPLUS_QCOM_UFS_DRIVER
+  tristate "config oplus qcom ufs driver"
+  help
+    define this config to compile ufs-qcom-oplus-dbg for device register
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Makefile b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Makefile
new file mode 100644
index 000000000..7301b88ef
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/Makefile
@@ -0,0 +1,2 @@
+ccflags-y += -I$(srctree)/drivers/ufs/core/
+obj-$(CONFIG_OPLUS_UFS_DRIVER)	+= ufs-oplus-dbg.o
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.c b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.c
new file mode 100644
index 000000000..4d007f085
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.c
@@ -0,0 +1,1215 @@
+#include <scsi/scsi.h>
+#include <scsi/scsi_ioctl.h>
+#include <scsi/scsi_cmnd.h>
+#include <ufs/ufs_quirks.h>
+#include <ufs/ufshcd.h>
+#include <ufs/unipro.h>
+#include <trace/hooks/ufshcd.h>
+#include <linux/tracepoint.h>
+#include <linux/proc_fs.h>
+#include <linux/rtc.h>
+#include <linux/async.h>
+
+#include <soc/oplus/device_info.h>
+
+#include "ufs-oplus-dbg.h"
+#ifdef CONFIG_OPLUS_QCOM_UFS_DRIVER
+#include "../../../../../ufs/host/ufs-qcom.h"
+#endif /* CONFIG_OPLUS_QCOM_UFS_DRIVER */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0))
+#ifdef CONFIG_OPLUS_QCOM_UFS_DRIVER
+#include "../../../../../ufs/core/ufshcd-priv.h"
+#endif /* CONFIG_OPLUS_QCOM_UFS_DRIVER */
+#include "ufshcd-priv.h"
+#else
+#ifdef CONFIG_OPLUS_QCOM_UFS_DRIVER
+#include <ufs/ufshcd-priv.h>
+#endif /* CONFIG_OPLUS_QCOM_UFS_DRIVER */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0))
+#define UFS_OPLUS_IOCTL_MAGIC 0xF5
+#define UFS_OPLUS_QUERY_IOCTL _IOWR(UFS_OPLUS_IOCTL_MAGIC, 0, int)
+#define UFS_OPLUS_MONITOR_IOCTL _IOWR(UFS_OPLUS_IOCTL_MAGIC, 1, int)
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
+
+struct unipro_signal_quality_ctrl signalCtrl;
+
+struct ufs_transmission_status_t ufs_transmission_status;
+struct device_attribute ufs_transmission_status_attr;
+
+#define ONE_DAY_SEC 86400
+static const char *ufs_null_device_strs = "nullnullnullnull";
+atomic_t ufs_init_done;
+
+int ufsplus_wb_status = 0;
+int ufsplus_hpb_status = 0;
+
+#ifdef CONFIG_OPLUS_QCOM_UFS_DRIVER
+extern int ufshcd_query_descriptor_retry(struct ufs_hba *hba,
+  				  enum query_opcode opcode,
+  				  enum desc_idn idn, u8 index,
+  				  u8 selector,
+  				  u8 *desc_buf, int *buf_len);
+#endif
+static void recordTimeStamp(
+	struct signal_quality *record,
+	enum ufs_event_type type
+) {
+	ktime_t cur_time = ktime_get();
+	switch (type)
+	{
+	case UFS_EVT_PA_ERR:
+	case UFS_EVT_DL_ERR:
+	case UFS_EVT_NL_ERR:
+	case UFS_EVT_TL_ERR:
+	case UFS_EVT_DME_ERR:
+		if (STAMP_RECORD_MAX <= record->stamp_pos)
+			return;
+		if (0 == record->stamp_pos)
+			record->stamp[0] = cur_time;
+		else if (cur_time > (record->stamp[record->stamp_pos - 1] +
+				STAMP_MIN_INTERVAL))
+			record->stamp[record->stamp_pos++] = cur_time;
+		return;
+	default:
+		return;
+	}
+}
+
+void recordUniproErr(
+	struct unipro_signal_quality_ctrl *signalCtrl,
+	u32 reg,
+	enum ufs_event_type type
+) {
+	unsigned long err_bits;
+	int ec;
+	struct signal_quality *rec = &signalCtrl->record;
+	recordTimeStamp(rec, type);
+	switch (type)
+	{
+	case UFS_EVT_FATAL_ERR:
+		if (DEVICE_FATAL_ERROR & reg)
+			rec->ufs_device_err_cnt++;
+		if (CONTROLLER_FATAL_ERROR & reg)
+			rec->ufs_host_err_cnt++;
+		if (SYSTEM_BUS_FATAL_ERROR & reg)
+			rec->ufs_bus_err_cnt++;
+		if (CRYPTO_ENGINE_FATAL_ERROR & reg)
+			rec->ufs_crypto_err_cnt++;
+		break;
+	case UFS_EVT_LINK_STARTUP_FAIL:
+		if (UIC_LINK_LOST & reg)
+			rec->ufs_link_lost_cnt++;
+		break;
+	case UFS_EVT_PA_ERR:
+		err_bits = reg & UIC_PHY_ADAPTER_LAYER_ERROR_CODE_MASK;
+		for_each_set_bit(ec, &err_bits, UNIPRO_PA_ERR_MAX) {
+			rec->unipro_PA_err_total_cnt++;
+			rec->unipro_PA_err_cnt[ec]++;
+		}
+		break;
+	case UFS_EVT_DL_ERR:
+		err_bits = reg & UIC_DATA_LINK_LAYER_ERROR_CODE_MASK;
+		for_each_set_bit(ec, &err_bits, UNIPRO_DL_ERR_MAX) {
+			rec->unipro_DL_err_total_cnt++;
+			rec->unipro_DL_err_cnt[ec]++;
+		}
+		break;
+	case UFS_EVT_NL_ERR:
+		err_bits = reg & UIC_NETWORK_LAYER_ERROR_CODE_MASK;
+		for_each_set_bit(ec, &err_bits, UNIPRO_NL_ERR_MAX) {
+			rec->unipro_NL_err_total_cnt++;
+			rec->unipro_NL_err_cnt[ec]++;
+		}
+		break;
+	case UFS_EVT_TL_ERR:
+		err_bits = reg & UIC_TRANSPORT_LAYER_ERROR_CODE_MASK;
+		for_each_set_bit(ec, &err_bits, UNIPRO_TL_ERR_MAX) {
+			rec->unipro_TL_err_total_cnt++;
+			rec->unipro_TL_err_cnt[ec]++;
+		}
+		break;
+	case UFS_EVT_DME_ERR:
+		err_bits = reg & UIC_DME_ERROR_CODE_MASK;
+		for_each_set_bit(ec, &err_bits, UNIPRO_DME_ERR_MAX) {
+			rec->unipro_DME_err_total_cnt++;
+			rec->unipro_DME_err_cnt[ec]++;
+		}
+		break;
+	case UFS_EVT_ABORT:
+		rec->task_abort_cnt++;
+		break;
+	case UFS_EVT_HOST_RESET:
+		rec->host_reset_cnt++;
+		break;
+	case UFS_EVT_DEV_RESET:
+		rec->dev_reset_cnt++;
+		break;
+	default:
+		break;
+	}
+}
+
+#define SEQ_EASY_PRINT(x)   seq_printf(s, #x"\t%d\n", signalCtrl->record.x)
+#define SEQ_PA_PRINT(x)     \
+	seq_printf(s, #x"\t%d\n", signalCtrl->record.unipro_PA_err_cnt[x])
+#define SEQ_DL_PRINT(x)     \
+	seq_printf(s, #x"\t%d\n", signalCtrl->record.unipro_DL_err_cnt[x])
+#define SEQ_NL_PRINT(x)     \
+	seq_printf(s, #x"\t%d\n", signalCtrl->record.unipro_NL_err_cnt[x])
+#define SEQ_TL_PRINT(x)     \
+	seq_printf(s, #x"\t%d\n", signalCtrl->record.unipro_TL_err_cnt[x])
+#define SEQ_DME_PRINT(x)    \
+	seq_printf(s, #x"\t%d\n", signalCtrl->record.unipro_DME_err_cnt[x])
+#define SEQ_STAMP_PRINT(x)  \
+	seq_printf(s, #x"\t%lld\n", signalCtrl->record.stamp[x])
+
+#define SEQ_GEAR_PRINT(x)  \
+	seq_printf(s, #x"\t%d\n", signalCtrl->record.gear_err_cnt[x])
+
+static int record_read_func(struct seq_file *s, void *v)
+{
+	struct unipro_signal_quality_ctrl *signalCtrl =
+		(struct unipro_signal_quality_ctrl *)(s->private);
+	if (!signalCtrl)
+		return -EINVAL;
+	SEQ_EASY_PRINT(ufs_device_err_cnt);
+	SEQ_EASY_PRINT(ufs_host_err_cnt);
+	SEQ_EASY_PRINT(ufs_bus_err_cnt);
+	SEQ_EASY_PRINT(ufs_crypto_err_cnt);
+	SEQ_EASY_PRINT(ufs_link_lost_cnt);
+	SEQ_EASY_PRINT(task_abort_cnt);
+	SEQ_EASY_PRINT(host_reset_cnt);
+	SEQ_EASY_PRINT(dev_reset_cnt);
+	SEQ_EASY_PRINT(unipro_PA_err_total_cnt);
+	SEQ_PA_PRINT(UNIPRO_PA_LANE0_ERR_CNT);
+	SEQ_PA_PRINT(UNIPRO_PA_LANE1_ERR_CNT);
+	SEQ_PA_PRINT(UNIPRO_PA_LANE2_ERR_CNT);
+	SEQ_PA_PRINT(UNIPRO_PA_LANE3_ERR_CNT);
+	SEQ_PA_PRINT(UNIPRO_PA_LINE_RESET);
+	SEQ_EASY_PRINT(unipro_DL_err_total_cnt);
+	SEQ_DL_PRINT(UNIPRO_DL_NAC_RECEIVED);
+	SEQ_DL_PRINT(UNIPRO_DL_TCX_REPLAY_TIMER_EXPIRED);
+	SEQ_DL_PRINT(UNIPRO_DL_AFCX_REQUEST_TIMER_EXPIRED);
+	SEQ_DL_PRINT(UNIPRO_DL_FCX_PROTECTION_TIMER_EXPIRED);
+	SEQ_DL_PRINT(UNIPRO_DL_CRC_ERROR);
+	SEQ_DL_PRINT(UNIPRO_DL_RX_BUFFER_OVERFLOW);
+	SEQ_DL_PRINT(UNIPRO_DL_MAX_FRAME_LENGTH_EXCEEDED);
+	SEQ_DL_PRINT(UNIPRO_DL_WRONG_SEQUENCE_NUMBER);
+	SEQ_DL_PRINT(UNIPRO_DL_AFC_FRAME_SYNTAX_ERROR);
+	SEQ_DL_PRINT(UNIPRO_DL_NAC_FRAME_SYNTAX_ERROR);
+	SEQ_DL_PRINT(UNIPRO_DL_EOF_SYNTAX_ERROR);
+	SEQ_DL_PRINT(UNIPRO_DL_FRAME_SYNTAX_ERROR);
+	SEQ_DL_PRINT(UNIPRO_DL_BAD_CTRL_SYMBOL_TYPE);
+	SEQ_DL_PRINT(UNIPRO_DL_PA_INIT_ERROR);
+	SEQ_DL_PRINT(UNIPRO_DL_PA_ERROR_IND_RECEIVED);
+	SEQ_DL_PRINT(UNIPRO_DL_PA_INIT);
+	SEQ_EASY_PRINT(unipro_NL_err_total_cnt);
+	SEQ_NL_PRINT(UNIPRO_NL_UNSUPPORTED_HEADER_TYPE);
+	SEQ_NL_PRINT(UNIPRO_NL_BAD_DEVICEID_ENC);
+	SEQ_NL_PRINT(UNIPRO_NL_LHDR_TRAP_PACKET_DROPPING);
+	SEQ_EASY_PRINT(unipro_TL_err_total_cnt);
+	SEQ_TL_PRINT(UNIPRO_TL_UNSUPPORTED_HEADER_TYPE);
+	SEQ_TL_PRINT(UNIPRO_TL_UNKNOWN_CPORTID);
+	SEQ_TL_PRINT(UNIPRO_TL_NO_CONNECTION_RX);
+	SEQ_TL_PRINT(UNIPRO_TL_CONTROLLED_SEGMENT_DROPPING);
+	SEQ_TL_PRINT(UNIPRO_TL_BAD_TC);
+	SEQ_TL_PRINT(UNIPRO_TL_E2E_CREDIT_OVERFLOW);
+	SEQ_TL_PRINT(UNIPRO_TL_SAFETY_VALVE_DROPPING);
+	SEQ_EASY_PRINT(unipro_DME_err_total_cnt);
+	SEQ_DME_PRINT(UNIPRO_DME_GENERIC);
+	SEQ_DME_PRINT(UNIPRO_DME_TX_QOS);
+	SEQ_DME_PRINT(UNIPRO_DME_RX_QOS);
+	SEQ_DME_PRINT(UNIPRO_DME_PA_INIT_QOS);
+	SEQ_GEAR_PRINT(UFS_HS_G1);
+	SEQ_GEAR_PRINT(UFS_HS_G2);
+	SEQ_GEAR_PRINT(UFS_HS_G3);
+	SEQ_GEAR_PRINT(UFS_HS_G4);
+	SEQ_GEAR_PRINT(UFS_HS_G5);
+	return 0;
+}
+
+static int record_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, record_read_func, pde_data(inode));
+}
+
+static const struct proc_ops record_fops = {
+	.proc_open = record_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+#define SEQ_UPLOAD_PRINT(x) \
+	seq_printf(s, #x": %d\n", signalCtrl->record.x \
+		-signalCtrl->record_upload.x);\
+	signalCtrl->record_upload.x = signalCtrl->record.x;
+#define SEQ_UPLOAD_STAMP_PRINT(x) \
+	seq_printf(s, #x": %lld\n", signalCtrl->record.stamp[x] \
+		-signalCtrl->record_upload.stamp[x]);\
+	signalCtrl->record_upload.stamp[x] = signalCtrl->record.stamp[x];
+
+#define SEQ_PA_UPLOAD_PRINT(x) \
+	seq_printf(s, #x": %d\n", signalCtrl->record.unipro_PA_err_cnt[x] \
+		-signalCtrl->record_upload.unipro_PA_err_cnt[x]);\
+	signalCtrl->record_upload.unipro_PA_err_cnt[x] = signalCtrl->record.unipro_PA_err_cnt[x];
+
+#define SEQ_DL_UPLOAD_PRINT(x) \
+		seq_printf(s, #x": %d\n", signalCtrl->record.unipro_DL_err_cnt[x] \
+			-signalCtrl->record_upload.unipro_DL_err_cnt[x]);\
+		signalCtrl->record_upload.unipro_DL_err_cnt[x] = signalCtrl->record.unipro_DL_err_cnt[x];
+
+#define SEQ_DL_UPLOAD_PRINT(x) \
+			seq_printf(s, #x": %d\n", signalCtrl->record.unipro_DL_err_cnt[x] \
+				-signalCtrl->record_upload.unipro_DL_err_cnt[x]);\
+			signalCtrl->record_upload.unipro_DL_err_cnt[x] = signalCtrl->record.unipro_DL_err_cnt[x];
+
+#define SEQ_NL_UPLOAD_PRINT(x) \
+				seq_printf(s, #x": %d\n", signalCtrl->record.unipro_NL_err_cnt[x] \
+					-signalCtrl->record_upload.unipro_NL_err_cnt[x]);\
+				signalCtrl->record_upload.unipro_NL_err_cnt[x] = signalCtrl->record.unipro_NL_err_cnt[x];
+
+#define SEQ_TL_UPLOAD_PRINT(x) \
+					seq_printf(s, #x": %d\n", signalCtrl->record.unipro_TL_err_cnt[x] \
+						-signalCtrl->record_upload.unipro_TL_err_cnt[x]);\
+					signalCtrl->record_upload.unipro_TL_err_cnt[x] = signalCtrl->record.unipro_TL_err_cnt[x];
+
+#define SEQ_DME_UPLOAD_PRINT(x) \
+						seq_printf(s, #x": %d\n", signalCtrl->record.unipro_DME_err_cnt[x] \
+							-signalCtrl->record_upload.unipro_DME_err_cnt[x]);\
+						signalCtrl->record_upload.unipro_DME_err_cnt[x] = signalCtrl->record.unipro_DME_err_cnt[x];
+
+#define SEQ_GEAR_UPLOAD_PRINT(x) \
+						seq_printf(s, #x": %d\n", signalCtrl->record.gear_err_cnt[x] \
+							-signalCtrl->record_upload.gear_err_cnt[x]);\
+						signalCtrl->record_upload.gear_err_cnt[x] = signalCtrl->record.gear_err_cnt[x];
+
+static int record_upload_read_func(struct seq_file *s, void *v)
+{
+	struct unipro_signal_quality_ctrl *signalCtrl =
+		(struct unipro_signal_quality_ctrl *)(s->private);
+	if (!signalCtrl)
+		return -EINVAL;
+	SEQ_UPLOAD_PRINT(ufs_device_err_cnt);
+	SEQ_UPLOAD_PRINT(ufs_host_err_cnt);
+	SEQ_UPLOAD_PRINT(ufs_bus_err_cnt);
+	SEQ_UPLOAD_PRINT(ufs_crypto_err_cnt);
+	SEQ_UPLOAD_PRINT(ufs_link_lost_cnt);
+	SEQ_UPLOAD_PRINT(task_abort_cnt);
+	SEQ_UPLOAD_PRINT(host_reset_cnt);
+	SEQ_UPLOAD_PRINT(dev_reset_cnt);
+	SEQ_UPLOAD_PRINT(unipro_PA_err_total_cnt);
+	SEQ_UPLOAD_PRINT(unipro_DL_err_total_cnt);
+	SEQ_UPLOAD_PRINT(unipro_NL_err_total_cnt);
+	SEQ_UPLOAD_PRINT(unipro_TL_err_total_cnt);
+	SEQ_UPLOAD_PRINT(unipro_DME_err_total_cnt);
+	SEQ_PA_UPLOAD_PRINT(UNIPRO_PA_LANE0_ERR_CNT);
+	SEQ_PA_UPLOAD_PRINT(UNIPRO_PA_LANE1_ERR_CNT);
+	SEQ_PA_UPLOAD_PRINT(UNIPRO_PA_LANE2_ERR_CNT);
+	SEQ_PA_UPLOAD_PRINT(UNIPRO_PA_LANE3_ERR_CNT);
+	SEQ_PA_UPLOAD_PRINT(UNIPRO_PA_LINE_RESET);
+
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_NAC_RECEIVED);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_TCX_REPLAY_TIMER_EXPIRED);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_AFCX_REQUEST_TIMER_EXPIRED);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_FCX_PROTECTION_TIMER_EXPIRED);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_CRC_ERROR);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_RX_BUFFER_OVERFLOW);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_MAX_FRAME_LENGTH_EXCEEDED);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_WRONG_SEQUENCE_NUMBER);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_AFC_FRAME_SYNTAX_ERROR);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_NAC_FRAME_SYNTAX_ERROR);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_EOF_SYNTAX_ERROR);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_FRAME_SYNTAX_ERROR);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_BAD_CTRL_SYMBOL_TYPE);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_PA_INIT_ERROR);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_PA_ERROR_IND_RECEIVED);
+	SEQ_DL_UPLOAD_PRINT(UNIPRO_DL_PA_INIT);
+
+	SEQ_NL_UPLOAD_PRINT(UNIPRO_NL_UNSUPPORTED_HEADER_TYPE);
+	SEQ_NL_UPLOAD_PRINT(UNIPRO_NL_BAD_DEVICEID_ENC);
+	SEQ_NL_UPLOAD_PRINT(UNIPRO_NL_LHDR_TRAP_PACKET_DROPPING);
+
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_UNSUPPORTED_HEADER_TYPE);
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_UNKNOWN_CPORTID);
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_NO_CONNECTION_RX);
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_CONTROLLED_SEGMENT_DROPPING);
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_BAD_TC);
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_E2E_CREDIT_OVERFLOW);
+	SEQ_TL_UPLOAD_PRINT(UNIPRO_TL_SAFETY_VALVE_DROPPING);
+
+	SEQ_DME_UPLOAD_PRINT(UNIPRO_DME_GENERIC);
+	SEQ_DME_UPLOAD_PRINT(UNIPRO_DME_TX_QOS);
+	SEQ_DME_UPLOAD_PRINT(UNIPRO_DME_RX_QOS);
+	SEQ_DME_UPLOAD_PRINT(UNIPRO_DME_PA_INIT_QOS);
+
+	SEQ_GEAR_UPLOAD_PRINT(UFS_HS_G1);
+	SEQ_GEAR_UPLOAD_PRINT(UFS_HS_G2);
+	SEQ_GEAR_UPLOAD_PRINT(UFS_HS_G3);
+	SEQ_GEAR_UPLOAD_PRINT(UFS_HS_G4);
+	SEQ_GEAR_UPLOAD_PRINT(UFS_HS_G5);
+	return 0;
+}
+
+static int record_upload_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, record_upload_read_func, pde_data(inode));
+}
+
+static const struct proc_ops record_upload_fops = {
+	.proc_open = record_upload_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+int create_signal_quality_proc(struct unipro_signal_quality_ctrl *signalCtrl)
+{
+	struct proc_dir_entry *d_entry;
+	signalCtrl->ctrl_dir = proc_mkdir("ufs_signalShow", NULL);
+	if (!signalCtrl->ctrl_dir)
+		return -ENOMEM;
+	d_entry = proc_create_data("record", S_IRUGO, signalCtrl->ctrl_dir,
+			&record_fops, signalCtrl);
+	if (!d_entry)
+		return -ENOMEM;
+	d_entry = proc_create_data("record_upload", S_IRUGO, signalCtrl->ctrl_dir,
+			&record_upload_fops, signalCtrl);
+	if (!d_entry)
+		return -ENOMEM;
+	return 0;
+}
+
+void remove_signal_quality_proc(struct unipro_signal_quality_ctrl *signalCtrl)
+{
+	if (signalCtrl->ctrl_dir) {
+		remove_proc_entry("record", signalCtrl->ctrl_dir);
+		remove_proc_entry("record_upload", signalCtrl->ctrl_dir);
+	}
+	return;
+}
+
+void recordGearErr(struct unipro_signal_quality_ctrl *signalCtrl, struct ufs_hba *hba)
+{
+	struct ufs_pa_layer_attr *pwr_info = &hba->pwr_info;
+	u32 dev_gear = min_t(u32, pwr_info->gear_rx, pwr_info->gear_tx);
+
+	if (dev_gear > UFS_HS_G5)
+		return;
+
+	signalCtrl->record.gear_err_cnt[dev_gear]++;
+}
+
+void recordSignalerr(struct ufs_hba *hba, unsigned int val, enum ufs_event_type evt)
+{
+	recordUniproErr(&signalCtrl, val, evt);
+	recordGearErr(&signalCtrl, hba);
+}
+EXPORT_SYMBOL_GPL(recordSignalerr);
+
+int get_rtc_time(struct rtc_time *tm)
+{
+	struct rtc_device *rtc;
+	int rc = 0;
+
+	rtc = rtc_class_open("rtc0");
+	if (rtc == NULL)
+		return -1;
+
+	rc = rtc_read_time(rtc, tm);
+	if (rc)
+		goto close_time;
+
+	rc = rtc_valid_tm(tm);
+	if (rc)
+		goto close_time;
+
+close_time:
+	rtc_class_close(rtc);
+
+	return rc;
+}
+
+void ufs_active_time_get(struct ufs_hba *hba)
+{
+	struct rtc_time tm;
+	int rc = 0;
+	ufs_transmission_status.active_count++;
+	rc = get_rtc_time(&tm);
+	if (rc != 0) {
+		dev_err(hba->dev,"ufs_transmission_status: get_rtc_time failed\n");
+		return;
+	}
+	ufs_transmission_status.resume_timing = (tm.tm_hour * 3600 + tm.tm_min * 60 + tm.tm_sec);
+	if (ufs_transmission_status.resume_timing < ufs_transmission_status.suspend_timing) {
+		ufs_transmission_status.sleep_time += ((ufs_transmission_status.resume_timing
+			+ ONE_DAY_SEC) - ufs_transmission_status.suspend_timing);
+		return;
+	}
+	if(ufs_transmission_status.suspend_timing == 0)
+		return;
+
+	ufs_transmission_status.sleep_time += (ufs_transmission_status.resume_timing
+		- ufs_transmission_status.suspend_timing);
+	return;
+}
+EXPORT_SYMBOL_GPL(ufs_active_time_get);
+
+
+void ufs_sleep_time_get(struct ufs_hba *hba)
+{
+	struct rtc_time tm;
+	int rc = 0;
+	ufs_transmission_status.sleep_count++;
+	rc = get_rtc_time(&tm);
+	if (rc != 0) {
+		dev_err(hba->dev,"ufs_transmission_status: get_rtc_time failed\n");
+		return;
+	}
+	ufs_transmission_status.suspend_timing = (tm.tm_hour * 3600 + tm.tm_min * 60 + tm.tm_sec);
+	if (ufs_transmission_status.suspend_timing < ufs_transmission_status.resume_timing) {
+		ufs_transmission_status.active_time += ((ufs_transmission_status.suspend_timing
+			+ ONE_DAY_SEC) - ufs_transmission_status.resume_timing);
+		return;
+	}
+	if(ufs_transmission_status.resume_timing == 0)
+		return;
+
+	ufs_transmission_status.active_time += (ufs_transmission_status.suspend_timing
+		- ufs_transmission_status.resume_timing);
+	return;
+}
+EXPORT_SYMBOL_GPL(ufs_sleep_time_get);
+
+static void ufshcd_lrb_scsicmd_time_statistics(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)
+{
+	if (lrbp->cmd->cmnd[0] == WRITE_10 || lrbp->cmd->cmnd[0] == WRITE_16) {
+		if (hba->pwr_info.gear_tx == 1) {
+			ufs_transmission_status.gear_min_write_sec += blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd));
+			ufs_transmission_status.gear_min_write_us +=
+				ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+		}
+
+		if (hba->pwr_info.gear_tx == 3 || hba->pwr_info.gear_tx == 4) {
+			ufs_transmission_status.gear_max_write_sec += blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd));
+			ufs_transmission_status.gear_max_write_us +=
+				ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+		}
+	} else if (lrbp->cmd->cmnd[0] == READ_10 || lrbp->cmd->cmnd[0] == READ_16) {
+		if (hba->pwr_info.gear_rx == 1) {
+			ufs_transmission_status.gear_min_read_sec += blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd));
+			ufs_transmission_status.gear_min_read_us +=
+				ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+		}
+
+		if (hba->pwr_info.gear_rx == 3 || hba->pwr_info.gear_rx == 4) {
+			ufs_transmission_status.gear_max_read_sec += blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd));
+			ufs_transmission_status.gear_max_read_us +=
+				ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+		}
+	} else {
+		if (hba->pwr_info.gear_rx == 1) {
+			ufs_transmission_status.gear_min_other_sec += blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd));
+			ufs_transmission_status.gear_min_other_us += ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+		}
+
+		if (hba->pwr_info.gear_rx == 3 || hba->pwr_info.gear_rx == 4) {
+			ufs_transmission_status.gear_max_other_sec += blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd));
+			ufs_transmission_status.gear_max_other_us += ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+		}
+	}
+
+	return;
+}
+
+static void ufshcd_lrb_devcmd_time_statistics(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)
+{
+	if (hba->pwr_info.gear_tx == 1) {
+		ufs_transmission_status.gear_min_dev_us +=
+			ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+	}
+
+	if (hba->pwr_info.gear_tx == 3 || hba->pwr_info.gear_tx == 4) {
+		ufs_transmission_status.gear_max_dev_us +=
+			ktime_us_delta(lrbp->compl_time_stamp, lrbp->issue_time_stamp);
+	}
+}
+
+void ufs_send_cmd_handle(void *data, struct ufs_hba *hba, struct ufshcd_lrb *lrbp)
+{
+	if (ufs_transmission_status.transmission_status_enable) {
+		if(lrbp->cmd) {
+			ufs_transmission_status.scsi_send_count++;
+		} else {
+			ufs_transmission_status.dev_cmd_count++;
+		}
+	}
+}
+
+void ufs_compl_cmd_handle(void *data, struct ufs_hba *hba, struct ufshcd_lrb *lrbp)
+{
+	if (lrbp->cmd) {
+		if (ufs_transmission_status.transmission_status_enable) {
+			lrbp->compl_time_stamp = ktime_get();
+			ufshcd_lrb_scsicmd_time_statistics(hba, lrbp);
+		}
+	} else if (lrbp->command_type == UTP_CMD_TYPE_DEV_MANAGE ||
+			lrbp->command_type == UTP_CMD_TYPE_UFS_STORAGE) {
+		if (ufs_transmission_status.transmission_status_enable) {
+			ufshcd_lrb_devcmd_time_statistics(hba, lrbp);
+		}
+	}
+}
+
+static ssize_t ufshcd_transmission_status_data_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE,
+					"transmission_status_enable:%u\n"
+					"gear_min_write_sec:%llu\n"
+					"gear_max_write_sec:%llu\n"
+					"gear_min_read_sec:%llu\n"
+					"gear_max_read_sec:%llu\n"
+					"gear_min_write_us:%llu\n"
+					"gear_max_write_us:%llu\n"
+					"gear_min_read_us:%llu\n"
+					"gear_max_read_us:%llu\n"
+					"gear_min_dev_us:%llu\n"
+					"gear_max_dev_us:%llu\n"
+					"gear_min_other_sec:%llu\n"
+					"gear_max_other_sec:%llu\n"
+					"gear_min_other_us:%llu\n"
+					"gear_max_other_us:%llu\n"
+					"scsi_send_count:%llu\n"
+					"dev_cmd_count:%llu\n"
+					"active_count:%llu\n"
+					"active_time:%llu\n"
+					"sleep_count:%llu\n"
+					"sleep_time:%llu\n"
+					"powerdown_count:%llu\n"
+					"powerdown_time:%llu\n"
+					"power_total_count:%llu\n"
+					"current_pwr_mode:%u\n",
+					ufs_transmission_status.transmission_status_enable,
+					ufs_transmission_status.gear_min_write_sec,
+					ufs_transmission_status.gear_max_write_sec,
+					ufs_transmission_status.gear_min_read_sec,
+					ufs_transmission_status.gear_max_read_sec,
+					ufs_transmission_status.gear_min_write_us,
+					ufs_transmission_status.gear_max_write_us,
+					ufs_transmission_status.gear_min_read_us,
+					ufs_transmission_status.gear_max_read_us,
+					ufs_transmission_status.gear_min_dev_us,
+					ufs_transmission_status.gear_max_dev_us,
+					ufs_transmission_status.gear_min_other_sec,
+					ufs_transmission_status.gear_max_other_sec,
+					ufs_transmission_status.gear_min_other_us,
+					ufs_transmission_status.gear_max_other_us,
+					ufs_transmission_status.scsi_send_count,
+					ufs_transmission_status.dev_cmd_count,
+					ufs_transmission_status.active_count,
+					ufs_transmission_status.active_time,
+					ufs_transmission_status.sleep_count,
+					ufs_transmission_status.sleep_time,
+					ufs_transmission_status.powerdown_count,
+					ufs_transmission_status.powerdown_time,
+					ufs_transmission_status.power_total_count,
+					ufs_transmission_status.current_pwr_mode);
+}
+
+static ssize_t ufshcd_transmission_status_data_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 value;
+
+	if (kstrtou32(buf, 0, &value))
+		return -EINVAL;
+
+	value = !!value;
+
+	if (value) {
+		ufs_transmission_status.transmission_status_enable = 1;
+	} else {
+		ufs_transmission_status.transmission_status_enable = 0;
+		memset(&ufs_transmission_status, 0, sizeof(struct ufs_transmission_status_t));
+	}
+
+	return count;
+}
+
+static void ufshcd_transmission_status_init_sysfs(struct ufs_hba *hba)
+{
+	printk("tianwen: ufshcd_transmission_status_init_sysfs start\n");
+	ufs_transmission_status_attr.show = ufshcd_transmission_status_data_show;
+	ufs_transmission_status_attr.store = ufshcd_transmission_status_data_store;
+	sysfs_attr_init(&ufs_transmission_status_attr.attr);
+	ufs_transmission_status_attr.attr.name = "ufs_transmission_status";
+	ufs_transmission_status_attr.attr.mode = 0644;
+	if (device_create_file(hba->dev, &ufs_transmission_status_attr))
+		dev_err(hba->dev, "Failed to create sysfs for ufs_transmission_status_attr\n");
+
+	/*init the struct ufs_transmission_status*/
+	memset(&ufs_transmission_status, 0, sizeof(struct ufs_transmission_status_t));
+	ufs_transmission_status.transmission_status_enable = 1;
+}
+
+#ifdef CONFIG_SCSI_UFS_HPB
+static bool is_ufshpb_allowed(struct ufs_hba *hba)
+{
+	return !(hba->ufshpb_dev.hpb_disabled);
+}
+#else
+static bool is_ufshpb_allowed(struct ufs_hba *hba)
+{
+	pr_warn("ufshpb macro definition is not opened\n");
+	return false;
+}
+#endif /* CONFIG_SCSI_UFS_HPB */
+
+static void create_devinfo_ufs(void *data, async_cookie_t c)
+{
+	struct scsi_device *sdev = data;
+	static char temp_version[5] = {0};
+	static char vendor[9] = {0};
+	static char model[17] = {0};
+	int ret = 0;
+	struct ufs_hba *hba = NULL;
+
+	pr_info("get ufs device vendor/model/rev\n");
+	WARN_ON(!sdev);
+	strncpy(temp_version, sdev->rev, 4);
+	strncpy(vendor, sdev->vendor, 8);
+	strncpy(model, sdev->model, 16);
+
+	ret = register_device_proc("ufs_version", temp_version, vendor);
+
+	if (ret) {
+		pr_err("%s create ufs_version fail, ret=%d",__func__,ret);
+		return;
+	}
+
+	ret = register_device_proc("ufs", model, vendor);
+
+	if (ret) {
+		pr_err("%s create ufs fail, ret=%d",__func__,ret);
+	}
+
+	hba = shost_priv(sdev->host);
+	if (hba && ufshcd_is_wb_allowed(hba)) {
+		ufsplus_wb_status = 1;
+	}
+	if (hba && is_ufshpb_allowed(hba)) {
+		ufsplus_hpb_status = 1;
+	}
+	ret = register_device_proc_for_ufsplus("ufsplus_status", &ufsplus_hpb_status, &ufsplus_wb_status);
+	if (ret) {
+		pr_err("%s create , ret=%d",__func__,ret);
+	}
+
+}
+
+static int monitor_verify_command(unsigned char *cmd)
+{
+    if (cmd[0] != 0x3B && cmd[0] != 0x3C && cmd[0] != 0xC0)
+        return false;
+
+    return true;
+}
+
+/**
+ * ufs_ioctl_monitor - special cmd for memory monitor
+ * @hba: per-adapter instance
+ * @buf_user: user space buffer for ioctl data
+ * @return: 0 for success negative error code otherwise
+ *
+ */
+int ufs_ioctl_monitor(struct scsi_device *dev, void __user *buf_user)
+{
+	struct request_queue *q = dev->request_queue;
+	struct request *rq;
+	struct scsi_cmnd *req;
+	struct scsi_ioctl_command __user *sic = (struct scsi_ioctl_command __user *)buf_user;
+	int err;
+	unsigned int in_len, out_len, bytes, opcode, cmdlen;
+	char *buffer = NULL;
+
+	/*
+	 * get in an out lengths, verify they don't exceed a page worth of data
+	 */
+	if (get_user(in_len, &sic->inlen))
+		return -EFAULT;
+	if (get_user(out_len, &sic->outlen))
+		return -EFAULT;
+	if (in_len > PAGE_SIZE || out_len > PAGE_SIZE)
+		return -EINVAL;
+	if (get_user(opcode, sic->data))
+		return -EFAULT;
+
+	bytes = max(in_len, out_len);
+	if (bytes) {
+		buffer = kzalloc(bytes, GFP_NOIO | GFP_USER| __GFP_NOWARN);
+		if (!buffer)
+			return -ENOMEM;
+
+	}
+
+	rq = scsi_alloc_request(q, in_len ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);
+	if (IS_ERR(rq)) {
+		err = PTR_ERR(rq);
+		goto error_free_buffer;
+	}
+	req = blk_mq_rq_to_pdu(rq);
+
+	cmdlen = COMMAND_SIZE(opcode);
+	if (((VENDOR_SPECIFIC_CDB == opcode) && (0 == strncmp(dev->vendor, "SAMSUNG ", 8)))
+	         || ((READ_BUFFER == opcode) && (0 == strncmp(dev->vendor, "XBSTOR ", 7)))) {
+		cmdlen = 16;
+	}
+
+	/*
+	 * get command and data to send to device, if any
+	 */
+	err = -EFAULT;
+	req->cmd_len = cmdlen;
+	if (copy_from_user(req->cmnd, sic->data, cmdlen))
+		goto error;
+
+	if (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))
+		goto error;
+
+	if (!monitor_verify_command(req->cmnd))
+		goto error;
+
+	/* default.  possible overriden later */
+	req->retries = 5;
+
+	if (bytes) {
+		err = blk_rq_map_kern(q, rq, buffer, bytes, GFP_NOIO);
+		if (err)
+			goto error;
+	}
+	blk_execute_rq(rq, 0);
+
+#define OMAX_SB_LEN 16          /* For backward compatibility */
+	err = req->result & 0xff;	/* only 8 bit SCSI status */
+	if (err) {
+		if (req->sense_len && req->sense_buffer) {
+			bytes = (OMAX_SB_LEN > req->sense_len) ?
+				req->sense_len : OMAX_SB_LEN;
+			if (copy_to_user(sic->data, req->sense_buffer, bytes))
+				err = -EFAULT;
+		}
+	} else {
+		if (copy_to_user(sic->data, buffer, out_len))
+			err = -EFAULT;
+	}
+
+error:
+	blk_mq_free_request(rq);
+
+error_free_buffer:
+	kfree(buffer);
+
+	return err;
+}
+
+static void probe_android_vh_ufs_update_sdev(void *data, struct scsi_device *sdev)
+{
+	if (strcmp(sdev->model, ufs_null_device_strs) && atomic_inc_return(&ufs_init_done) == 1) {
+		async_schedule(create_devinfo_ufs, sdev);
+	}
+
+}
+
+static int oplus_ufs_regist_tracepoint(void)
+{
+	int rc;
+	printk("oplus ufs trace point init");
+	rc = register_trace_android_vh_ufs_send_command(ufs_send_cmd_handle, NULL);
+	if (rc != 0)
+		pr_err("register_trace_android_vh_ufs_send_command failed! rc=%d\n", rc);
+
+	rc = register_trace_android_vh_ufs_compl_command(ufs_compl_cmd_handle, NULL);
+	if (rc != 0)
+		pr_err("register_trace_android_vh_ufs_compl_command failed! rc=%d\n", rc);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
+	rc = register_trace_android_vh_ufs_update_sdev(probe_android_vh_ufs_update_sdev, NULL);
+	if (rc != 0)
+		pr_err("register_trace_android_vh_ufs_update_sdev failed! rc=%d\n", rc);
+#endif /*  */
+	return rc;
+}
+
+static void oplus_ufs_unregist_tracepoint(void)
+{
+	unregister_trace_android_vh_ufs_send_command(ufs_send_cmd_handle, NULL);
+	unregister_trace_android_vh_ufs_compl_command(ufs_compl_cmd_handle, NULL);
+	unregister_trace_android_vh_ufs_update_sdev(probe_android_vh_ufs_update_sdev, NULL);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)) || defined(CONFIG_OPLUS_QCOM_UFS_DRIVER)
+/**
+ * ufs_oplus_query_ioctl - perform user read queries
+ * @hba: per-adapter instance
+ * @lun: used for lun specific queries
+ * @buffer: user space buffer for reading and submitting query data and params
+ * @return: 0 for success negative error code otherwise
+ *
+ * Expected/Submitted buffer structure is struct ufs_ioctl_query_data.
+ * It will read the opcode, idn and buf_length parameters, and, put the
+ * response in the buffer field while updating the used size in buf_length.
+ */
+static int
+ufs_oplus_query_ioctl(struct ufs_hba *hba, u8 lun, void __user *buffer)
+{
+	struct ufs_ioctl_query_data *ioctl_data;
+	int err = 0;
+	int length = 0;
+	void *data_ptr;
+	bool flag;
+	u32 att;
+	u8 index;
+	u8 *desc = NULL;
+
+	ioctl_data = kzalloc(sizeof(*ioctl_data), GFP_KERNEL);
+	if (!ioctl_data) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* extract params from user buffer */
+	err = copy_from_user(ioctl_data, buffer,
+			     sizeof(struct ufs_ioctl_query_data));
+	if (err) {
+		dev_err(hba->dev,
+			"%s: Failed copying buffer from user, err %d\n",
+			__func__, err);
+		goto out_release_mem;
+	}
+
+	/* verify legal parameters & send query */
+	switch (ioctl_data->opcode) {
+	case UPIU_QUERY_OPCODE_READ_DESC:
+		switch (ioctl_data->idn) {
+		case QUERY_DESC_IDN_DEVICE:
+		case QUERY_DESC_IDN_CONFIGURATION:
+		case QUERY_DESC_IDN_INTERCONNECT:
+		case QUERY_DESC_IDN_GEOMETRY:
+		case QUERY_DESC_IDN_POWER:
+		case QUERY_DESC_IDN_HEALTH:
+			index = 0;
+			break;
+		case QUERY_DESC_IDN_UNIT:
+			if (!ufs_is_valid_unit_desc_lun(&hba->dev_info, lun)) {
+				dev_err(hba->dev,
+					"%s: No unit descriptor for lun 0x%x\n",
+					__func__, lun);
+				err = -EINVAL;
+				goto out_release_mem;
+			}
+			index = lun;
+			break;
+		default:
+			goto out_einval;
+		}
+		length = min_t(int, QUERY_DESC_MAX_SIZE,
+			       ioctl_data->buf_size);
+		desc = kzalloc(length, GFP_KERNEL);
+		if (!desc) {
+			dev_err(hba->dev, "%s: Failed allocating %d bytes\n",
+				__func__, length);
+			err = -ENOMEM;
+			goto out_release_mem;
+		}
+		err = ufshcd_query_descriptor_retry(hba, ioctl_data->opcode,
+						    ioctl_data->idn, index, 0,
+						    desc, &length);
+		break;
+	case UPIU_QUERY_OPCODE_READ_ATTR:
+		switch (ioctl_data->idn) {
+		case QUERY_ATTR_IDN_BOOT_LU_EN:
+		case QUERY_ATTR_IDN_POWER_MODE:
+		case QUERY_ATTR_IDN_ACTIVE_ICC_LVL:
+		case QUERY_ATTR_IDN_OOO_DATA_EN:
+		case QUERY_ATTR_IDN_BKOPS_STATUS:
+		case QUERY_ATTR_IDN_PURGE_STATUS:
+		case QUERY_ATTR_IDN_MAX_DATA_IN:
+		case QUERY_ATTR_IDN_MAX_DATA_OUT:
+		case QUERY_ATTR_IDN_REF_CLK_FREQ:
+		case QUERY_ATTR_IDN_CONF_DESC_LOCK:
+		case QUERY_ATTR_IDN_MAX_NUM_OF_RTT:
+		case QUERY_ATTR_IDN_EE_CONTROL:
+		case QUERY_ATTR_IDN_EE_STATUS:
+		case QUERY_ATTR_IDN_SECONDS_PASSED:
+			index = 0;
+			break;
+		case QUERY_ATTR_IDN_DYN_CAP_NEEDED:
+		case QUERY_ATTR_IDN_CORR_PRG_BLK_NUM:
+			index = lun;
+			break;
+		default:
+			goto out_einval;
+		}
+		err = ufshcd_query_attr(hba, ioctl_data->opcode,
+					ioctl_data->idn, index, 0, &att);
+		break;
+
+	case UPIU_QUERY_OPCODE_WRITE_ATTR:
+		err = copy_from_user(&att,
+				     buffer +
+				     sizeof(struct ufs_ioctl_query_data),
+				     sizeof(u32));
+		if (err) {
+			dev_err(hba->dev,
+				"%s: Failed copying buffer from user, err %d\n",
+				__func__, err);
+			goto out_release_mem;
+		}
+
+		switch (ioctl_data->idn) {
+		case QUERY_ATTR_IDN_BOOT_LU_EN:
+			index = 0;
+			if (!att) {
+				dev_err(hba->dev,
+					"%s: Illegal ufs query ioctl data, opcode 0x%x, idn 0x%x, att 0x%x\n",
+					__func__, ioctl_data->opcode,
+					(unsigned int)ioctl_data->idn, att);
+				err = -EINVAL;
+				goto out_release_mem;
+			}
+			break;
+		default:
+			goto out_einval;
+		}
+		err = ufshcd_query_attr(hba, ioctl_data->opcode,
+					ioctl_data->idn, index, 0, &att);
+		break;
+
+	case UPIU_QUERY_OPCODE_READ_FLAG:
+		switch (ioctl_data->idn) {
+		case QUERY_FLAG_IDN_FDEVICEINIT:
+		case QUERY_FLAG_IDN_PERMANENT_WPE:
+		case QUERY_FLAG_IDN_PWR_ON_WPE:
+		case QUERY_FLAG_IDN_BKOPS_EN:
+		case QUERY_FLAG_IDN_PURGE_ENABLE:
+		case QUERY_FLAG_IDN_FPHYRESOURCEREMOVAL:
+		case QUERY_FLAG_IDN_BUSY_RTC:
+			break;
+		default:
+			goto out_einval;
+		}
+		err = ufshcd_query_flag(hba, ioctl_data->opcode,
+					ioctl_data->idn, 0, &flag);
+		break;
+	default:
+		goto out_einval;
+	}
+
+	if (err) {
+		dev_err(hba->dev, "%s: Query for idn %d failed\n", __func__,
+			ioctl_data->idn);
+		goto out_release_mem;
+	}
+
+	/*
+	 * copy response data
+	 * As we might end up reading less data than what is specified in
+	 * "ioctl_data->buf_size". So we are updating "ioctl_data->
+	 * buf_size" to what exactly we have read.
+	 */
+	switch (ioctl_data->opcode) {
+	case UPIU_QUERY_OPCODE_READ_DESC:
+		ioctl_data->buf_size = min_t(int, ioctl_data->buf_size, length);
+		data_ptr = desc;
+		break;
+	case UPIU_QUERY_OPCODE_READ_ATTR:
+		ioctl_data->buf_size = sizeof(u32);
+		data_ptr = &att;
+		break;
+	case UPIU_QUERY_OPCODE_READ_FLAG:
+		ioctl_data->buf_size = 1;
+		data_ptr = &flag;
+		break;
+	case UPIU_QUERY_OPCODE_WRITE_ATTR:
+		goto out_release_mem;
+	default:
+		goto out_einval;
+	}
+
+	/* copy to user */
+	err = copy_to_user(buffer, ioctl_data,
+			   sizeof(struct ufs_ioctl_query_data));
+	if (err)
+		dev_err(hba->dev, "%s: Failed copying back to user.\n",
+			__func__);
+	err = copy_to_user(buffer + sizeof(struct ufs_ioctl_query_data),
+			   data_ptr, ioctl_data->buf_size);
+	if (err)
+		dev_err(hba->dev, "%s: err %d copying back to user.\n",
+			__func__, err);
+	goto out_release_mem;
+
+out_einval:
+	dev_err(hba->dev,
+		"%s: illegal ufs query ioctl data, opcode 0x%x, idn 0x%x\n",
+		__func__, ioctl_data->opcode, (unsigned int)ioctl_data->idn);
+	err = -EINVAL;
+out_release_mem:
+	kfree(ioctl_data);
+	kfree(desc);
+out:
+	return err;
+}
+
+
+static int
+ufs_oplus_ioctl(struct scsi_device *dev, unsigned int cmd, void __user *buffer)
+{
+	struct ufs_hba *hba = shost_priv(dev->host);
+	int err = 0;
+
+	if (!hba)
+		return -ENOTTY;
+	if (!buffer) {
+		dev_err(hba->dev, "%s: User buffer is NULL!\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	case UFS_IOCTL_QUERY:
+		down(&hba->host_sem);
+		if (!ufshcd_is_user_access_allowed(hba)) {
+			up(&hba->host_sem);
+			err = -EBUSY;
+			goto err_out;
+		}
+		ufshcd_rpm_get_sync(hba);
+		err = ufs_oplus_query_ioctl(hba,
+					   ufshcd_scsi_to_upiu_lun(dev->lun),
+					   buffer);
+		ufshcd_rpm_put_sync(hba);
+		up(&hba->host_sem);
+	break;
+	case UFS_IOCTL_MONITOR:
+		ufshcd_rpm_get_sync(hba);
+		err = ufs_ioctl_monitor(dev, buffer);
+		ufshcd_rpm_put_sync(hba);
+	break;
+	default:
+		err = -ENOIOCTLCMD;
+		dev_err(hba->dev, "%s: Unsupported ioctl cmd %d\n", __func__,
+			cmd);
+	break;
+	}
+
+err_out:
+	return err;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) || defined(CONFIG_OPLUS_QCOM_UFS_DRIVER) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0))
+static void ufs_update_sdev(struct scsi_device *sdev)
+{
+	async_schedule(create_devinfo_ufs, sdev);
+}
+
+static long ufs_common_oplus_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct scsi_device *dev = pde_data(file_inode(filp));
+	long err = 0;
+
+	if (dev == NULL)
+		return -ENOTTY;
+
+	if (_IOC_TYPE(cmd) != UFS_OPLUS_IOCTL_MAGIC)
+		return -ENOTTY;
+
+	switch (cmd)
+	{
+		case UFS_OPLUS_QUERY_IOCTL:
+			err = ufs_oplus_ioctl(dev, UFS_IOCTL_QUERY, (void *)arg);
+		break;
+		case UFS_OPLUS_MONITOR_IOCTL:
+			err = ufs_oplus_ioctl(dev, UFS_IOCTL_MONITOR, (void *)arg);
+		break;
+	}
+	return err;
+}
+
+static struct proc_ops proc_ioctl_fops = {
+	.proc_ioctl = ufs_common_oplus_ioctl,
+};
+
+static void ufs_oplus_ioctl_init(struct scsi_device *sdev) {
+	struct proc_dir_entry *oplus_ufs_proc_dir = proc_mkdir("ufs_oplus_dir", NULL);
+	struct proc_dir_entry *d_entry;
+
+	if (!oplus_ufs_proc_dir)
+		return;
+
+	d_entry = proc_create_data("ufs_oplus_ioctl", 0644, oplus_ufs_proc_dir, &proc_ioctl_fops, sdev);
+	if (!d_entry)
+		return;
+	return;
+}
+
+void ufs_oplus_init_sdev(struct scsi_device *sdev) {
+	if (scsi_is_wlun(sdev->lun))
+            return;
+
+	if (atomic_inc_return(&ufs_init_done) == 1) {
+        	ufs_update_sdev(sdev);
+		ufs_oplus_ioctl_init(sdev);
+	}
+}
+EXPORT_SYMBOL_GPL(ufs_oplus_init_sdev);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
+
+void ufs_init_oplus_dbg(struct ufs_hba *hba)
+{
+	oplus_ufs_regist_tracepoint();
+	ufshcd_transmission_status_init_sysfs(hba);
+	create_signal_quality_proc(&signalCtrl);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
+#ifdef CONFIG_OPLUS_QCOM_UFS_DRIVER
+	hba->host->hostt->ioctl = (int (*)(struct scsi_device *, unsigned int,
+				   void __user *))ufs_oplus_ioctl;
+#ifdef CONFIG_COMPAT
+	hba->host->hostt->compat_ioctl = (int (*)(struct scsi_device *,
+					  unsigned int,
+					  void __user *))ufs_oplus_ioctl;
+#endif /* CONFIG_COMPAT */
+#endif /* CONFIG_OPLUS_QCOM_UFS_DRIVER */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
+}
+EXPORT_SYMBOL_GPL(ufs_init_oplus_dbg);
+
+void ufs_remove_oplus_dbg(void)
+{
+	oplus_ufs_unregist_tracepoint();
+	remove_signal_quality_proc(&signalCtrl);
+}
+EXPORT_SYMBOL_GPL(ufs_remove_oplus_dbg);
+
+
+static void __exit ufs_oplus_dbg_exit(void)
+{
+	return;
+}
+
+static int __init ufs_oplus_dbg_init(void)
+{
+	atomic_set(&ufs_init_done, 0);
+	return 0;
+}
+
+module_init(ufs_oplus_dbg_init)
+module_exit(ufs_oplus_dbg_exit)
+
+MODULE_DESCRIPTION("Oplus UFS Debugging Facility");
+MODULE_AUTHOR("oplus");
+MODULE_LICENSE("GPL v2");
+
+
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.h b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.h
new file mode 100644
index 000000000..14cef8726
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/ufs_oplus_dbg/ufs-oplus-dbg.h
@@ -0,0 +1,209 @@
+#ifndef _UFS_OPLUS_DBG_H
+#define _UFS_OPLUS_DBG_H
+
+#include <linux/reset-controller.h>
+#include <linux/reset.h>
+#include <linux/phy/phy.h>
+#include <linux/pm_qos.h>
+#include <linux/notifier.h>
+#include <linux/panic_notifier.h>
+#include <linux/version.h>
+#include <ufs/ufshcd.h>
+#include <ufs/unipro.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) || defined(CONFIG_OPLUS_QCOM_UFS_DRIVER)
+#define UFS_IOCTL_QUERY			0x5388
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) || defined(CONFIG_OPLUS_QCOM_UFS_DRIVER) */
+#define UFS_IOCTL_MONITOR               0x5392  /* For monitor access */
+
+/*define ufs uic error code*/
+enum unipro_pa_errCode {
+	UNIPRO_PA_LANE0_ERR_CNT,
+	UNIPRO_PA_LANE1_ERR_CNT,
+	UNIPRO_PA_LANE2_ERR_CNT,
+	UNIPRO_PA_LANE3_ERR_CNT,
+	UNIPRO_PA_LINE_RESET,
+	UNIPRO_PA_ERR_MAX
+};
+
+enum unipro_dl_errCode {
+	UNIPRO_DL_NAC_RECEIVED,
+	UNIPRO_DL_TCX_REPLAY_TIMER_EXPIRED,
+	UNIPRO_DL_AFCX_REQUEST_TIMER_EXPIRED,
+	UNIPRO_DL_FCX_PROTECTION_TIMER_EXPIRED,
+	UNIPRO_DL_CRC_ERROR,
+	UNIPRO_DL_RX_BUFFER_OVERFLOW,
+	UNIPRO_DL_MAX_FRAME_LENGTH_EXCEEDED,
+	UNIPRO_DL_WRONG_SEQUENCE_NUMBER,
+	UNIPRO_DL_AFC_FRAME_SYNTAX_ERROR,
+	UNIPRO_DL_NAC_FRAME_SYNTAX_ERROR,
+	UNIPRO_DL_EOF_SYNTAX_ERROR,
+	UNIPRO_DL_FRAME_SYNTAX_ERROR,
+	UNIPRO_DL_BAD_CTRL_SYMBOL_TYPE,
+	UNIPRO_DL_PA_INIT_ERROR,
+	UNIPRO_DL_PA_ERROR_IND_RECEIVED,
+	UNIPRO_DL_PA_INIT,
+	UNIPRO_DL_ERR_MAX
+};
+
+enum unipro_nl_errCode {
+	UNIPRO_NL_UNSUPPORTED_HEADER_TYPE,
+	UNIPRO_NL_BAD_DEVICEID_ENC,
+	UNIPRO_NL_LHDR_TRAP_PACKET_DROPPING,
+	UNIPRO_NL_ERR_MAX
+};
+
+enum unipro_tl_errCode {
+	UNIPRO_TL_UNSUPPORTED_HEADER_TYPE,
+	UNIPRO_TL_UNKNOWN_CPORTID,
+	UNIPRO_TL_NO_CONNECTION_RX,
+	UNIPRO_TL_CONTROLLED_SEGMENT_DROPPING,
+	UNIPRO_TL_BAD_TC,
+	UNIPRO_TL_E2E_CREDIT_OVERFLOW,
+	UNIPRO_TL_SAFETY_VALVE_DROPPING,
+	UNIPRO_TL_ERR_MAX
+};
+
+enum unipro_dme_errCode {
+	UNIPRO_DME_GENERIC,
+	UNIPRO_DME_TX_QOS,
+	UNIPRO_DME_RX_QOS,
+	UNIPRO_DME_PA_INIT_QOS,
+	UNIPRO_DME_ERR_MAX
+};
+
+enum unipro_err_time_stamp {
+	UNIPRO_0_STAMP,
+	UNIPRO_1_STAMP,
+	UNIPRO_2_STAMP,
+	UNIPRO_3_STAMP,
+	UNIPRO_4_STAMP,
+	UNIPRO_5_STAMP,
+	UNIPRO_6_STAMP,
+	UNIPRO_7_STAMP,
+	UNIPRO_8_STAMP,
+	UNIPRO_9_STAMP,
+	STAMP_RECORD_MAX
+};
+#define STAMP_MIN_INTERVAL ((ktime_t)600000000000) /*ns, 10min*/
+
+struct signal_quality {
+	u32 ufs_device_err_cnt;
+	u32 ufs_host_err_cnt;
+	u32 ufs_bus_err_cnt;
+	u32 ufs_crypto_err_cnt;
+	u32 ufs_link_lost_cnt;
+	u32 task_abort_cnt;
+	u32 host_reset_cnt;
+	u32 dev_reset_cnt;
+	u32 unipro_PA_err_total_cnt;
+	u32 unipro_PA_err_cnt[UNIPRO_PA_ERR_MAX];
+	u32 unipro_DL_err_total_cnt;
+	u32 unipro_DL_err_cnt[UNIPRO_DL_ERR_MAX];
+	u32 unipro_NL_err_total_cnt;
+	u32 unipro_NL_err_cnt[UNIPRO_NL_ERR_MAX];
+	u32 unipro_TL_err_total_cnt;
+	u32 unipro_TL_err_cnt[UNIPRO_TL_ERR_MAX];
+	u32 unipro_DME_err_total_cnt;
+	u32 unipro_DME_err_cnt[UNIPRO_DME_ERR_MAX];
+	u32 gear_err_cnt[UFS_HS_G5 + 1];
+	/* first 10 error cnt, interval is 10min at least */
+	ktime_t stamp[STAMP_RECORD_MAX];
+	int stamp_pos;
+};
+
+struct unipro_signal_quality_ctrl {
+	struct proc_dir_entry *ctrl_dir;
+	struct signal_quality record;
+	struct signal_quality record_upload;
+};
+
+struct ufs_transmission_status_t
+{
+	u8  transmission_status_enable;
+
+	u64 gear_min_write_sec;
+	u64 gear_max_write_sec;
+	u64 gear_min_read_sec;
+	u64 gear_max_read_sec;
+
+	u64 gear_min_write_us;
+	u64 gear_max_write_us;
+	u64 gear_min_read_us;
+	u64 gear_max_read_us;
+
+	u64 gear_min_dev_us;
+	u64 gear_max_dev_us;
+
+	u64 gear_min_other_sec;
+	u64 gear_max_other_sec;
+	u64 gear_min_other_us;
+	u64 gear_max_other_us;
+
+	u64 scsi_send_count;
+	u64 dev_cmd_count;
+
+	u64 active_count;
+	u64 active_time;
+	u64 resume_timing;
+
+	u64 sleep_count;
+	u64 sleep_time;
+	u64 suspend_timing;
+
+	u64 powerdown_count;
+	u64 powerdown_time;
+
+	u64 power_total_count;
+	u32 current_pwr_mode;
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+#ifndef CONFIG_OPLUS_QCOM_UFS_DRIVER
+struct ufs_ioctl_query_data {
+ 	/*
+	 * User should select one of the opcode defined in "enum query_opcode".
+	 * Please check include/uapi/scsi/ufs/ufs.h for the definition of it.
+	 * Note that only UPIU_QUERY_OPCODE_READ_DESC,
+	 * UPIU_QUERY_OPCODE_READ_ATTR & UPIU_QUERY_OPCODE_READ_FLAG are
+	 * supported as of now. All other query_opcode would be considered
+	 * invalid.
+ 	 * As of now only read query operations are supported.
+	 */
+	__u32 opcode;
+	/*
+	 * User should select one of the idn from "enum flag_idn" or "enum
+	 * attr_idn" or "enum desc_idn" based on whether opcode above is
+	 * attribute, flag or descriptor.
+	 * Please check include/uapi/scsi/ufs/ufs.h for the definition of it.
+	 */
+	__u8 idn;
+	/*
+	 * User should specify the size of the buffer (buffer[0] below) where
+	 * it wants to read the query data (attribute/flag/descriptor).
+ 	 * As we might end up reading less data then what is specified in
+	 * buf_size. So we are updating buf_size to what exactly we have read.
+	 */
+	__u16 buf_size;
+	/*
+	 * placeholder for the start of the data buffer where kernel will copy
+	 * the query data (attribute/flag/descriptor) read from the UFS device
+	 * Note:
+	 * For Read/Write Attribute you will have to allocate 4 bytes
+	 * For Read/Write Flag you will have to allocate 1 byte
+	 */
+	__u8 buffer[0];
+};
+#endif
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
+
+void ufs_active_time_get(struct ufs_hba *hba);
+void ufs_sleep_time_get(struct ufs_hba *hba);
+void recordSignalerr(struct ufs_hba *hba, unsigned int val, enum ufs_event_type evt);
+void ufs_init_oplus_dbg(struct ufs_hba *hba);
+void ufs_remove_oplus_dbg(void);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+void ufs_oplus_init_sdev(struct scsi_device *sdev);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
+
+#endif /* !_UFS_OPLUS_DBG_H */
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Kconfig b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Kconfig
new file mode 100644
index 000000000..04032d19c
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Kconfig
@@ -0,0 +1,6 @@
+config OPLUS_FEATURE_WQ_DYNPRIO
+    tristate "workqueue dynamic priority"
+    default n
+    help
+      define this config to modify workqueue priority for gki.
+
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Makefile b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Makefile
new file mode 100644
index 000000000..87f24ade6
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# Copyright (C) 2024 Oplus. All rights reserved.
+
+LINUXINCLUDE += -I$(srctree)/
+obj-$(CONFIG_OPLUS_FEATURE_WQ_DYNPRIO) += oplus_wq_dynamic_priority.o
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.c b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.c
new file mode 100644
index 000000000..8c7ca8def
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.c
@@ -0,0 +1,236 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kprobes.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+
+#include <../kernel/oplus_cpu/sched/sched_assist/sa_common.h>
+#include "oplus_wq_dynamic_priority.h"
+
+#define WQ_UX    (1 << 14)
+
+#define VIRTUAL_KWORKER_NICE (-1000)
+
+/* ---------alloc_workqueue--------- */
+struct config_wq_flags {
+    char *target_str;
+    unsigned int new_flags;
+};
+
+static struct config_wq_flags oplus_wq_config[] = {
+    { "loop", WQ_UNBOUND | WQ_FREEZABLE | WQ_HIGHPRI | WQ_UX },
+    { "kverityd", WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_UX | WQ_UNBOUND },
+    // Add more strings and flags as needed.
+    { NULL, 0 } // Terminate array with NULL
+};
+
+static int handler_alloc_workqueue_pre(struct kprobe *p, struct pt_regs *regs)
+{
+    const char *fmt = (const char *)regs->regs[0];
+    unsigned int flags = (unsigned int)regs->regs[1];
+
+    struct config_wq_flags *item = oplus_wq_config;
+    if(fmt) {
+        while (item->target_str) {
+            if (!strncmp(fmt, item->target_str, strlen(item->target_str)) && (item->new_flags != flags)) {
+                printk(KERN_INFO "alloc_workqueue: matching fmt '%s', modifying flags from 0x%x to 0x%x\n", fmt, flags, item->new_flags);
+                regs->regs[1] = item->new_flags;
+                break;
+            }
+            item++;
+        }
+    }
+    return 0;
+}
+
+static struct kprobe oplus_alloc_workqueue_kp = {
+    .symbol_name = "alloc_workqueue",
+    .pre_handler = handler_alloc_workqueue_pre,
+};
+
+/* ---------alloc_unbound_pwq--------- */
+static int handler_alloc_unbound_pwq_pre(struct kprobe *p, struct pt_regs *regs)
+{
+    struct workqueue_struct *wq = (struct workqueue_struct *)regs->regs[0];
+    struct workqueue_attrs *attrs = (struct workqueue_attrs *)regs->regs[1];
+
+    int old_nice=0;
+
+    if (wq && (wq->flags & WQ_UX)) {
+        if (attrs) {
+            old_nice = attrs->nice;
+            if (old_nice != VIRTUAL_KWORKER_NICE) {
+                attrs->nice = VIRTUAL_KWORKER_NICE;
+                printk(KERN_INFO "alloc_unbound_pwq: modifying nice from %d to %d\n", old_nice, attrs->nice);
+            }
+        }
+    }
+    return 0;
+}
+
+static struct kprobe oplus_alloc_unbound_pwq_kp = {
+    .symbol_name = "alloc_unbound_pwq",
+    .pre_handler = handler_alloc_unbound_pwq_pre,
+};
+
+/* ---------apply_wqattrs_prepare--------- */
+static int handler_apply_wqattrs_ret(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+    struct apply_wqattrs_ctx *ctx = (struct apply_wqattrs_ctx *)regs_return_value(regs);
+    if (ctx && (ctx->wq) && (ctx->wq->flags & WQ_UX)) {
+        printk(KERN_INFO "apply_wqattrs_prepare: modifying nice from %d to %d\n", ctx->attrs->nice, VIRTUAL_KWORKER_NICE);
+        ctx->attrs->nice = VIRTUAL_KWORKER_NICE;
+    }
+    return 0;
+}
+
+static struct kretprobe oplus_apply_wqattrs_krp = {
+    .kp = {
+        .symbol_name = "apply_wqattrs_prepare",
+    },
+    .handler = handler_apply_wqattrs_ret,
+};
+
+/* ---------worker_attach_to_pool--------- */
+static int handler_worker_attach_to_pool_pre(struct kprobe *p, struct pt_regs *regs)
+{
+    struct worker *worker = (struct worker *)regs->regs[0];
+    struct worker_pool *pool = (struct worker_pool *)regs->regs[1];
+
+    if ((worker && worker->task) && (pool && pool->attrs)) {
+        if (pool->attrs->nice == VIRTUAL_KWORKER_NICE) {
+        #ifdef CONFIG_OPLUS_SYSTEM_KERNEL_QCOM
+            oplus_set_ux_state_lock(worker->task, SA_TYPE_LIGHT, -1, true);
+            printk(KERN_INFO "worker_attach_to_pool:comm:%s set UX and set nice to %d\n", worker->task->comm, MIN_NICE);
+        #else
+            sched_set_fifo_low(worker->task);
+            printk(KERN_INFO "worker_attach_to_pool:comm:%s set RT and set nice to %d\n", worker->task->comm, MIN_NICE);
+        #endif /* CONFIG_OPLUS_SYSTEM_KERNEL_QCOM */
+            set_user_nice(worker->task, MIN_NICE);
+        }
+    }
+    return 0;
+}
+
+static struct kprobe oplus_worker_attach_to_pool_kp = {
+    .symbol_name = "worker_attach_to_pool",
+    .pre_handler = handler_worker_attach_to_pool_pre,
+};
+
+
+/* ---------kblockd_schedule_work--------- */
+static struct workqueue_struct *oplus_kblockd_workqueue;
+static int handler_kblockd_schedule_work_pre(struct kprobe *p, struct pt_regs *regs) {
+    //printk(KERN_INFO "kblockd_schedule_work:use oplus kblockd workqueue\n");
+    regs->regs[1] = (u64)oplus_kblockd_workqueue;
+    return 0;
+}
+
+static int handler_kblockd_mod_delayed_work_on_pre(struct kprobe *p, struct pt_regs *regs) {
+    //printk(KERN_INFO "kblockd_mod_delayed_work_on:use oplus kblockd workqueue\n");
+    regs->regs[1] = (u64)oplus_kblockd_workqueue;
+    return 0;
+}
+
+static struct kprobe oplus_kblockd_schedule_work_kp = {
+    .symbol_name = "kblockd_schedule_work",
+    .offset = 0x1c,
+    .pre_handler = handler_kblockd_schedule_work_pre,
+};
+
+static struct kprobe oplus_kblockd_mod_delayed_work_on_kp = {
+    .symbol_name = "kblockd_mod_delayed_work_on",
+    .offset = 0x1c,
+    .pre_handler = handler_kblockd_mod_delayed_work_on_pre,
+};
+
+static bool kprobe_init_successful=false;
+static int __init oplus_wq_kprobe_init(void)
+{
+    int ret;
+
+    ret = register_kprobe(&oplus_alloc_workqueue_kp);
+    if (ret < 0) {
+        printk(KERN_ERR "register_kprobe alloc_workqueue failed, returned %d\n", ret);
+        goto kp_alloc_workqueue_fail;
+    }
+
+    ret = register_kprobe(&oplus_alloc_unbound_pwq_kp);
+    if (ret < 0) {
+        printk(KERN_ERR "register_kprobe alloc_unbound_pwq failed, returned %d\n", ret);
+        goto kp_alloc_unbound_pwq_fail;
+    }
+
+    ret = register_kretprobe(&oplus_apply_wqattrs_krp);
+    if (ret < 0) {
+        printk(KERN_ERR "register_kretprobe apply_wqattrs failed, returned %d\n", ret);
+        goto kp_apply_wqattrs_fail;
+    }
+
+    ret = register_kprobe(&oplus_worker_attach_to_pool_kp);
+    if (ret < 0) {
+        printk(KERN_ERR "register_kprobe worker_attach_to_pool failed, returned %d\n", ret);
+        goto kp_worker_attach_to_pool_fail;
+    }
+
+    oplus_kblockd_workqueue = alloc_workqueue("opluskblockd",WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_UX | WQ_UNBOUND, 0);
+
+    if (!oplus_kblockd_workqueue) {
+        printk(KERN_ERR "alloc  oplus_kblockd_workqueue fail!\n");
+        goto kp_kblockd_schedule_work_kp_fail;
+    }
+
+    ret = register_kprobe(&oplus_kblockd_schedule_work_kp);
+    if (ret < 0) {
+        printk(KERN_ERR "register_kprobe oplus_kblockd_schedule_work_kp failed, returned %d\n", ret);
+        goto kp_kblockd_schedule_work_kp_fail;
+    }
+
+    ret = register_kprobe(&oplus_kblockd_mod_delayed_work_on_kp);
+    if (ret < 0) {
+        printk(KERN_ERR "register_kprobe oplus_kblockd_mod_delayed_work_on_kp failed, returned %d\n", ret);
+        goto kp_kblockd_mod_delayed_work_on_kp_fail;
+    }
+
+    printk(KERN_ERR "%s successful!\n", __func__);
+    kprobe_init_successful = true;
+    return 0;
+
+kp_kblockd_mod_delayed_work_on_kp_fail:
+    unregister_kprobe(&oplus_kblockd_schedule_work_kp);
+kp_kblockd_schedule_work_kp_fail:
+    unregister_kprobe(&oplus_worker_attach_to_pool_kp);
+kp_worker_attach_to_pool_fail:
+    unregister_kretprobe(&oplus_apply_wqattrs_krp);
+kp_apply_wqattrs_fail:
+    unregister_kprobe(&oplus_alloc_unbound_pwq_kp);
+kp_alloc_unbound_pwq_fail:
+    unregister_kprobe(&oplus_alloc_workqueue_kp);
+kp_alloc_workqueue_fail:
+
+    kprobe_init_successful = false;
+    return ret;
+}
+
+static void __exit oplus_wq_kprobe_exit(void)
+{
+	//工作队列未销毁
+    if(kprobe_init_successful) {
+        unregister_kprobe(&oplus_alloc_workqueue_kp);
+        unregister_kprobe(&oplus_alloc_unbound_pwq_kp);
+        unregister_kretprobe(&oplus_apply_wqattrs_krp);
+        unregister_kprobe(&oplus_worker_attach_to_pool_kp);
+        unregister_kprobe(&oplus_kblockd_schedule_work_kp);
+        unregister_kprobe(&oplus_kblockd_mod_delayed_work_on_kp);
+        printk(KERN_INFO "kprobe unregistered\n");
+    } else {
+        printk(KERN_INFO "kprobe needn't unregistered\n");
+    }
+}
+
+module_init(oplus_wq_kprobe_init);
+module_exit(oplus_wq_kprobe_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("lijiang");
+MODULE_DESCRIPTION("A kernel module using kprobe to hook alloc_workqueue function");
diff --git a/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.h b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.h
new file mode 100644
index 000000000..ab20fafd2
--- /dev/null
+++ b/drivers/soc/oplus/storage/storage_feature_in_module/common/wq_dynamic_priority/oplus_wq_dynamic_priority.h
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+
+#ifndef _OPLUS_WQ_DYNAMIC_PRIORITY_H_
+#define _OPLUS_WQ_DYNAMIC_PRIORITY_H_
+
+#include <linux/hashtable.h>
+#include <linux/workqueue.h>
+#include <kernel/workqueue_internal.h>
+
+/* copy from workqueue.c */
+enum {
+	/*
+	 * worker_pool flags
+	 *
+	 * A bound pool is either associated or disassociated with its CPU.
+	 * While associated (!DISASSOCIATED), all workers are bound to the
+	 * CPU and none has %WORKER_UNBOUND set and concurrency management
+	 * is in effect.
+	 *
+	 * While DISASSOCIATED, the cpu may be offline and all workers have
+	 * %WORKER_UNBOUND set and concurrency management disabled, and may
+	 * be executing on any CPU.  The pool behaves as an unbound one.
+	 *
+	 * Note that DISASSOCIATED should be flipped only while holding
+	 * wq_pool_attach_mutex to avoid changing binding state while
+	 * worker_attach_to_pool() is in progress.
+	 */
+	POOL_MANAGER_ACTIVE	= 1 << 0,	/* being managed */
+	POOL_DISASSOCIATED	= 1 << 2,	/* cpu can't serve workers */
+
+	/* worker flags */
+	WORKER_DIE		= 1 << 1,	/* die die die */
+	WORKER_IDLE		= 1 << 2,	/* is idle */
+	WORKER_PREP		= 1 << 3,	/* preparing to run works */
+	WORKER_CPU_INTENSIVE	= 1 << 6,	/* cpu intensive */
+	WORKER_UNBOUND		= 1 << 7,	/* worker is unbound */
+	WORKER_REBOUND		= 1 << 8,	/* worker was rebound */
+
+	WORKER_NOT_RUNNING	= WORKER_PREP | WORKER_CPU_INTENSIVE |
+				  WORKER_UNBOUND | WORKER_REBOUND,
+
+	NR_STD_WORKER_POOLS	= 2,		/* # standard pools per cpu */
+
+	UNBOUND_POOL_HASH_ORDER	= 6,		/* hashed by pool->attrs */
+	BUSY_WORKER_HASH_ORDER	= 6,		/* 64 pointers */
+
+	MAX_IDLE_WORKERS_RATIO	= 4,		/* 1/4 of busy can be idle */
+	IDLE_WORKER_TIMEOUT	= 300 * HZ,	/* keep idle ones for 5 mins */
+
+	MAYDAY_INITIAL_TIMEOUT  = HZ / 100 >= 2 ? HZ / 100 : 2,
+						/* call for help after 10ms
+						   (min two ticks) */
+	MAYDAY_INTERVAL		= HZ / 10,	/* and then every 100ms */
+	CREATE_COOLDOWN		= HZ,		/* time to breath after fail */
+
+	/*
+	 * Rescue workers are used only on emergencies and shared by
+	 * all cpus.  Give MIN_NICE.
+	 */
+	RESCUER_NICE_LEVEL	= MIN_NICE,
+	HIGHPRI_NICE_LEVEL	= MIN_NICE,
+
+	WQ_NAME_LEN		= 24,
+};
+
+struct worker_pool {
+	raw_spinlock_t		lock;		/* the pool lock */
+	int			cpu;		/* I: the associated cpu */
+	int			node;		/* I: the associated node ID */
+	int			id;		/* I: pool ID */
+	unsigned int		flags;		/* L: flags */
+
+	unsigned long		watchdog_ts;	/* L: watchdog timestamp */
+	bool			cpu_stall;	/* WD: stalled cpu bound pool */
+
+	/*
+	 * The counter is incremented in a process context on the associated CPU
+	 * w/ preemption disabled, and decremented or reset in the same context
+	 * but w/ pool->lock held. The readers grab pool->lock and are
+	 * guaranteed to see if the counter reached zero.
+	 */
+	int			nr_running;
+
+	struct list_head	worklist;	/* L: list of pending works */
+
+	int			nr_workers;	/* L: total number of workers */
+	int			nr_idle;	/* L: currently idle workers */
+
+	struct list_head	idle_list;	/* L: list of idle workers */
+	struct timer_list	idle_timer;	/* L: worker idle timeout */
+	struct work_struct      idle_cull_work; /* L: worker idle cleanup */
+
+	struct timer_list	mayday_timer;	  /* L: SOS timer for workers */
+
+	/* a workers is either on busy_hash or idle_list, or the manager */
+	DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);
+						/* L: hash of busy workers */
+
+	struct worker		*manager;	/* L: purely informational */
+	struct list_head	workers;	/* A: attached workers */
+	struct list_head        dying_workers;  /* A: workers about to die */
+	struct completion	*detach_completion; /* all workers detached */
+
+	struct ida		worker_ida;	/* worker IDs for task name */
+
+	struct workqueue_attrs	*attrs;		/* I: worker attributes */
+	struct hlist_node	hash_node;	/* PL: unbound_pool_hash node */
+	int			refcnt;		/* PL: refcnt for unbound pools */
+
+	/*
+	 * Destruction of pool is RCU protected to allow dereferences
+	 * from get_work_pool().
+	 */
+	struct rcu_head		rcu;
+};
+
+struct workqueue_struct {
+	struct list_head	pwqs;		/* WR: all pwqs of this wq */
+	struct list_head	list;		/* PR: list of all workqueues */
+
+	struct mutex		mutex;		/* protects this wq */
+	int			work_color;	/* WQ: current work color */
+	int			flush_color;	/* WQ: current flush color */
+	atomic_t		nr_pwqs_to_flush; /* flush in progress */
+	struct wq_flusher	*first_flusher;	/* WQ: first flusher */
+	struct list_head	flusher_queue;	/* WQ: flush waiters */
+	struct list_head	flusher_overflow; /* WQ: flush overflow list */
+
+	struct list_head	maydays;	/* MD: pwqs requesting rescue */
+	struct worker		*rescuer;	/* MD: rescue worker */
+
+	int			nr_drainers;	/* WQ: drain in progress */
+	int			saved_max_active; /* WQ: saved pwq max_active */
+
+	struct workqueue_attrs	*unbound_attrs;	/* PW: only for unbound wqs */
+	struct pool_workqueue	*dfl_pwq;	/* PW: only for unbound wqs */
+
+#ifdef CONFIG_SYSFS
+	struct wq_device	*wq_dev;	/* I: for sysfs interface */
+#endif
+#ifdef CONFIG_LOCKDEP
+	char			*lock_name;
+	struct lock_class_key	key;
+	struct lockdep_map	lockdep_map;
+#endif
+	char			name[WQ_NAME_LEN]; /* I: workqueue name */
+
+	/*
+	 * Destruction of workqueue_struct is RCU protected to allow walking
+	 * the workqueues list without grabbing wq_pool_mutex.
+	 * This is used to dump all workqueues from sysrq.
+	 */
+	struct rcu_head		rcu;
+
+	/* hot fields used during command issue, aligned to cacheline */
+	unsigned int		flags ____cacheline_aligned; /* WQ: WQ_* flags */
+	struct pool_workqueue __percpu __rcu **cpu_pwq; /* I: per-cpu pwqs */
+};
+
+/* context to store the prepared attrs & pwqs before applying */
+struct apply_wqattrs_ctx {
+	struct workqueue_struct	*wq;		/* target workqueue */
+	struct workqueue_attrs	*attrs;		/* attrs to apply */
+	struct list_head	list;		/* queued for batching commit */
+	struct pool_workqueue	*dfl_pwq;
+	struct pool_workqueue	*pwq_tbl[];
+};
+
+
+
+#endif /* _OPLUS_WQ_DYNAMIC_PRIORITY_H_ */
diff --git a/kernel/locking/Makefile b/kernel/locking/Makefile
index ea925731f..afd151ae1 100644
--- a/kernel/locking/Makefile
+++ b/kernel/locking/Makefile
@@ -3,7 +3,7 @@
 # and is generally not a function of system call inputs.
 KCOV_INSTRUMENT		:= n
 
-obj-y += mutex.o semaphore.o rwsem.o percpu-rwsem.o
+obj-y += mutex.o semaphore.o rwsem.o percpu-rwsem.o oplus_locking.o
 
 # Avoid recursion lockdep -> sanitizer -> ... -> lockdep.
 KCSAN_SANITIZE_lockdep.o := n
diff --git a/kernel/locking/locking_main.h b/kernel/locking/locking_main.h
new file mode 100644
index 000000000..809e98b17
--- /dev/null
+++ b/kernel/locking/locking_main.h
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2020-2022 Oplus. All rights reserved.
+ */
+
+#ifndef _OPLUS_LOCKING_MAIN_H_
+#define _OPLUS_LOCKING_MAIN_H_
+
+#include "sa_common_struct.h"
+
+#define cond_trace_printk(cond, fmt, ...)	\
+do {										\
+	if (cond)								\
+		trace_printk(fmt, ##__VA_ARGS__);	\
+} while (0)
+
+
+
+#define MAGIC_NUM       (0xdead0000)
+#define MAGIC_MASK      (0xffff0000)
+#define MAGIC_SHIFT     (16)
+#define OWNER_BIT       (1 << 0)
+#define THREAD_INFO_BIT (1 << 1)
+#define TYPE_BIT        (1 << 2)
+
+#define UX_FLAG_BIT       (1<<0)
+#define SS_FLAG_BIT       (1<<1)
+#define GRP_SHIFT         (2)
+#define GRP_FLAG_MASK     (7 << GRP_SHIFT)
+#define U_GRP_OTHER       (1 << GRP_SHIFT)
+#define U_GRP_BACKGROUND  (2 << GRP_SHIFT)
+#define U_GRP_FRONDGROUD  (3 << GRP_SHIFT)
+#define U_GRP_TOP_APP     (4 << GRP_SHIFT)
+
+#define LOCK_TYPE_SHIFT (30)
+#define INVALID_TYPE    (0)
+#define LOCK_ART        (1)
+#define LOCK_JUC        (2)
+
+#define lk_err(fmt, ...) \
+		pr_err("[oplus_locking][%s]"fmt, __func__, ##__VA_ARGS__)
+#define lk_warn(fmt, ...) \
+		pr_warn("[oplus_locking][%s]"fmt, __func__, ##__VA_ARGS__)
+#define lk_info(fmt, ...) \
+		pr_info("[oplus_locking][%s]"fmt, __func__, ##__VA_ARGS__)
+
+#define OTS_IDX			0
+
+
+struct futex_uinfo {
+	u32 cmd;
+	u32 owner_tid;
+	u32 type;
+	u64 inform_user;
+};
+
+enum {
+	CGROUP_RESV = 0,
+	CGROUP_DEFAULT,
+	CGROUP_FOREGROUND,
+	CGROUP_BACKGROUND,
+	CGROUP_TOP_APP,
+
+	CGROUP_NRS,
+};
+
+enum rwsem_waiter_type {
+	RWSEM_WAITING_FOR_WRITE,
+	RWSEM_WAITING_FOR_READ
+};
+
+struct rwsem_waiter {
+	struct list_head list;
+	struct task_struct *task;
+	enum rwsem_waiter_type type;
+	unsigned long timeout;
+	bool handoff_set;
+};
+
+#define LK_MUTEX_ENABLE (1 << 0)
+#define LK_RWSEM_ENABLE (1 << 1)
+#define LK_FUTEX_ENABLE (1 << 2)
+#define LK_OSQ_ENABLE   (1 << 3)
+
+#ifdef CONFIG_OPLUS_LOCKING_MONITOR
+/*
+ * The bit definitions of the g_opt_enable:
+ * bit 0-7: reserved bits for other locking optimation.
+ * bit8 ~ bit10(each monitor version is exclusive):
+ * 1 : monitor control, level-0(internal version).
+ * 2 : monitor control, level-1(trial version).
+ * 3 : monitor control, level-2(official version).
+ */
+#define LK_MONITOR_SHIFT  (8)
+#define LK_MONITOR_MASK   (7 << LK_MONITOR_SHIFT)
+#define LK_MONITOR_LEVEL0 (1 << LK_MONITOR_SHIFT)
+#define LK_MONITOR_LEVEL1 (2 << LK_MONITOR_SHIFT)
+#define LK_MONITOR_LEVEL2 (3 << LK_MONITOR_SHIFT)
+#endif
+
+#define LK_DEBUG_PRINTK (1 << 0)
+#define LK_DEBUG_FTRACE (1 << 1)
+
+extern unsigned int g_opt_enable;
+extern unsigned int g_opt_debug;
+
+extern atomic64_t futex_inherit_set_times;
+extern atomic64_t futex_inherit_unset_times;
+extern atomic64_t futex_inherit_useless_times;
+extern atomic64_t futex_low_count;
+extern atomic64_t futex_high_count;
+
+static inline bool locking_opt_enable(unsigned int enable)
+{
+	return g_opt_enable & enable;
+}
+
+#ifdef CONFIG_OPLUS_LOCKING_MONITOR
+static inline bool lock_supp_level(int level)
+{
+	return (g_opt_enable & LK_MONITOR_MASK) == level;
+}
+#endif
+
+static inline bool locking_opt_debug(int debug)
+{
+	return g_opt_debug & debug;
+}
+
+void register_rwsem_vendor_hooks(void);
+void register_mutex_vendor_hooks(void);
+void register_futex_vendor_hooks(void);
+void register_monitor_vendor_hooks(void);
+void lk_sysfs_init(void);
+#ifdef CONFIG_OPLUS_LOCKING_MONITOR
+int kern_lstat_init(void);
+#endif
+
+void unregister_rwsem_vendor_hooks(void);
+void unregister_mutex_vendor_hooks(void);
+void unregister_futex_vendor_hooks(void);
+void unregister_monitor_vendor_hooks(void);
+void lk_sysfs_exit(void);
+#ifdef CONFIG_OPLUS_LOCKING_MONITOR
+void kern_lstat_exit(void);
+#endif
+#endif /* _OPLUS_LOCKING_MAIN_H_ */
+
+static inline struct oplus_task_struct *get_oplus_task_struct(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = NULL;
+
+	/* not Skip idle thread */
+	if (!t)
+		return NULL;
+
+	ots = (struct oplus_task_struct *) READ_ONCE(t->android_oem_data1[OTS_IDX]);
+	if (IS_ERR_OR_NULL(ots))
+		return NULL;
+
+	return ots;
+}
+
+void locking_record_switch_in_cs(struct task_struct *tsk);
+
diff --git a/kernel/locking/oplus_locking.c b/kernel/locking/oplus_locking.c
new file mode 100644
index 000000000..338097ebc
--- /dev/null
+++ b/kernel/locking/oplus_locking.c
@@ -0,0 +1,885 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/sched/clock.h>
+#include <linux/cgroup.h>
+#include <linux/ftrace.h>
+#include <linux/futex.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/rwsem.h>
+#include <linux/rtmutex.h>
+#include <linux/mutex.h>
+#include <trace/hooks/dtask.h>
+#include <trace/hooks/futex.h>
+#include <trace/hooks/sched.h>
+#include <trace/events/sched.h>
+#include <trace/events/task.h>
+#include <linux/sched.h>
+
+
+//#include <../kernel/oplus_cpu/sched/sched_assist/sa_common.h>
+
+#include "locking_main.h"
+static inline struct oplus_task_struct *get_oplus_task_struct(struct task_struct *t);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+#define PDE_DATA pde_data
+#endif
+
+static int debug_enable_flag;
+static bool init_done = false;
+atomic64_t switch_in_cs_cnts;
+
+#define SAVE_TRACE_NUMS	4
+struct lock_record {
+	int type;
+	u64 lock_id;
+	u64 start_time;
+
+	unsigned long traces[SAVE_TRACE_NUMS];
+
+	struct list_head node;
+};
+
+static const char *skip_str[] = {"f2fs_quota_sync", "f2fs_dquot_commit", "aio_write", "aio_complete_rw", "mcp_wait",
+                                 "session_gp_invoke_command", "ksys_read", "devkmsg_read", "n_tty_read", "__driver_attach",
+                                 "btmtk_uart_cif_mutex_unlock", "wfsys_unlock", "connv3_core_pre_cal_start", "regulator_unlock_recursive"};
+
+#define MUTEX		0
+#define RWSEM		1
+#define RTMUTEX		2
+#define PCP_RWSEM	3
+#define LOCK_TYPES	4
+
+char *lock_str[LOCK_TYPES] = {"mutex", "rwsem", "rtmutex", "pcp-rwsem"};
+
+static atomic64_t wait_cnt[LOCK_TYPES];
+static atomic64_t lock_cnts[LOCK_TYPES];
+static atomic64_t max_wait_cnts[LOCK_TYPES];
+static atomic_t max_depth;
+
+#define CS_STATS_LVLS	6
+static atomic64_t cs_duration[LOCK_TYPES][CS_STATS_LVLS];
+
+static unsigned long scopes[CS_STATS_LVLS][2] = {
+	{0, 2 * NSEC_PER_MSEC},
+	{2 * NSEC_PER_MSEC, 10 * NSEC_PER_MSEC},
+	{10 * NSEC_PER_MSEC, 50 * NSEC_PER_MSEC},
+	{50 * NSEC_PER_MSEC, 200 * NSEC_PER_MSEC},
+	{200 * NSEC_PER_MSEC, 1 * NSEC_PER_SEC},
+	{1 * NSEC_PER_SEC, ULONG_MAX}
+};
+
+#define MAX_TRACE_DEPTH	10
+
+static bool is_match_skip_str(unsigned long *entries, int nentries)
+{
+	char trace_str[KSYM_SYMBOL_LEN];
+	char buf[1024];
+	int idx = 0;
+	int i;
+
+	for (i = 0; i < nentries; i++) {
+		sprint_symbol_no_offset(trace_str, entries[i]);
+		idx += sprintf(&buf[idx], "%s-", trace_str);
+	}
+
+	for (i = 0; i < sizeof(skip_str) / sizeof(skip_str[0]); i++) {
+		if (strstr(buf, skip_str[i])) {
+			//pr_err("krn_reliab : match string = %s\n", strstr(buf, skip_str[i]));
+			return true;
+		}
+	}
+
+	return false;
+}
+
+#define WALK_BACKTRACE_LEVELS	4
+static bool is_skip_report_error(void)
+{
+	unsigned long entries[WALK_BACKTRACE_LEVELS];
+
+	stack_trace_save(entries, WALK_BACKTRACE_LEVELS, 3);
+
+	return is_match_skip_str(entries, WALK_BACKTRACE_LEVELS);
+}
+
+static void output_backtrace(unsigned long *entries, int nentrie)
+{
+	char trace_str[KSYM_SYMBOL_LEN];
+	char *buf;
+	int idx = 0;
+	int i;
+
+	buf = kmalloc(KSYM_SYMBOL_LEN * MAX_TRACE_DEPTH, GFP_ATOMIC);
+	if (!buf)
+		return;
+
+	for (i = 0; i < nentrie; i++) {
+		sprint_symbol(trace_str, entries[i]);
+		idx += sprintf(&buf[idx], "%s - ", trace_str);
+	}
+	idx += sprintf(&buf[idx], "\n");
+
+	pr_err("krn_reliab : trace = %s\n", buf);
+
+	kfree(buf);
+}
+
+static void print_backtrace(int skip, int depth)
+{
+	unsigned long entries[MAX_TRACE_DEPTH];
+
+	if (depth >= MAX_TRACE_DEPTH)
+		return;
+
+	stack_trace_save(entries, depth, skip);
+	output_backtrace(entries, depth);
+}
+
+#define CLEAR_PERIOD_MSEC	(5000)
+#define HOLD_EXPIRE_TIME	(10 * NSEC_PER_SEC)
+/* Timer to clear hold lock info which exceed timeout. */
+static atomic64_t clear_seq;
+static struct timer_list clh_timer;
+
+static void clear_hold_timer(struct timer_list *unused)
+{
+	atomic64_inc_return(&clear_seq);
+	mod_timer(&clh_timer, jiffies + CLEAR_PERIOD_MSEC);
+}
+
+static void init_clear_lock_hold_timer(void)
+{
+	timer_setup(&clh_timer, clear_hold_timer, 0);
+	clh_timer.expires = jiffies + msecs_to_jiffies(CLEAR_PERIOD_MSEC);
+	add_timer(&clh_timer);
+}
+
+static void exit_clear_lock_hold_timer(void)
+{
+	del_timer_sync(&clh_timer);
+}
+
+static void stats_cs_duration(int type, u64 duration)
+{
+	int i;
+
+	if (duration > 10 * NSEC_PER_SEC) {
+		pr_err("krn_reliab : lock %s own the lock exceed threshold, duration = %llu s\n", lock_str[type], duration / NSEC_PER_SEC);
+		print_backtrace(2, 7);
+	}
+
+	if (duration > NSEC_PER_SEC) {
+		if (is_skip_report_error()) {
+			//pr_err("match the skip str, do not report the error\n");
+		}
+		else {
+			pr_err("krn_reliab : lock %s own the lock exceed 1s, duration = %llu s\n", lock_str[type], duration / NSEC_PER_SEC);
+			print_backtrace(2, 7);
+			atomic64_inc(&cs_duration[type][CS_STATS_LVLS-1]);
+		}
+	}
+
+	for (i = 0; i < CS_STATS_LVLS-1; i++) {
+		if (duration < scopes[i][1] && duration >= scopes[i][0]) {
+			atomic64_inc(&cs_duration[type][i]);
+			return;
+		}
+	}
+}
+
+void locking_record_switch_in_cs(struct task_struct *tsk)
+{
+	struct oplus_task_struct *ots;
+
+	ots = get_oplus_task_struct(tsk);
+	if (NULL == ots)
+		return;
+	if (atomic_read(&ots->lkinfo.lock_depth)) {
+		atomic64_inc(&switch_in_cs_cnts);
+	}
+}
+EXPORT_SYMBOL(locking_record_switch_in_cs);
+
+static void get_lock_cnts(bool is_lock, int type)
+{
+	if (is_lock)
+		atomic64_inc(&lock_cnts[type]);
+}
+
+void depth_check(struct oplus_task_struct *ots, int flag)
+{
+	int length = 0;
+	struct list_head *list_node;
+
+	list_for_each(list_node, &ots->lkinfo.lock_head) {
+		length++;
+	}
+	
+	if(length != atomic_read(&ots->lkinfo.lock_depth)) {
+		//pr_err("depth:%d, length:%d, flag:%d", atomic_read(&ots->lkinfo.lock_depth), length, flag);
+		atomic_set(&ots->lkinfo.lock_depth, length);
+	}
+}
+
+static void lock_handler(struct task_struct *tsk, u64 lock_id, int type)
+{
+	struct oplus_task_struct *ots;
+	struct lock_record *node, *tmp;
+
+	u64 g_clear_seq;
+	
+	ots = get_oplus_task_struct(tsk);
+	if (IS_ERR_OR_NULL(ots)) {
+		//pr_err("krn_reliab : ots == NULL \n");
+		return;
+	}
+	if (NULL == ots->lkinfo.lock_head.next) {
+		INIT_LIST_HEAD(&ots->lkinfo.lock_head);
+	}
+
+	g_clear_seq = atomic64_read_acquire(&clear_seq);
+	if (ots->lkinfo.clear_seq < g_clear_seq) {
+		ots->lkinfo.clear_seq = g_clear_seq;
+		list_for_each_entry_safe_reverse(node, tmp, &ots->lkinfo.lock_head, node) {
+			if (sched_clock() - node->start_time >= HOLD_EXPIRE_TIME) {
+				if (is_match_skip_str(node->traces, SAVE_TRACE_NUMS)) {
+					pr_err("krn_reliab : free skip expire held lock info, type = %s\n", lock_str[type]);
+				} else {
+					pr_err("krn_reliab : free unskip expire held lock info, type = %s, lock_id = 0x%llx, lock_stamp = %llu\n", lock_str[node->type], node->lock_id, node->start_time);
+					output_backtrace(node->traces, SAVE_TRACE_NUMS);
+					print_backtrace(2, 7);
+				}
+				if (type == PCP_RWSEM) {
+					if (atomic_read(&ots->lkinfo.lock_depth) < 0) {
+						//pr_err("krn_reliab : why lock depth less than 0?\n");
+					}
+				}
+				atomic_dec(&ots->lkinfo.lock_depth);
+				list_del(&node->node);
+				depth_check(ots, 1);
+				kfree(node);
+			} else {
+				break;
+			}
+		}
+	}
+
+	node = kmalloc(sizeof(*node), GFP_ATOMIC);
+	if (!node) {
+		pr_err("krn_reliab : Failed to alloc record node\n");
+		return;
+	}
+	node->lock_id = lock_id;
+	node->type = type;
+	node->start_time = sched_clock();
+	stack_trace_save(node->traces, SAVE_TRACE_NUMS, 2);
+	list_add(&node->node, &ots->lkinfo.lock_head);
+
+	atomic_inc(&ots->lkinfo.lock_depth);
+	depth_check(ots, 2);
+	if (atomic_read(&max_depth) < atomic_read(&ots->lkinfo.lock_depth)) {
+		atomic_set(&max_depth, atomic_read(&ots->lkinfo.lock_depth));
+		pr_err("krn_reliab : update the max depth: %d, type = %s, lock_id = 0x%llx\n", atomic_read(&ots->lkinfo.lock_depth), lock_str[node->type], node->lock_id);
+		print_backtrace(2, 7);
+	}
+
+}
+
+static void unlock_handler(struct task_struct *tsk, u64 lock_id, int type)
+{
+	struct oplus_task_struct *ots;
+	struct lock_record *node, *tmp;
+	u64 duration;
+	int found = 0;
+
+	ots = get_oplus_task_struct(tsk);
+
+	if (IS_ERR_OR_NULL(ots)) {
+		pr_err("krn_reliab : ots == NULL \n");
+		return;
+	}
+	if (NULL == ots->lkinfo.lock_head.next)
+		INIT_LIST_HEAD(&ots->lkinfo.lock_head);
+
+	list_for_each_entry_safe(node, tmp, &ots->lkinfo.lock_head, node) {
+		if (lock_id == node->lock_id) {
+			duration = sched_clock() - node->start_time;
+			stats_cs_duration(type, duration);
+
+			/* Find corresponding lock !*/
+			found++;
+			/*
+			if (found >= 2) {
+				pr_err("krn_reliab : why found 2 unlocks, type = %s\n", lock_str[type]);
+				print_backtrace(3, 4);
+			} */
+			atomic_dec(&ots->lkinfo.lock_depth);
+			depth_check(ots, 3);
+			if (atomic_read(&ots->lkinfo.lock_depth) < 0) {
+				pr_err("krn_reliab : why lock depth less than 0?\n");
+			}
+
+			list_del(&node->node);
+			kfree(node);
+
+			/* f2fs_dquot_commit/f2fs_quota_sync will lock recursively rwsem(reader) with trylock. */
+			break;
+		}
+	}
+	if (0 == found) {
+		if (is_skip_report_error()) {
+			//pr_err("krn_reliab : skip report unlocked error, type =  %s\n", lock_str[type]);
+		} else {
+			pr_err("krn_reliab : can't find corresponding lock, type = %s, lock_id = 0x%llx, lock_stamp = %llu\n", lock_str[type], lock_id, sched_clock());
+			print_backtrace(2, 7);
+		}
+	}
+}
+
+void mutex_lock_handler(u64 lock, struct task_struct *tsk, unsigned long jiffies)
+{
+	if(!debug_enable_flag) return;
+
+	get_lock_cnts(jiffies, MUTEX);
+
+	if (jiffies) {
+		lock_handler(tsk, lock, MUTEX);
+	}
+	else {
+		unlock_handler(tsk, lock, MUTEX);
+	}
+
+}
+
+void rwsem_lock_handler(u64 sem, struct task_struct *tsk, unsigned long jiffies)
+{
+	if(!debug_enable_flag) return;
+	get_lock_cnts(jiffies, RWSEM);
+
+	if (jiffies) {	
+		lock_handler(tsk, (u64)sem, RWSEM);
+	}
+	else {
+		unlock_handler(tsk, (u64)sem, RWSEM);
+	}
+}
+
+void rtmutex_lock_handler(u64 lock, struct task_struct *tsk, unsigned long jiffies)
+{
+	if(!debug_enable_flag) return;
+	get_lock_cnts(jiffies, RTMUTEX);
+
+	if (jiffies)
+		lock_handler(tsk, (u64)lock, RTMUTEX);
+	else
+		unlock_handler(tsk, (u64)lock, RTMUTEX);
+}
+
+void android_vh_pcpu_rwsem_handler(u64 sem, struct task_struct *tsk, unsigned long jiffies)
+{
+	if(!debug_enable_flag) return;
+	get_lock_cnts(jiffies, PCP_RWSEM);
+
+/*
+	if (jiffies)
+		lock_handler(tsk, (u64)sem, PCP_RWSEM);
+	else
+		unlock_handler(tsk, (u64)sem, PCP_RWSEM);
+*/
+}
+EXPORT_SYMBOL(android_vh_pcpu_rwsem_handler);
+
+static int iter_rbtree_for_elem_nums(struct rb_root *root)
+{
+	int cnts = 0;
+	struct rb_node *node;
+
+	for (node = rb_first(root); node; node = rb_next(node))
+		cnts++;
+
+	return cnts;
+}
+
+unsigned long flags;
+static noinline int walk_list_for_elem_nums(struct list_head *head)
+{
+	atomic_t cnts;
+	struct list_head *node;
+
+	atomic_set(&cnts, 0);
+
+	list_for_each(node, head) {
+		atomic_inc(&cnts);
+	}
+	return atomic_read(&cnts);
+}
+
+/* We don't want to add a cnt field in lock struct.
+ * Just walk the list/rbtree to get wait list cnt;
+ */
+static void record_waiters_cnts(void *lock, int type)
+{
+	struct mutex *mlock;
+	struct rw_semaphore *rwsem;
+	struct rt_mutex_base *rtlock;
+	struct percpu_rw_semaphore *pcp_sem;
+
+	int max;
+	atomic_t cnt;
+	
+	atomic_set(&cnt, 0);
+	if (NULL == lock) {
+		printk("krn_reliab : lock is NULL\n");
+		return;
+	}
+
+	/* Only read, no need to acquire spinlock.*/
+	max = atomic64_read(&max_wait_cnts[type]);
+	switch (type) {
+	case MUTEX:
+		mlock = (struct mutex*)lock;
+		atomic_set(&cnt, walk_list_for_elem_nums(&mlock->wait_list));
+		break;
+	case RWSEM:
+		rwsem = (struct rw_semaphore *)lock;
+		atomic_set(&cnt, walk_list_for_elem_nums(&rwsem->wait_list));
+		break;
+	case RTMUTEX:
+		rtlock = (struct rt_mutex_base *)lock;
+		atomic_set(&cnt, iter_rbtree_for_elem_nums(&rtlock->waiters.rb_root));
+		break;
+	case PCP_RWSEM:
+		pcp_sem = (struct percpu_rw_semaphore *)lock;
+		spin_lock_irqsave(&pcp_sem->waiters.lock, flags);
+		atomic_set(&cnt, walk_list_for_elem_nums(&pcp_sem->waiters.head));
+		spin_unlock_irqrestore(&pcp_sem->waiters.lock, flags);
+		break;
+	default:
+		atomic_set(&cnt, 0);
+		break;
+	}
+
+	if (atomic_read(&cnt) > max) {
+		atomic64_set(&max_wait_cnts[type], atomic_read(&cnt));
+		pr_err("krn_reliab : update the max waiter_cnts: %d, type = %s, lock_id = 0x%lx\n", atomic_read(&cnt), lock_str[type], (unsigned long)lock);
+		print_backtrace(2, 7);
+	}
+}
+
+void mutex_wait_handler(struct mutex *lock)
+{
+	if(!debug_enable_flag) return;
+	/* Contend stats. */
+	atomic64_inc(&wait_cnt[MUTEX]);
+
+	/* Wait list nums stats. */
+	record_waiters_cnts(lock, MUTEX);
+}
+
+void rwsem_read_wait_handler(struct rw_semaphore *sem)
+{
+	if(!debug_enable_flag) return;
+	/* Contend stats. */
+	atomic64_inc(&wait_cnt[RWSEM]);
+
+	/* Wait list nums stats. */
+	raw_spin_lock(&sem->wait_lock);
+	record_waiters_cnts(sem, RWSEM);
+	// walk_list_for_elem_nums(&sem->wait_list);
+	raw_spin_unlock(&sem->wait_lock);
+}
+
+void rwsem_write_wait_handler(struct rw_semaphore *sem)
+{
+	/* Contend stats. */
+	atomic64_inc(&wait_cnt[RWSEM]);
+
+	/* Wait list nums stats. */
+	record_waiters_cnts(sem, RWSEM);
+}
+
+void rtmutex_wait_handler(struct rt_mutex_base *lock)
+{
+	if(!debug_enable_flag) return;
+	/* Contend stats. */
+	atomic64_inc(&wait_cnt[RTMUTEX]);
+
+	/* Wait list nums stats. */
+	record_waiters_cnts(lock, RTMUTEX);
+}
+
+void pcp_wait_handler(struct percpu_rw_semaphore *sem, bool is_reader, int phase)
+{
+	if(!debug_enable_flag) return;
+	/* Contend stats. */
+	atomic64_inc(&wait_cnt[PCP_RWSEM]);
+
+	/* Wait list nums stats. */
+	record_waiters_cnts(sem, PCP_RWSEM);
+}
+
+/*
+static void schedule_handler(void *unused, struct task_struct *prev, struct task_struct *next, struct rq *rq)
+{
+
+}*/
+
+
+/***************************** switch in cs *******************************/
+static int switch_in_cs_show(struct seq_file *m, void *v)
+{
+	char buf[1024];
+	int idx = 0;
+	long long int total_lock_cnts = 0;
+	int i;
+
+	idx += sprintf(&buf[idx], "%-16s%-16s\n", "total", "switch_incs");
+
+	for (i = 0; i < LOCK_TYPES; i++) {
+		total_lock_cnts += atomic64_read(&lock_cnts[i]);
+	}
+
+	idx += sprintf(&buf[idx], "%-16lld%-16lld\n", total_lock_cnts, atomic64_read(&switch_in_cs_cnts));
+
+	sprintf(&buf[idx], "\n");
+
+	seq_printf(m, "%s\n", buf);
+
+	return 0;
+}
+
+static int switch_in_cs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, switch_in_cs_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops switch_in_cs_fops = {
+	.proc_open		= switch_in_cs_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+};
+
+/*****************************Contend Info *******************************/
+
+/***************************** max depth *******************************/
+static int max_depth_show(struct seq_file *m, void *v)
+{
+	char buf[1024];
+	int idx = 0;
+	// int i;
+
+	idx += sprintf(&buf[idx], "%-16s%-16d\n", "max_depth:", atomic_read(&max_depth));
+
+	/*
+	for (i = 0; i < LOCK_TYPES; i++) {
+		idx += sprintf(&buf[idx], "%-16s%-16d\n", lock_str[i], atomic_read(&max_depth[i]));
+	}
+	*/
+
+	seq_printf(m, "%s\n", buf);
+
+	return 0;
+}
+
+static int max_depth_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max_depth_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops max_depth_fops = {
+	.proc_open		= max_depth_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+};
+
+/***************************** max depth *******************************/
+
+
+/***************************** CS duration *******************************/
+#define STAMP_TO_UNIT_NUM(x)	(x / 1000000000 >= 1 ? (x / 1000000000) : (x / 1000000 >= 1 ? (x / 1000000) : (x / 1000)))
+#define STAMP_TO_NUM_UNIT(x)	(x / 1000000000 >= 1 ? "s" : (x / 1000000 >= 1 ? "ms" : "us"))
+
+static int cs_duration_show(struct seq_file *m, void *v)
+{
+	char *buf;
+	char tmp[50];
+	int i, j, idx = 0;
+
+	buf = kmalloc(8192, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+
+	idx += sprintf(&buf[idx], "%-16s", "");
+
+	for (i = 0; i < CS_STATS_LVLS; i++) {
+		if(i < CS_STATS_LVLS -1) {
+			sprintf(tmp, "%lu%s~%lu%s",
+					STAMP_TO_UNIT_NUM(scopes[i][0]),
+					STAMP_TO_NUM_UNIT(scopes[i][0]),
+					STAMP_TO_UNIT_NUM(scopes[i][1]),
+					STAMP_TO_NUM_UNIT(scopes[i][1]));
+		} else {
+			sprintf(tmp, "%lu%s~%s",
+					STAMP_TO_UNIT_NUM(scopes[i][0]),
+					STAMP_TO_NUM_UNIT(scopes[i][0]),
+					"UL_MAX");
+		}
+		idx += sprintf(&buf[idx], "%-12s", tmp);
+	}
+	idx += sprintf(&buf[idx], "\n");
+
+	for (i = 0; i < LOCK_TYPES; i++) {
+		idx += sprintf(&buf[idx], "%-16s", lock_str[i]);
+		for (j = 0; j < CS_STATS_LVLS; j++) {
+			idx += sprintf(&buf[idx], "%-12lld", atomic64_read(&cs_duration[i][j]));
+		}
+		idx += sprintf(&buf[idx], "\n");
+	}
+	seq_printf(m, "%s\n", buf);
+
+	kfree(buf);
+	return 0;
+}
+
+static int cs_duration_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cs_duration_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops cs_duration_fops = {
+	.proc_open		= cs_duration_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+};
+
+/***************************** CS duration *******************************/
+
+/***************************** Waiter cnts *******************************/
+static int waiter_cnts_show(struct seq_file *m, void *v)
+{
+	char waiter_cnts[1024];
+	int idx = 0;
+	int i;
+
+	idx += sprintf(&waiter_cnts[idx], "%-16s%-16s\n", "", "max_cnts");
+
+	for (i = 0; i < LOCK_TYPES; i++) {
+		idx += sprintf(&waiter_cnts[idx], "%-16s%-16lld\n", lock_str[i], atomic64_read(&max_wait_cnts[i]));
+	}
+
+	sprintf(&waiter_cnts[idx], "\n");
+
+	seq_printf(m, "%s\n", waiter_cnts);
+
+	return 0;
+}
+
+static int waiter_cnts_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, waiter_cnts_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops waiter_cnts_fops = {
+	.proc_open		= waiter_cnts_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+};
+
+/***************************** Waiter cnts *******************************/
+
+/*****************************Contend Info *******************************/
+static int contend_infos_show(struct seq_file *m, void *v)
+{
+	char contend_info[1024];
+	int idx = 0;
+	int i;
+
+	idx += sprintf(&contend_info[idx], "%-16s%-16s%-16s\n", "", "total", "contend");
+
+	for (i = 0; i < LOCK_TYPES; i++) {
+		idx += sprintf(&contend_info[idx], "%-16s%-16lld%-16lld\n", lock_str[i], atomic64_read(&lock_cnts[i]), atomic64_read(&wait_cnt[i]));	
+	}
+
+	sprintf(&contend_info[idx], "\n");
+
+	seq_printf(m, "%s\n", contend_info);
+
+	return 0;
+}
+
+static int contend_infos_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, contend_infos_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops contend_info_fops = {
+	.proc_open		= contend_infos_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+};
+
+/*****************************Contend Info *******************************/
+
+
+#define CONTEND_INFO_FILE	"contend_info"
+#define WAITER_CNTS		"waiter_cnts"
+#define CS_DURATION		"cs_duration"
+#define MAX_DEPTH		"max_depth"
+#define KRN_RELIAB_DIR		"boot_reliab_dir"
+#define SWITCH_IN_CS		"switch_in_cs"
+
+static struct proc_dir_entry *d_krn_reliab;
+
+static int create_proc_files(void)
+{
+	struct proc_dir_entry *p;
+
+	p = proc_create(CONTEND_INFO_FILE, S_IRUGO | S_IWUGO,
+			d_krn_reliab, &contend_info_fops);
+	if (!p)
+		goto err;
+
+	p = proc_create(WAITER_CNTS, S_IRUGO | S_IWUGO,
+			d_krn_reliab, &waiter_cnts_fops);
+	if (!p)
+		goto err1;
+
+	p = proc_create(CS_DURATION, S_IRUGO | S_IWUGO,
+			d_krn_reliab, &cs_duration_fops);
+	if (!p)
+		goto err2;
+
+	p = proc_create(MAX_DEPTH, S_IRUGO | S_IWUGO,
+			d_krn_reliab, &max_depth_fops);
+	if (!p)
+		goto err3;
+
+	p = proc_create(SWITCH_IN_CS, S_IRUGO | S_IWUGO,
+			d_krn_reliab, &switch_in_cs_fops);
+	if (!p)
+		goto err4;
+
+	return 0;
+err4:
+	remove_proc_entry(MAX_DEPTH, d_krn_reliab);
+err3:
+	remove_proc_entry(CS_DURATION, d_krn_reliab);
+err2:
+	remove_proc_entry(WAITER_CNTS, d_krn_reliab);
+err1:
+	remove_proc_entry(CONTEND_INFO_FILE, d_krn_reliab);
+err:
+	remove_proc_entry(KRN_RELIAB_DIR, NULL);
+	return -ENOMEM;
+}
+
+
+static void remove_proc_files(void)
+{
+	remove_proc_entry(SWITCH_IN_CS, d_krn_reliab);
+	remove_proc_entry(MAX_DEPTH, d_krn_reliab);
+	remove_proc_entry(CONTEND_INFO_FILE, d_krn_reliab);
+	remove_proc_entry(WAITER_CNTS, d_krn_reliab);
+	remove_proc_entry(CS_DURATION, d_krn_reliab);
+}
+
+static int register_driver(void)
+{
+	create_proc_files();
+	return 0;
+}
+
+static void unregister_driver(void)
+{
+	remove_proc_files();
+}
+
+static ssize_t kernel_reliab_enabled_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	char buffer[8];
+	int err;
+
+	memset(buffer, 0, sizeof(buffer));
+
+	if (count > sizeof(buffer) - 1)
+		count = sizeof(buffer) - 1;
+
+	if (copy_from_user(buffer, buf, count))
+		return -EFAULT;
+
+	buffer[count] = '\0';
+	err = kstrtoint(strstrip(buffer), 10, &debug_enable_flag);
+	if (err)
+		return err;
+
+	if(debug_enable_flag) {
+		if(init_done)
+			return count;
+		init_done = true;
+		register_driver();
+		init_clear_lock_hold_timer();
+	} else {
+		init_done = false;
+		unregister_driver();
+		exit_clear_lock_hold_timer();
+	}
+
+	return count;
+}
+
+static ssize_t kernel_reliab_enabled_read(struct file *file, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	char buffer[20];
+	size_t len = 0;
+
+	len = snprintf(buffer, sizeof(buffer), "debug_enable_flag=%d\n", debug_enable_flag);
+
+	return simple_read_from_buffer(buf, count, ppos, buffer, len);
+}
+
+static const struct proc_ops kernel_reliab_enabled_fops = {
+	.proc_write		= kernel_reliab_enabled_write,
+	.proc_read		= kernel_reliab_enabled_read,
+};
+
+static int __init krn_reliab_init(void)
+{
+	struct proc_dir_entry *proc_node;
+
+	d_krn_reliab = proc_mkdir(KRN_RELIAB_DIR, NULL);
+	if (!d_krn_reliab)
+		return -ENOMEM;
+
+	proc_node = proc_create("debug_enable", 0666, d_krn_reliab, &kernel_reliab_enabled_fops);
+	if (!proc_node) {
+		pr_err("failed to create proc node debug_enable_flag\n");
+		goto err_creat_debug_enable_flag;
+	}
+
+	return 0;
+
+err_creat_debug_enable_flag:
+	remove_proc_entry("debug_enable_flag", d_krn_reliab);
+	remove_proc_entry(KRN_RELIAB_DIR, NULL);
+	return 0;
+}
+
+static void __exit krn_reliab_exit(void)
+{
+	exit_clear_lock_hold_timer();
+}
+
+module_init(krn_reliab_init);
+module_exit(krn_reliab_exit);
diff --git a/kernel/locking/sa_common_struct.h b/kernel/locking/sa_common_struct.h
new file mode 100644
index 000000000..1d4b2f995
--- /dev/null
+++ b/kernel/locking/sa_common_struct.h
@@ -0,0 +1,181 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2020-2022 Oplus. All rights reserved.
+ */
+
+/*
+this file is splited from the sa_common.h to adapt the OKI,
+IS_ENABLED is not allowed in here, because the macro will not work in OKI.
+*/
+#ifndef _OPLUS_SA_COMMON_STRUCT_H_
+#define _OPLUS_SA_COMMON_STRUCT_H_
+
+#define MAX_CLUSTER            (4)
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)*/
+
+#define MAX_TASK_COMM_LEN 256
+struct uid_struct {
+	uid_t uid;
+	u64 uid_total_cycle;
+	u64 uid_total_inst;
+	spinlock_t lock;
+	char leader_comm[TASK_COMM_LEN];
+	char cmdline[MAX_TASK_COMM_LEN];
+};
+
+struct  amu_uid_entry {
+	uid_t uid;
+	struct uid_struct *uid_struct;
+	struct hlist_node node;
+};
+
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_LOCKING_STRATEGY)*/
+struct locking_info {
+	u64 waittime_stamp;
+	u64 holdtime_stamp;
+	/* Used in torture acquire latency statistic.*/
+	u64 acquire_stamp;
+	/*
+	 * mutex or rwsem optimistic spin start time. Because a task
+	 * can't spin both on mutex and rwsem at one time, use one common
+	 * threshold time is OK.
+	 */
+	u64 opt_spin_start_time;
+	struct task_struct *holder;
+	u32 waittype;
+	bool ux_contrib;
+	/*
+	 * Whether task is ux when it's going to be added to mutex or
+	 * rwsem waiter list. It helps us check whether there is ux
+	 * task on mutex or rwsem waiter list. Also, a task can't be
+	 * added to both mutex and rwsem at one time, so use one common
+	 * field is OK.
+	 */
+	bool is_block_ux;
+	u32 kill_flag;
+	/* for cfs enqueue smoothly.*/
+	struct list_head node;
+	struct task_struct *owner;
+	struct list_head lock_head;
+	u64 clear_seq;
+	atomic_t lock_depth;
+};
+/*#endif*/
+
+/* Please add your own members of task_struct here :) */
+struct oplus_task_struct {
+	/* CONFIG_OPLUS_FEATURE_SCHED_ASSIST */
+	struct rb_node ux_entry;
+	struct rb_node exec_time_node;
+	struct task_struct *task;
+	atomic64_t inherit_ux;
+	u64 enqueue_time;
+	u64 inherit_ux_start;
+	/* u64 sum_exec_baseline; */
+	u64 total_exec;
+	u64 vruntime;
+	u64 preset_vruntime;
+	s64 cfs_delta;
+	int ux_state;
+	u8 ux_depth;
+	s8 ux_priority;
+	s8 ux_nice;
+	unsigned long im_flag;
+	pid_t affinity_pid;
+	pid_t affinity_tgid;
+	unsigned long state;
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_ABNORMAL_FLAG)*/
+	int abnormal_flag;
+/*#endif*/
+	/* CONFIG_OPLUS_FEATURE_SCHED_SPREAD */
+	int lb_state;
+	int ld_flag:1;
+	/* CONFIG_OPLUS_FEATURE_TASK_LOAD */
+	int is_update_runtime:1;
+	int target_process;
+	u64 wake_tid;
+	u64 running_start_time;
+	bool update_running_start_time;
+	u64 exec_calc_runtime;
+	cpumask_t cpus_requested;
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)*/
+	u64 block_start_time;
+/*#endif*/
+	/* CONFIG_OPLUS_FEATURE_FRAME_BOOST */
+	struct list_head fbg_list;
+	raw_spinlock_t fbg_list_entry_lock;
+	bool fbg_running; /* task belongs to a group, and in running */
+	u16 fbg_state;
+	s8 preferred_cluster_id;
+	s8 fbg_depth;
+	u64 last_wake_ts;
+	int fbg_cur_group;
+/*#ifdef CONFIG_LOCKING_PROTECT*/
+	unsigned long locking_start_time;
+	struct list_head locking_entry;
+	int locking_depth;
+	int lk_tick_hit;
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_LOCKING_STRATEGY)*/
+	struct locking_info lkinfo;
+/*#endif*/
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_FDLEAK_CHECK)*/
+	u8 fdleak_flag;
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)*/
+	/* for loadbalance */
+	struct plist_node rtb;		/* rt boost task */
+
+	/*
+	 * The following variables are used to calculate the time
+	 * a task spends in the running/runnable state.
+	 */
+	u64 snap_run_delay;
+	unsigned long snap_pcount;
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_PIPELINE)*/
+	atomic_t pipeline_cpu;
+/*#endif*/
+
+	/* for oplus secure guard */
+	int sg_flag;
+	int sg_scno;
+	uid_t sg_uid;
+	uid_t sg_euid;
+	gid_t sg_gid;
+	gid_t sg_egid;
+/*#if IS_ENABLED(CONFIG_ARM64_AMU_EXTN) && IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)*/
+	struct uid_struct *uid_struct;
+	u64 amu_instruct;
+	u64 amu_cycle;
+/*#endif*/
+	/* for binder ux */
+	int binder_async_ux_enable;
+	bool binder_async_ux_sts;
+	int binder_thread_mode;
+	struct binder_node *binder_thread_node;
+	/*
+	 * for vip binder:
+	 * vip_thread_policy_max_threads:for the max number of vip threads except binder_max_threads.
+	 * vip_save_threads:the vip thread saved in binder_max_threads
+	 */
+	int vip_thread_policy_max_threads;
+	int vip_save_threads;
+} ____cacheline_aligned;
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)*/
+#define INVALID_PID						(-1)
+struct oplus_lb {
+	/* used for active_balance to record the running task. */
+	pid_t pid;
+};
+/*#endif*/
+
+#endif /* _OPLUS_SA_COMMON_STRUCT_H_ */
+
-- 
2.51.0

