diff --git a/kernel/Kconfig b/kernel/Kconfig
index 67f177f4..ed4a4667 100644
--- a/kernel/Kconfig
+++ b/kernel/Kconfig
@@ -9,6 +9,15 @@ config KSU
 	  To compile as a module, choose M here: the
 	  module will be called kernelsu.
 
+config KSU_KRETPROBES_SUCOMPAT
+	bool "EXPERIMENTAL: kretprobes for sucompat"
+	depends on KRETPROBES
+	default y
+	help
+	  EXPERIMENTAL: Use kretprobes for hooking getname_flags, mainly for
+	  sucompat. This method will hijack all fs-related syscalls, but
+	  thwarts timing based detections.
+
 config KSU_DEBUG
 	bool "KernelSU debug mode"
 	depends on KSU
diff --git a/kernel/Makefile b/kernel/Makefile
index 732ba2d9..6c209aad 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -8,6 +8,10 @@ kernelsu-objs += ksud.o
 kernelsu-objs += embed_ksud.o
 kernelsu-objs += kernel_compat.o
 
+ifeq ($(CONFIG_KSU_KRETPROBES_SUCOMPAT),y)
+kernelsu-objs += rp_sucompat.o
+endif
+
 kernelsu-objs += selinux/selinux.o
 kernelsu-objs += selinux/sepolicy.o
 kernelsu-objs += selinux/rules.o
diff --git a/kernel/ksu.c b/kernel/ksu.c
index d517c3b5..8320e9aa 100644
--- a/kernel/ksu.c
+++ b/kernel/ksu.c
@@ -11,6 +11,10 @@
 #include "ksu.h"
 #include "throne_tracker.h"
 
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+extern void rp_sucompat_init();
+#endif 
+
 static struct workqueue_struct *ksu_workqueue;
 
 bool ksu_queue_work(struct work_struct *work)
@@ -57,6 +61,10 @@ int __init kernelsu_init(void)
 
 	ksu_throne_tracker_init();
 
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT	
+	rp_sucompat_init();
+#endif
+
 #ifdef CONFIG_KPROBES
 	ksu_sucompat_init();
 	ksu_ksud_init();
diff --git a/kernel/rp_sucompat.c b/kernel/rp_sucompat.c
new file mode 100644
index 00000000..c639dc62
--- /dev/null
+++ b/kernel/rp_sucompat.c
@@ -0,0 +1,108 @@
+#include <linux/version.h>
+#include <linux/kprobes.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/namei.h>
+
+#include "arch.h"
+#include "klog.h"
+#include "ksud.h"
+#include "kernel_compat.h"
+
+static DEFINE_MUTEX(ksu_rp_sucompat_lock);
+
+// struct filename *getname_flags(const char __user *filename, int flags, int *empty)
+// https://elixir.bootlin.com/linux/v4.9.337/source/samples/kprobes/kretprobe_example.c
+
+extern int ksu_getname_flags_kernel(char **kname, int flags);
+
+struct kretprobe *getname_rp;
+
+static int getname_flags_ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	int *flags = (int *)ri->data;
+
+	struct filename *ret = (struct filename *)PT_REGS_RC(regs);
+	if (IS_ERR(ret) || !ret || !ret->name)
+		return 0;
+
+	ksu_getname_flags_kernel((char **)&ret->name, *flags);
+	return 0;
+}
+
+static int getname_flags_entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	int *flags = (int *)ri->data; // as per sample, we store everything on ri->data ?
+	*flags = (int)PT_REGS_PARM2(regs); // keep a copy of arg2
+
+	return 0;
+}
+
+#if 0
+static struct kretprobe getname_kretprobe = {
+	.kp.symbol_name = "getname_flags",
+	.entry_handler = getname_flags_entry_handler,
+	.handler = getname_flags_ret_handler,
+	.data_size = sizeof(int),
+	.maxactive = 20,
+};
+#endif
+
+// kanged from upstrteam
+// this method allows high volume register/unregister
+static struct kretprobe *init_kretprobe(const char *symbol,
+					kretprobe_handler_t entry_handler,
+					kretprobe_handler_t ret_handler,
+					size_t data_size,
+					int maxactive)
+{
+	struct kretprobe *rp = kzalloc(sizeof(struct kretprobe), GFP_KERNEL);
+	if (!rp)
+		return NULL;
+
+	rp->kp.symbol_name = symbol;
+	rp->entry_handler = entry_handler;
+	rp->handler = ret_handler;
+	rp->data_size = data_size;
+	rp->maxactive = maxactive;
+
+	mutex_lock(&ksu_rp_sucompat_lock);
+	int ret = register_kretprobe(rp);
+	mutex_unlock(&ksu_rp_sucompat_lock);
+	if (ret) {
+		kfree(rp);
+		return NULL;
+	}
+	pr_info("rp_sucompat: planted kretprobe at %s: %p\n", rp->kp.symbol_name, rp->kp.addr);
+
+	return rp;
+}
+
+static void destroy_kretprobe(struct kretprobe **rp_ptr)
+{
+	if (!rp_ptr || !*rp_ptr)
+		return;
+
+	mutex_lock(&ksu_rp_sucompat_lock);
+	unregister_kretprobe(*rp_ptr);
+	mutex_unlock(&ksu_rp_sucompat_lock);
+	kfree(*rp_ptr);
+	*rp_ptr = NULL;
+}
+
+void rp_sucompat_exit()
+{
+	pr_info("rp_sucompat: unregister getname_flags!\n");
+	destroy_kretprobe(&getname_rp);
+	return 0;
+}
+
+void rp_sucompat_init()
+{
+	pr_info("%s: register getname_flags!\n", __func__);
+	getname_rp = init_kretprobe("getname_flags", getname_flags_entry_handler,
+			getname_flags_ret_handler, sizeof(int), 20);
+}
diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index fdfc0d59..5ee056fc 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -265,9 +265,17 @@ static void destroy_kprobe(struct kprobe **kp_ptr)
 static struct kprobe *su_kps[4];
 #endif
 
-// sucompat: permited process can execute 'su' to gain root access.
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+extern void rp_sucompat_exit();
+extern void rp_sucompat_init();
+#endif
+// sucompat: permited process can execute ' to gain root access.
 void ksu_sucompat_init()
 {
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+	rp_sucompat_init();
+#endif
+
 #ifdef CONFIG_KPROBES
 	su_kps[0] = init_kprobe(SYS_EXECVE_SYMBOL, execve_handler_pre);
 	su_kps[1] = init_kprobe(SYS_FACCESSAT_SYMBOL, faccessat_handler_pre);
@@ -278,6 +286,10 @@ void ksu_sucompat_init()
 
 void ksu_sucompat_exit()
 {
+#ifdef CONFIG_KSU_KRETPROBES_SUCOMPAT
+	rp_sucompat_exit();
+#endif
+
 #ifdef CONFIG_KPROBES
 	for (int i = 0; i < ARRAY_SIZE(su_kps); i++) {
 		destroy_kprobe(&su_kps[i]);
